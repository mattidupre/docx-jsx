"use strict";
var DocxJsxFrontend = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/.pnpm/type@1.2.0/node_modules/type/value/is.js
  var require_is = __commonJS({
    "node_modules/.pnpm/type@1.2.0/node_modules/type/value/is.js"(exports, module) {
      "use strict";
      var _undefined = void 0;
      module.exports = function(value) {
        return value !== _undefined && value !== null;
      };
    }
  });

  // node_modules/.pnpm/type@1.2.0/node_modules/type/object/is.js
  var require_is2 = __commonJS({
    "node_modules/.pnpm/type@1.2.0/node_modules/type/object/is.js"(exports, module) {
      "use strict";
      var isValue = require_is();
      var possibleTypes = {
        "object": true,
        "function": true,
        "undefined": true
        /* document.all */
      };
      module.exports = function(value) {
        if (!isValue(value))
          return false;
        return hasOwnProperty.call(possibleTypes, typeof value);
      };
    }
  });

  // node_modules/.pnpm/type@1.2.0/node_modules/type/prototype/is.js
  var require_is3 = __commonJS({
    "node_modules/.pnpm/type@1.2.0/node_modules/type/prototype/is.js"(exports, module) {
      "use strict";
      var isObject = require_is2();
      module.exports = function(value) {
        if (!isObject(value))
          return false;
        try {
          if (!value.constructor)
            return false;
          return value.constructor.prototype === value;
        } catch (error) {
          return false;
        }
      };
    }
  });

  // node_modules/.pnpm/type@1.2.0/node_modules/type/function/is.js
  var require_is4 = __commonJS({
    "node_modules/.pnpm/type@1.2.0/node_modules/type/function/is.js"(exports, module) {
      "use strict";
      var isPrototype = require_is3();
      module.exports = function(value) {
        if (typeof value !== "function")
          return false;
        if (!hasOwnProperty.call(value, "length"))
          return false;
        try {
          if (typeof value.length !== "number")
            return false;
          if (typeof value.call !== "function")
            return false;
          if (typeof value.apply !== "function")
            return false;
        } catch (error) {
          return false;
        }
        return !isPrototype(value);
      };
    }
  });

  // node_modules/.pnpm/type@1.2.0/node_modules/type/plain-function/is.js
  var require_is5 = __commonJS({
    "node_modules/.pnpm/type@1.2.0/node_modules/type/plain-function/is.js"(exports, module) {
      "use strict";
      var isFunction = require_is4();
      var classRe = /^\s*class[\s{/}]/;
      var functionToString = Function.prototype.toString;
      module.exports = function(value) {
        if (!isFunction(value))
          return false;
        if (classRe.test(functionToString.call(value)))
          return false;
        return true;
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/assign/is-implemented.js
  var require_is_implemented = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/assign/is-implemented.js"(exports, module) {
      "use strict";
      module.exports = function() {
        var assign = Object.assign, obj;
        if (typeof assign !== "function")
          return false;
        obj = { foo: "raz" };
        assign(obj, { bar: "dwa" }, { trzy: "trzy" });
        return obj.foo + obj.bar + obj.trzy === "razdwatrzy";
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/keys/is-implemented.js
  var require_is_implemented2 = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/keys/is-implemented.js"(exports, module) {
      "use strict";
      module.exports = function() {
        try {
          Object.keys("primitive");
          return true;
        } catch (e) {
          return false;
        }
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/function/noop.js
  var require_noop = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/function/noop.js"(exports, module) {
      "use strict";
      module.exports = function() {
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/is-value.js
  var require_is_value = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/is-value.js"(exports, module) {
      "use strict";
      var _undefined = require_noop()();
      module.exports = function(val) {
        return val !== _undefined && val !== null;
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/keys/shim.js
  var require_shim = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/keys/shim.js"(exports, module) {
      "use strict";
      var isValue = require_is_value();
      var keys = Object.keys;
      module.exports = function(object) {
        return keys(isValue(object) ? Object(object) : object);
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/keys/index.js
  var require_keys = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/keys/index.js"(exports, module) {
      "use strict";
      module.exports = require_is_implemented2()() ? Object.keys : require_shim();
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/valid-value.js
  var require_valid_value = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/valid-value.js"(exports, module) {
      "use strict";
      var isValue = require_is_value();
      module.exports = function(value) {
        if (!isValue(value))
          throw new TypeError("Cannot use null or undefined");
        return value;
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/assign/shim.js
  var require_shim2 = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/assign/shim.js"(exports, module) {
      "use strict";
      var keys = require_keys();
      var value = require_valid_value();
      var max = Math.max;
      module.exports = function(dest, src2) {
        var error, i, length = max(arguments.length, 2), assign;
        dest = Object(value(dest));
        assign = function(key) {
          try {
            dest[key] = src2[key];
          } catch (e) {
            if (!error)
              error = e;
          }
        };
        for (i = 1; i < length; ++i) {
          src2 = arguments[i];
          keys(src2).forEach(assign);
        }
        if (error !== void 0)
          throw error;
        return dest;
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/assign/index.js
  var require_assign = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/assign/index.js"(exports, module) {
      "use strict";
      module.exports = require_is_implemented()() ? Object.assign : require_shim2();
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/normalize-options.js
  var require_normalize_options = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/normalize-options.js"(exports, module) {
      "use strict";
      var isValue = require_is_value();
      var forEach = Array.prototype.forEach;
      var create = Object.create;
      var process2 = function(src2, obj) {
        var key;
        for (key in src2)
          obj[key] = src2[key];
      };
      module.exports = function(opts1) {
        var result = create(null);
        forEach.call(arguments, function(options) {
          if (!isValue(options))
            return;
          process2(Object(options), result);
        });
        return result;
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/string/#/contains/is-implemented.js
  var require_is_implemented3 = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/string/#/contains/is-implemented.js"(exports, module) {
      "use strict";
      var str = "razdwatrzy";
      module.exports = function() {
        if (typeof str.contains !== "function")
          return false;
        return str.contains("dwa") === true && str.contains("foo") === false;
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/string/#/contains/shim.js
  var require_shim3 = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/string/#/contains/shim.js"(exports, module) {
      "use strict";
      var indexOf2 = String.prototype.indexOf;
      module.exports = function(searchString) {
        return indexOf2.call(this, searchString, arguments[1]) > -1;
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/string/#/contains/index.js
  var require_contains = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/string/#/contains/index.js"(exports, module) {
      "use strict";
      module.exports = require_is_implemented3()() ? String.prototype.contains : require_shim3();
    }
  });

  // node_modules/.pnpm/d@1.0.1/node_modules/d/index.js
  var require_d = __commonJS({
    "node_modules/.pnpm/d@1.0.1/node_modules/d/index.js"(exports, module) {
      "use strict";
      var isValue = require_is();
      var isPlainFunction = require_is5();
      var assign = require_assign();
      var normalizeOpts = require_normalize_options();
      var contains = require_contains();
      var d = module.exports = function(dscr, value) {
        var c, e, w, options, desc;
        if (arguments.length < 2 || typeof dscr !== "string") {
          options = value;
          value = dscr;
          dscr = null;
        } else {
          options = arguments[2];
        }
        if (isValue(dscr)) {
          c = contains.call(dscr, "c");
          e = contains.call(dscr, "e");
          w = contains.call(dscr, "w");
        } else {
          c = w = true;
          e = false;
        }
        desc = { value, configurable: c, enumerable: e, writable: w };
        return !options ? desc : assign(normalizeOpts(options), desc);
      };
      d.gs = function(dscr, get, set) {
        var c, e, options, desc;
        if (typeof dscr !== "string") {
          options = set;
          set = get;
          get = dscr;
          dscr = null;
        } else {
          options = arguments[3];
        }
        if (!isValue(get)) {
          get = void 0;
        } else if (!isPlainFunction(get)) {
          options = get;
          get = set = void 0;
        } else if (!isValue(set)) {
          set = void 0;
        } else if (!isPlainFunction(set)) {
          options = set;
          set = void 0;
        }
        if (isValue(dscr)) {
          c = contains.call(dscr, "c");
          e = contains.call(dscr, "e");
        } else {
          c = true;
          e = false;
        }
        desc = { get, set, configurable: c, enumerable: e };
        return !options ? desc : assign(normalizeOpts(options), desc);
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/valid-callable.js
  var require_valid_callable = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/valid-callable.js"(exports, module) {
      "use strict";
      module.exports = function(fn) {
        if (typeof fn !== "function")
          throw new TypeError(fn + " is not a function");
        return fn;
      };
    }
  });

  // node_modules/.pnpm/event-emitter@0.3.5/node_modules/event-emitter/index.js
  var require_event_emitter = __commonJS({
    "node_modules/.pnpm/event-emitter@0.3.5/node_modules/event-emitter/index.js"(exports, module) {
      "use strict";
      var d = require_d();
      var callable = require_valid_callable();
      var apply = Function.prototype.apply;
      var call = Function.prototype.call;
      var create = Object.create;
      var defineProperty = Object.defineProperty;
      var defineProperties = Object.defineProperties;
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var descriptor = { configurable: true, enumerable: false, writable: true };
      var on;
      var once3;
      var off;
      var emit2;
      var methods;
      var descriptors;
      var base;
      on = function(type, listener) {
        var data;
        callable(listener);
        if (!hasOwnProperty2.call(this, "__ee__")) {
          data = descriptor.value = create(null);
          defineProperty(this, "__ee__", descriptor);
          descriptor.value = null;
        } else {
          data = this.__ee__;
        }
        if (!data[type])
          data[type] = listener;
        else if (typeof data[type] === "object")
          data[type].push(listener);
        else
          data[type] = [data[type], listener];
        return this;
      };
      once3 = function(type, listener) {
        var once4, self2;
        callable(listener);
        self2 = this;
        on.call(this, type, once4 = function() {
          off.call(self2, type, once4);
          apply.call(listener, this, arguments);
        });
        once4.__eeOnceListener__ = listener;
        return this;
      };
      off = function(type, listener) {
        var data, listeners2, candidate, i;
        callable(listener);
        if (!hasOwnProperty2.call(this, "__ee__"))
          return this;
        data = this.__ee__;
        if (!data[type])
          return this;
        listeners2 = data[type];
        if (typeof listeners2 === "object") {
          for (i = 0; candidate = listeners2[i]; ++i) {
            if (candidate === listener || candidate.__eeOnceListener__ === listener) {
              if (listeners2.length === 2)
                data[type] = listeners2[i ? 0 : 1];
              else
                listeners2.splice(i, 1);
            }
          }
        } else {
          if (listeners2 === listener || listeners2.__eeOnceListener__ === listener) {
            delete data[type];
          }
        }
        return this;
      };
      emit2 = function(type) {
        var i, l, listener, listeners2, args;
        if (!hasOwnProperty2.call(this, "__ee__"))
          return;
        listeners2 = this.__ee__[type];
        if (!listeners2)
          return;
        if (typeof listeners2 === "object") {
          l = arguments.length;
          args = new Array(l - 1);
          for (i = 1; i < l; ++i)
            args[i - 1] = arguments[i];
          listeners2 = listeners2.slice();
          for (i = 0; listener = listeners2[i]; ++i) {
            apply.call(listener, this, args);
          }
        } else {
          switch (arguments.length) {
            case 1:
              call.call(listeners2, this);
              break;
            case 2:
              call.call(listeners2, this, arguments[1]);
              break;
            case 3:
              call.call(listeners2, this, arguments[1], arguments[2]);
              break;
            default:
              l = arguments.length;
              args = new Array(l - 1);
              for (i = 1; i < l; ++i) {
                args[i - 1] = arguments[i];
              }
              apply.call(listeners2, this, args);
          }
        }
      };
      methods = {
        on,
        once: once3,
        off,
        emit: emit2
      };
      descriptors = {
        on: d(on),
        once: d(once3),
        off: d(off),
        emit: d(emit2)
      };
      base = defineProperties({}, descriptors);
      module.exports = exports = function(o) {
        return o == null ? create(base) : defineProperties(Object(o), descriptors);
      };
      exports.methods = methods;
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/common/List.js
  var require_List = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/common/List.js"(exports, module) {
      function createItem(data) {
        return {
          prev: null,
          next: null,
          data
        };
      }
      function allocateCursor(node, prev, next) {
        var cursor;
        if (cursors !== null) {
          cursor = cursors;
          cursors = cursors.cursor;
          cursor.prev = prev;
          cursor.next = next;
          cursor.cursor = node.cursor;
        } else {
          cursor = {
            prev,
            next,
            cursor: node.cursor
          };
        }
        node.cursor = cursor;
        return cursor;
      }
      function releaseCursor(node) {
        var cursor = node.cursor;
        node.cursor = cursor.cursor;
        cursor.prev = null;
        cursor.next = null;
        cursor.cursor = cursors;
        cursors = cursor;
      }
      var cursors = null;
      var List = function() {
        this.cursor = null;
        this.head = null;
        this.tail = null;
      };
      List.createItem = createItem;
      List.prototype.createItem = createItem;
      List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
        var cursor = this.cursor;
        while (cursor !== null) {
          if (cursor.prev === prevOld) {
            cursor.prev = prevNew;
          }
          if (cursor.next === nextOld) {
            cursor.next = nextNew;
          }
          cursor = cursor.cursor;
        }
      };
      List.prototype.getSize = function() {
        var size = 0;
        var cursor = this.head;
        while (cursor) {
          size++;
          cursor = cursor.next;
        }
        return size;
      };
      List.prototype.fromArray = function(array) {
        var cursor = null;
        this.head = null;
        for (var i = 0; i < array.length; i++) {
          var item = createItem(array[i]);
          if (cursor !== null) {
            cursor.next = item;
          } else {
            this.head = item;
          }
          item.prev = cursor;
          cursor = item;
        }
        this.tail = cursor;
        return this;
      };
      List.prototype.toArray = function() {
        var cursor = this.head;
        var result = [];
        while (cursor) {
          result.push(cursor.data);
          cursor = cursor.next;
        }
        return result;
      };
      List.prototype.toJSON = List.prototype.toArray;
      List.prototype.isEmpty = function() {
        return this.head === null;
      };
      List.prototype.first = function() {
        return this.head && this.head.data;
      };
      List.prototype.last = function() {
        return this.tail && this.tail.data;
      };
      List.prototype.each = function(fn, context) {
        var item;
        if (context === void 0) {
          context = this;
        }
        var cursor = allocateCursor(this, null, this.head);
        while (cursor.next !== null) {
          item = cursor.next;
          cursor.next = item.next;
          fn.call(context, item.data, item, this);
        }
        releaseCursor(this);
      };
      List.prototype.forEach = List.prototype.each;
      List.prototype.eachRight = function(fn, context) {
        var item;
        if (context === void 0) {
          context = this;
        }
        var cursor = allocateCursor(this, this.tail, null);
        while (cursor.prev !== null) {
          item = cursor.prev;
          cursor.prev = item.prev;
          fn.call(context, item.data, item, this);
        }
        releaseCursor(this);
      };
      List.prototype.forEachRight = List.prototype.eachRight;
      List.prototype.reduce = function(fn, initialValue, context) {
        var item;
        if (context === void 0) {
          context = this;
        }
        var cursor = allocateCursor(this, null, this.head);
        var acc = initialValue;
        while (cursor.next !== null) {
          item = cursor.next;
          cursor.next = item.next;
          acc = fn.call(context, acc, item.data, item, this);
        }
        releaseCursor(this);
        return acc;
      };
      List.prototype.reduceRight = function(fn, initialValue, context) {
        var item;
        if (context === void 0) {
          context = this;
        }
        var cursor = allocateCursor(this, this.tail, null);
        var acc = initialValue;
        while (cursor.prev !== null) {
          item = cursor.prev;
          cursor.prev = item.prev;
          acc = fn.call(context, acc, item.data, item, this);
        }
        releaseCursor(this);
        return acc;
      };
      List.prototype.nextUntil = function(start, fn, context) {
        if (start === null) {
          return;
        }
        var item;
        if (context === void 0) {
          context = this;
        }
        var cursor = allocateCursor(this, null, start);
        while (cursor.next !== null) {
          item = cursor.next;
          cursor.next = item.next;
          if (fn.call(context, item.data, item, this)) {
            break;
          }
        }
        releaseCursor(this);
      };
      List.prototype.prevUntil = function(start, fn, context) {
        if (start === null) {
          return;
        }
        var item;
        if (context === void 0) {
          context = this;
        }
        var cursor = allocateCursor(this, start, null);
        while (cursor.prev !== null) {
          item = cursor.prev;
          cursor.prev = item.prev;
          if (fn.call(context, item.data, item, this)) {
            break;
          }
        }
        releaseCursor(this);
      };
      List.prototype.some = function(fn, context) {
        var cursor = this.head;
        if (context === void 0) {
          context = this;
        }
        while (cursor !== null) {
          if (fn.call(context, cursor.data, cursor, this)) {
            return true;
          }
          cursor = cursor.next;
        }
        return false;
      };
      List.prototype.map = function(fn, context) {
        var result = new List();
        var cursor = this.head;
        if (context === void 0) {
          context = this;
        }
        while (cursor !== null) {
          result.appendData(fn.call(context, cursor.data, cursor, this));
          cursor = cursor.next;
        }
        return result;
      };
      List.prototype.filter = function(fn, context) {
        var result = new List();
        var cursor = this.head;
        if (context === void 0) {
          context = this;
        }
        while (cursor !== null) {
          if (fn.call(context, cursor.data, cursor, this)) {
            result.appendData(cursor.data);
          }
          cursor = cursor.next;
        }
        return result;
      };
      List.prototype.clear = function() {
        this.head = null;
        this.tail = null;
      };
      List.prototype.copy = function() {
        var result = new List();
        var cursor = this.head;
        while (cursor !== null) {
          result.insert(createItem(cursor.data));
          cursor = cursor.next;
        }
        return result;
      };
      List.prototype.prepend = function(item) {
        this.updateCursors(null, item, this.head, item);
        if (this.head !== null) {
          this.head.prev = item;
          item.next = this.head;
        } else {
          this.tail = item;
        }
        this.head = item;
        return this;
      };
      List.prototype.prependData = function(data) {
        return this.prepend(createItem(data));
      };
      List.prototype.append = function(item) {
        return this.insert(item);
      };
      List.prototype.appendData = function(data) {
        return this.insert(createItem(data));
      };
      List.prototype.insert = function(item, before) {
        if (before !== void 0 && before !== null) {
          this.updateCursors(before.prev, item, before, item);
          if (before.prev === null) {
            if (this.head !== before) {
              throw new Error("before doesn't belong to list");
            }
            this.head = item;
            before.prev = item;
            item.next = before;
            this.updateCursors(null, item);
          } else {
            before.prev.next = item;
            item.prev = before.prev;
            before.prev = item;
            item.next = before;
          }
        } else {
          this.updateCursors(this.tail, item, null, item);
          if (this.tail !== null) {
            this.tail.next = item;
            item.prev = this.tail;
          } else {
            this.head = item;
          }
          this.tail = item;
        }
        return this;
      };
      List.prototype.insertData = function(data, before) {
        return this.insert(createItem(data), before);
      };
      List.prototype.remove = function(item) {
        this.updateCursors(item, item.prev, item, item.next);
        if (item.prev !== null) {
          item.prev.next = item.next;
        } else {
          if (this.head !== item) {
            throw new Error("item doesn't belong to list");
          }
          this.head = item.next;
        }
        if (item.next !== null) {
          item.next.prev = item.prev;
        } else {
          if (this.tail !== item) {
            throw new Error("item doesn't belong to list");
          }
          this.tail = item.prev;
        }
        item.prev = null;
        item.next = null;
        return item;
      };
      List.prototype.push = function(data) {
        this.insert(createItem(data));
      };
      List.prototype.pop = function() {
        if (this.tail !== null) {
          return this.remove(this.tail);
        }
      };
      List.prototype.unshift = function(data) {
        this.prepend(createItem(data));
      };
      List.prototype.shift = function() {
        if (this.head !== null) {
          return this.remove(this.head);
        }
      };
      List.prototype.prependList = function(list) {
        return this.insertList(list, this.head);
      };
      List.prototype.appendList = function(list) {
        return this.insertList(list);
      };
      List.prototype.insertList = function(list, before) {
        if (list.head === null) {
          return this;
        }
        if (before !== void 0 && before !== null) {
          this.updateCursors(before.prev, list.tail, before, list.head);
          if (before.prev !== null) {
            before.prev.next = list.head;
            list.head.prev = before.prev;
          } else {
            this.head = list.head;
          }
          before.prev = list.tail;
          list.tail.next = before;
        } else {
          this.updateCursors(this.tail, list.tail, null, list.head);
          if (this.tail !== null) {
            this.tail.next = list.head;
            list.head.prev = this.tail;
          } else {
            this.head = list.head;
          }
          this.tail = list.tail;
        }
        list.head = null;
        list.tail = null;
        return this;
      };
      List.prototype.replace = function(oldItem, newItemOrList) {
        if ("head" in newItemOrList) {
          this.insertList(newItemOrList, oldItem);
        } else {
          this.insert(newItemOrList, oldItem);
        }
        this.remove(oldItem);
      };
      module.exports = List;
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/utils/createCustomError.js
  var require_createCustomError = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/utils/createCustomError.js"(exports, module) {
      module.exports = function createCustomError(name, message) {
        var error = Object.create(SyntaxError.prototype);
        var errorStack = new Error();
        error.name = name;
        error.message = message;
        Object.defineProperty(error, "stack", {
          get: function() {
            return (errorStack.stack || "").replace(/^(.+\n){1,3}/, name + ": " + message + "\n");
          }
        });
        return error;
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/common/SyntaxError.js
  var require_SyntaxError = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/common/SyntaxError.js"(exports, module) {
      var createCustomError = require_createCustomError();
      var MAX_LINE_LENGTH = 100;
      var OFFSET_CORRECTION = 60;
      var TAB_REPLACEMENT = "    ";
      function sourceFragment(error, extraLines) {
        function processLines(start, end) {
          return lines.slice(start, end).map(function(line2, idx) {
            var num = String(start + idx + 1);
            while (num.length < maxNumLength) {
              num = " " + num;
            }
            return num + " |" + line2;
          }).join("\n");
        }
        var lines = error.source.split(/\r\n?|\n|\f/);
        var line = error.line;
        var column = error.column;
        var startLine = Math.max(1, line - extraLines) - 1;
        var endLine = Math.min(line + extraLines, lines.length + 1);
        var maxNumLength = Math.max(4, String(endLine).length) + 1;
        var cutLeft = 0;
        column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;
        if (column > MAX_LINE_LENGTH) {
          cutLeft = column - OFFSET_CORRECTION + 3;
          column = OFFSET_CORRECTION - 2;
        }
        for (var i = startLine; i <= endLine; i++) {
          if (i >= 0 && i < lines.length) {
            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
            lines[i] = (cutLeft > 0 && lines[i].length > cutLeft ? "\u2026" : "") + lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? "\u2026" : "");
          }
        }
        return [
          processLines(startLine, line),
          new Array(column + maxNumLength + 2).join("-") + "^",
          processLines(line, endLine)
        ].filter(Boolean).join("\n");
      }
      var SyntaxError2 = function(message, source, offset, line, column) {
        var error = createCustomError("SyntaxError", message);
        error.source = source;
        error.offset = offset;
        error.line = line;
        error.column = column;
        error.sourceFragment = function(extraLines) {
          return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
        };
        Object.defineProperty(error, "formattedMessage", {
          get: function() {
            return "Parse error: " + error.message + "\n" + sourceFragment(error, 2);
          }
        });
        error.parseError = {
          offset,
          line,
          column
        };
        return error;
      };
      module.exports = SyntaxError2;
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/tokenizer/const.js
  var require_const = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/tokenizer/const.js"(exports, module) {
      var TYPE = {
        EOF: 0,
        // <EOF-token>
        Ident: 1,
        // <ident-token>
        Function: 2,
        // <function-token>
        AtKeyword: 3,
        // <at-keyword-token>
        Hash: 4,
        // <hash-token>
        String: 5,
        // <string-token>
        BadString: 6,
        // <bad-string-token>
        Url: 7,
        // <url-token>
        BadUrl: 8,
        // <bad-url-token>
        Delim: 9,
        // <delim-token>
        Number: 10,
        // <number-token>
        Percentage: 11,
        // <percentage-token>
        Dimension: 12,
        // <dimension-token>
        WhiteSpace: 13,
        // <whitespace-token>
        CDO: 14,
        // <CDO-token>
        CDC: 15,
        // <CDC-token>
        Colon: 16,
        // <colon-token>     :
        Semicolon: 17,
        // <semicolon-token> ;
        Comma: 18,
        // <comma-token>     ,
        LeftSquareBracket: 19,
        // <[-token>
        RightSquareBracket: 20,
        // <]-token>
        LeftParenthesis: 21,
        // <(-token>
        RightParenthesis: 22,
        // <)-token>
        LeftCurlyBracket: 23,
        // <{-token>
        RightCurlyBracket: 24,
        // <}-token>
        Comment: 25
      };
      var NAME = Object.keys(TYPE).reduce(function(result, key) {
        result[TYPE[key]] = key;
        return result;
      }, {});
      module.exports = {
        TYPE,
        NAME
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/tokenizer/char-code-definitions.js
  var require_char_code_definitions = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/tokenizer/char-code-definitions.js"(exports, module) {
      var EOF = 0;
      function isDigit(code) {
        return code >= 48 && code <= 57;
      }
      function isHexDigit(code) {
        return isDigit(code) || // 0 .. 9
        code >= 65 && code <= 70 || // A .. F
        code >= 97 && code <= 102;
      }
      function isUppercaseLetter(code) {
        return code >= 65 && code <= 90;
      }
      function isLowercaseLetter(code) {
        return code >= 97 && code <= 122;
      }
      function isLetter(code) {
        return isUppercaseLetter(code) || isLowercaseLetter(code);
      }
      function isNonAscii(code) {
        return code >= 128;
      }
      function isNameStart(code) {
        return isLetter(code) || isNonAscii(code) || code === 95;
      }
      function isName(code) {
        return isNameStart(code) || isDigit(code) || code === 45;
      }
      function isNonPrintable(code) {
        return code >= 0 && code <= 8 || code === 11 || code >= 14 && code <= 31 || code === 127;
      }
      function isNewline(code) {
        return code === 10 || code === 13 || code === 12;
      }
      function isWhiteSpace(code) {
        return isNewline(code) || code === 32 || code === 9;
      }
      function isValidEscape(first, second) {
        if (first !== 92) {
          return false;
        }
        if (isNewline(second) || second === EOF) {
          return false;
        }
        return true;
      }
      function isIdentifierStart(first, second, third) {
        if (first === 45) {
          return isNameStart(second) || second === 45 || isValidEscape(second, third);
        }
        if (isNameStart(first)) {
          return true;
        }
        if (first === 92) {
          return isValidEscape(first, second);
        }
        return false;
      }
      function isNumberStart(first, second, third) {
        if (first === 43 || first === 45) {
          if (isDigit(second)) {
            return 2;
          }
          return second === 46 && isDigit(third) ? 3 : 0;
        }
        if (first === 46) {
          return isDigit(second) ? 2 : 0;
        }
        if (isDigit(first)) {
          return 1;
        }
        return 0;
      }
      function isBOM(code) {
        if (code === 65279) {
          return 1;
        }
        if (code === 65534) {
          return 1;
        }
        return 0;
      }
      var CATEGORY = new Array(128);
      charCodeCategory.Eof = 128;
      charCodeCategory.WhiteSpace = 130;
      charCodeCategory.Digit = 131;
      charCodeCategory.NameStart = 132;
      charCodeCategory.NonPrintable = 133;
      for (i = 0; i < CATEGORY.length; i++) {
        switch (true) {
          case isWhiteSpace(i):
            CATEGORY[i] = charCodeCategory.WhiteSpace;
            break;
          case isDigit(i):
            CATEGORY[i] = charCodeCategory.Digit;
            break;
          case isNameStart(i):
            CATEGORY[i] = charCodeCategory.NameStart;
            break;
          case isNonPrintable(i):
            CATEGORY[i] = charCodeCategory.NonPrintable;
            break;
          default:
            CATEGORY[i] = i || charCodeCategory.Eof;
        }
      }
      var i;
      function charCodeCategory(code) {
        return code < 128 ? CATEGORY[code] : charCodeCategory.NameStart;
      }
      module.exports = {
        isDigit,
        isHexDigit,
        isUppercaseLetter,
        isLowercaseLetter,
        isLetter,
        isNonAscii,
        isNameStart,
        isName,
        isNonPrintable,
        isNewline,
        isWhiteSpace,
        isValidEscape,
        isIdentifierStart,
        isNumberStart,
        isBOM,
        charCodeCategory
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/tokenizer/utils.js
  var require_utils = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/tokenizer/utils.js"(exports, module) {
      var charCodeDef = require_char_code_definitions();
      var isDigit = charCodeDef.isDigit;
      var isHexDigit = charCodeDef.isHexDigit;
      var isUppercaseLetter = charCodeDef.isUppercaseLetter;
      var isName = charCodeDef.isName;
      var isWhiteSpace = charCodeDef.isWhiteSpace;
      var isValidEscape = charCodeDef.isValidEscape;
      function getCharCode(source, offset) {
        return offset < source.length ? source.charCodeAt(offset) : 0;
      }
      function getNewlineLength(source, offset, code) {
        if (code === 13 && getCharCode(source, offset + 1) === 10) {
          return 2;
        }
        return 1;
      }
      function cmpChar(testStr, offset, referenceCode) {
        var code = testStr.charCodeAt(offset);
        if (isUppercaseLetter(code)) {
          code = code | 32;
        }
        return code === referenceCode;
      }
      function cmpStr(testStr, start, end, referenceStr) {
        if (end - start !== referenceStr.length) {
          return false;
        }
        if (start < 0 || end > testStr.length) {
          return false;
        }
        for (var i = start; i < end; i++) {
          var testCode = testStr.charCodeAt(i);
          var referenceCode = referenceStr.charCodeAt(i - start);
          if (isUppercaseLetter(testCode)) {
            testCode = testCode | 32;
          }
          if (testCode !== referenceCode) {
            return false;
          }
        }
        return true;
      }
      function findWhiteSpaceStart(source, offset) {
        for (; offset >= 0; offset--) {
          if (!isWhiteSpace(source.charCodeAt(offset))) {
            break;
          }
        }
        return offset + 1;
      }
      function findWhiteSpaceEnd(source, offset) {
        for (; offset < source.length; offset++) {
          if (!isWhiteSpace(source.charCodeAt(offset))) {
            break;
          }
        }
        return offset;
      }
      function findDecimalNumberEnd(source, offset) {
        for (; offset < source.length; offset++) {
          if (!isDigit(source.charCodeAt(offset))) {
            break;
          }
        }
        return offset;
      }
      function consumeEscaped(source, offset) {
        offset += 2;
        if (isHexDigit(getCharCode(source, offset - 1))) {
          for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
            if (!isHexDigit(getCharCode(source, offset))) {
              break;
            }
          }
          var code = getCharCode(source, offset);
          if (isWhiteSpace(code)) {
            offset += getNewlineLength(source, offset, code);
          }
        }
        return offset;
      }
      function consumeName(source, offset) {
        for (; offset < source.length; offset++) {
          var code = source.charCodeAt(offset);
          if (isName(code)) {
            continue;
          }
          if (isValidEscape(code, getCharCode(source, offset + 1))) {
            offset = consumeEscaped(source, offset) - 1;
            continue;
          }
          break;
        }
        return offset;
      }
      function consumeNumber(source, offset) {
        var code = source.charCodeAt(offset);
        if (code === 43 || code === 45) {
          code = source.charCodeAt(offset += 1);
        }
        if (isDigit(code)) {
          offset = findDecimalNumberEnd(source, offset + 1);
          code = source.charCodeAt(offset);
        }
        if (code === 46 && isDigit(source.charCodeAt(offset + 1))) {
          code = source.charCodeAt(offset += 2);
          offset = findDecimalNumberEnd(source, offset);
        }
        if (cmpChar(
          source,
          offset,
          101
          /* e */
        )) {
          var sign = 0;
          code = source.charCodeAt(offset + 1);
          if (code === 45 || code === 43) {
            sign = 1;
            code = source.charCodeAt(offset + 2);
          }
          if (isDigit(code)) {
            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
          }
        }
        return offset;
      }
      function consumeBadUrlRemnants(source, offset) {
        for (; offset < source.length; offset++) {
          var code = source.charCodeAt(offset);
          if (code === 41) {
            offset++;
            break;
          }
          if (isValidEscape(code, getCharCode(source, offset + 1))) {
            offset = consumeEscaped(source, offset);
          }
        }
        return offset;
      }
      module.exports = {
        consumeEscaped,
        consumeName,
        consumeNumber,
        consumeBadUrlRemnants,
        cmpChar,
        cmpStr,
        getNewlineLength,
        findWhiteSpaceStart,
        findWhiteSpaceEnd
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/common/TokenStream.js
  var require_TokenStream = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/common/TokenStream.js"(exports, module) {
      var constants = require_const();
      var TYPE = constants.TYPE;
      var NAME = constants.NAME;
      var utils = require_utils();
      var cmpStr = utils.cmpStr;
      var EOF = TYPE.EOF;
      var WHITESPACE = TYPE.WhiteSpace;
      var COMMENT = TYPE.Comment;
      var OFFSET_MASK = 16777215;
      var TYPE_SHIFT = 24;
      var TokenStream = function() {
        this.offsetAndType = null;
        this.balance = null;
        this.reset();
      };
      TokenStream.prototype = {
        reset: function() {
          this.eof = false;
          this.tokenIndex = -1;
          this.tokenType = 0;
          this.tokenStart = this.firstCharOffset;
          this.tokenEnd = this.firstCharOffset;
        },
        lookupType: function(offset) {
          offset += this.tokenIndex;
          if (offset < this.tokenCount) {
            return this.offsetAndType[offset] >> TYPE_SHIFT;
          }
          return EOF;
        },
        lookupOffset: function(offset) {
          offset += this.tokenIndex;
          if (offset < this.tokenCount) {
            return this.offsetAndType[offset - 1] & OFFSET_MASK;
          }
          return this.source.length;
        },
        lookupValue: function(offset, referenceStr) {
          offset += this.tokenIndex;
          if (offset < this.tokenCount) {
            return cmpStr(
              this.source,
              this.offsetAndType[offset - 1] & OFFSET_MASK,
              this.offsetAndType[offset] & OFFSET_MASK,
              referenceStr
            );
          }
          return false;
        },
        getTokenStart: function(tokenIndex) {
          if (tokenIndex === this.tokenIndex) {
            return this.tokenStart;
          }
          if (tokenIndex > 0) {
            return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
          }
          return this.firstCharOffset;
        },
        // TODO: -> skipUntilBalanced
        getRawLength: function(startToken, mode) {
          var cursor = startToken;
          var balanceEnd;
          var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
          var type;
          loop:
            for (; cursor < this.tokenCount; cursor++) {
              balanceEnd = this.balance[cursor];
              if (balanceEnd < startToken) {
                break loop;
              }
              type = this.offsetAndType[cursor] >> TYPE_SHIFT;
              switch (mode(type, this.source, offset)) {
                case 1:
                  break loop;
                case 2:
                  cursor++;
                  break loop;
                default:
                  if (this.balance[balanceEnd] === cursor) {
                    cursor = balanceEnd;
                  }
                  offset = this.offsetAndType[cursor] & OFFSET_MASK;
              }
            }
          return cursor - this.tokenIndex;
        },
        isBalanceEdge: function(pos) {
          return this.balance[this.tokenIndex] < pos;
        },
        isDelim: function(code, offset) {
          if (offset) {
            return this.lookupType(offset) === TYPE.Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code;
          }
          return this.tokenType === TYPE.Delim && this.source.charCodeAt(this.tokenStart) === code;
        },
        getTokenValue: function() {
          return this.source.substring(this.tokenStart, this.tokenEnd);
        },
        getTokenLength: function() {
          return this.tokenEnd - this.tokenStart;
        },
        substrToCursor: function(start) {
          return this.source.substring(start, this.tokenStart);
        },
        skipWS: function() {
          for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
            if (this.offsetAndType[i] >> TYPE_SHIFT !== WHITESPACE) {
              break;
            }
          }
          if (skipTokenCount > 0) {
            this.skip(skipTokenCount);
          }
        },
        skipSC: function() {
          while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
            this.next();
          }
        },
        skip: function(tokenCount) {
          var next = this.tokenIndex + tokenCount;
          if (next < this.tokenCount) {
            this.tokenIndex = next;
            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
          } else {
            this.tokenIndex = this.tokenCount;
            this.next();
          }
        },
        next: function() {
          var next = this.tokenIndex + 1;
          if (next < this.tokenCount) {
            this.tokenIndex = next;
            this.tokenStart = this.tokenEnd;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
          } else {
            this.tokenIndex = this.tokenCount;
            this.eof = true;
            this.tokenType = EOF;
            this.tokenStart = this.tokenEnd = this.source.length;
          }
        },
        forEachToken(fn) {
          for (var i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {
            var start = offset;
            var item = this.offsetAndType[i];
            var end = item & OFFSET_MASK;
            var type = item >> TYPE_SHIFT;
            offset = end;
            fn(type, start, end, i);
          }
        },
        dump() {
          var tokens = new Array(this.tokenCount);
          this.forEachToken((type, start, end, index) => {
            tokens[index] = {
              idx: index,
              type: NAME[type],
              chunk: this.source.substring(start, end),
              balance: this.balance[index]
            };
          });
          return tokens;
        }
      };
      module.exports = TokenStream;
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/definition-syntax/generate.js
  var require_generate = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/definition-syntax/generate.js"(exports, module) {
      function noop2(value) {
        return value;
      }
      function generateMultiplier(multiplier) {
        if (multiplier.min === 0 && multiplier.max === 0) {
          return "*";
        }
        if (multiplier.min === 0 && multiplier.max === 1) {
          return "?";
        }
        if (multiplier.min === 1 && multiplier.max === 0) {
          return multiplier.comma ? "#" : "+";
        }
        if (multiplier.min === 1 && multiplier.max === 1) {
          return "";
        }
        return (multiplier.comma ? "#" : "") + (multiplier.min === multiplier.max ? "{" + multiplier.min + "}" : "{" + multiplier.min + "," + (multiplier.max !== 0 ? multiplier.max : "") + "}");
      }
      function generateTypeOpts(node) {
        switch (node.type) {
          case "Range":
            return " [" + (node.min === null ? "-\u221E" : node.min) + "," + (node.max === null ? "\u221E" : node.max) + "]";
          default:
            throw new Error("Unknown node type `" + node.type + "`");
        }
      }
      function generateSequence(node, decorate, forceBraces, compact) {
        var combinator = node.combinator === " " || compact ? node.combinator : " " + node.combinator + " ";
        var result = node.terms.map(function(term) {
          return generate(term, decorate, forceBraces, compact);
        }).join(combinator);
        if (node.explicit || forceBraces) {
          result = (compact || result[0] === "," ? "[" : "[ ") + result + (compact ? "]" : " ]");
        }
        return result;
      }
      function generate(node, decorate, forceBraces, compact) {
        var result;
        switch (node.type) {
          case "Group":
            result = generateSequence(node, decorate, forceBraces, compact) + (node.disallowEmpty ? "!" : "");
            break;
          case "Multiplier":
            return generate(node.term, decorate, forceBraces, compact) + decorate(generateMultiplier(node), node);
          case "Type":
            result = "<" + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : "") + ">";
            break;
          case "Property":
            result = "<'" + node.name + "'>";
            break;
          case "Keyword":
            result = node.name;
            break;
          case "AtKeyword":
            result = "@" + node.name;
            break;
          case "Function":
            result = node.name + "(";
            break;
          case "String":
          case "Token":
            result = node.value;
            break;
          case "Comma":
            result = ",";
            break;
          default:
            throw new Error("Unknown node type `" + node.type + "`");
        }
        return decorate(result, node);
      }
      module.exports = function(node, options) {
        var decorate = noop2;
        var forceBraces = false;
        var compact = false;
        if (typeof options === "function") {
          decorate = options;
        } else if (options) {
          forceBraces = Boolean(options.forceBraces);
          compact = Boolean(options.compact);
          if (typeof options.decorate === "function") {
            decorate = options.decorate;
          }
        }
        return generate(node, decorate, forceBraces, compact);
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/lexer/error.js
  var require_error = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/lexer/error.js"(exports, module) {
      var createCustomError = require_createCustomError();
      var generate = require_generate();
      var defaultLoc = { offset: 0, line: 1, column: 1 };
      function locateMismatch(matchResult, node) {
        const tokens = matchResult.tokens;
        const longestMatch = matchResult.longestMatch;
        const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
        const badNode = mismatchNode !== node ? mismatchNode : null;
        let mismatchOffset = 0;
        let mismatchLength = 0;
        let entries = 0;
        let css = "";
        let start;
        let end;
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i].value;
          if (i === longestMatch) {
            mismatchLength = token.length;
            mismatchOffset = css.length;
          }
          if (badNode !== null && tokens[i].node === badNode) {
            if (i <= longestMatch) {
              entries++;
            } else {
              entries = 0;
            }
          }
          css += token;
        }
        if (longestMatch === tokens.length || entries > 1) {
          start = fromLoc(badNode || node, "end") || buildLoc(defaultLoc, css);
          end = buildLoc(start);
        } else {
          start = fromLoc(badNode, "start") || buildLoc(fromLoc(node, "start") || defaultLoc, css.slice(0, mismatchOffset));
          end = fromLoc(badNode, "end") || buildLoc(start, css.substr(mismatchOffset, mismatchLength));
        }
        return {
          css,
          mismatchOffset,
          mismatchLength,
          start,
          end
        };
      }
      function fromLoc(node, point) {
        const value = node && node.loc && node.loc[point];
        if (value) {
          return "line" in value ? buildLoc(value) : value;
        }
        return null;
      }
      function buildLoc({ offset, line, column }, extra) {
        const loc = {
          offset,
          line,
          column
        };
        if (extra) {
          const lines = extra.split(/\n|\r\n?|\f/);
          loc.offset += extra.length;
          loc.line += lines.length - 1;
          loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
        }
        return loc;
      }
      var SyntaxReferenceError = function(type, referenceName) {
        const error = createCustomError(
          "SyntaxReferenceError",
          type + (referenceName ? " `" + referenceName + "`" : "")
        );
        error.reference = referenceName;
        return error;
      };
      var SyntaxMatchError = function(message, syntax, node, matchResult) {
        const error = createCustomError("SyntaxMatchError", message);
        const {
          css,
          mismatchOffset,
          mismatchLength,
          start,
          end
        } = locateMismatch(matchResult, node);
        error.rawMessage = message;
        error.syntax = syntax ? generate(syntax) : "<generic>";
        error.css = css;
        error.mismatchOffset = mismatchOffset;
        error.mismatchLength = mismatchLength;
        error.message = message + "\n  syntax: " + error.syntax + "\n   value: " + (css || "<empty string>") + "\n  --------" + new Array(error.mismatchOffset + 1).join("-") + "^";
        Object.assign(error, start);
        error.loc = {
          source: node && node.loc && node.loc.source || "<unknown>",
          start,
          end
        };
        return error;
      };
      module.exports = {
        SyntaxReferenceError,
        SyntaxMatchError
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/utils/names.js
  var require_names = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/utils/names.js"(exports, module) {
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var keywords = /* @__PURE__ */ Object.create(null);
      var properties = /* @__PURE__ */ Object.create(null);
      var HYPHENMINUS = 45;
      function isCustomProperty(str, offset) {
        offset = offset || 0;
        return str.length - offset >= 2 && str.charCodeAt(offset) === HYPHENMINUS && str.charCodeAt(offset + 1) === HYPHENMINUS;
      }
      function getVendorPrefix(str, offset) {
        offset = offset || 0;
        if (str.length - offset >= 3) {
          if (str.charCodeAt(offset) === HYPHENMINUS && str.charCodeAt(offset + 1) !== HYPHENMINUS) {
            var secondDashIndex = str.indexOf("-", offset + 2);
            if (secondDashIndex !== -1) {
              return str.substring(offset, secondDashIndex + 1);
            }
          }
        }
        return "";
      }
      function getKeywordDescriptor(keyword) {
        if (hasOwnProperty2.call(keywords, keyword)) {
          return keywords[keyword];
        }
        var name = keyword.toLowerCase();
        if (hasOwnProperty2.call(keywords, name)) {
          return keywords[keyword] = keywords[name];
        }
        var custom = isCustomProperty(name, 0);
        var vendor = !custom ? getVendorPrefix(name, 0) : "";
        return keywords[keyword] = Object.freeze({
          basename: name.substr(vendor.length),
          name,
          vendor,
          prefix: vendor,
          custom
        });
      }
      function getPropertyDescriptor(property) {
        if (hasOwnProperty2.call(properties, property)) {
          return properties[property];
        }
        var name = property;
        var hack = property[0];
        if (hack === "/") {
          hack = property[1] === "/" ? "//" : "/";
        } else if (hack !== "_" && hack !== "*" && hack !== "$" && hack !== "#" && hack !== "+" && hack !== "&") {
          hack = "";
        }
        var custom = isCustomProperty(name, hack.length);
        if (!custom) {
          name = name.toLowerCase();
          if (hasOwnProperty2.call(properties, name)) {
            return properties[property] = properties[name];
          }
        }
        var vendor = !custom ? getVendorPrefix(name, hack.length) : "";
        var prefix = name.substr(0, hack.length + vendor.length);
        return properties[property] = Object.freeze({
          basename: name.substr(prefix.length),
          name: name.substr(hack.length),
          hack,
          vendor,
          prefix,
          custom
        });
      }
      module.exports = {
        keyword: getKeywordDescriptor,
        property: getPropertyDescriptor,
        isCustomProperty,
        vendorPrefix: getVendorPrefix
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/common/adopt-buffer.js
  var require_adopt_buffer = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/common/adopt-buffer.js"(exports, module) {
      var MIN_SIZE = 16 * 1024;
      var SafeUint32Array = typeof Uint32Array !== "undefined" ? Uint32Array : Array;
      module.exports = function adoptBuffer(buffer2, size) {
        if (buffer2 === null || buffer2.length < size) {
          return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
        }
        return buffer2;
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/tokenizer/index.js
  var require_tokenizer = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/tokenizer/index.js"(exports, module) {
      var TokenStream = require_TokenStream();
      var adoptBuffer = require_adopt_buffer();
      var constants = require_const();
      var TYPE = constants.TYPE;
      var charCodeDefinitions = require_char_code_definitions();
      var isNewline = charCodeDefinitions.isNewline;
      var isName = charCodeDefinitions.isName;
      var isValidEscape = charCodeDefinitions.isValidEscape;
      var isNumberStart = charCodeDefinitions.isNumberStart;
      var isIdentifierStart = charCodeDefinitions.isIdentifierStart;
      var charCodeCategory = charCodeDefinitions.charCodeCategory;
      var isBOM = charCodeDefinitions.isBOM;
      var utils = require_utils();
      var cmpStr = utils.cmpStr;
      var getNewlineLength = utils.getNewlineLength;
      var findWhiteSpaceEnd = utils.findWhiteSpaceEnd;
      var consumeEscaped = utils.consumeEscaped;
      var consumeName = utils.consumeName;
      var consumeNumber = utils.consumeNumber;
      var consumeBadUrlRemnants = utils.consumeBadUrlRemnants;
      var OFFSET_MASK = 16777215;
      var TYPE_SHIFT = 24;
      function tokenize(source, stream) {
        function getCharCode(offset2) {
          return offset2 < sourceLength ? source.charCodeAt(offset2) : 0;
        }
        function consumeNumericToken() {
          offset = consumeNumber(source, offset);
          if (isIdentifierStart(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
            type = TYPE.Dimension;
            offset = consumeName(source, offset);
            return;
          }
          if (getCharCode(offset) === 37) {
            type = TYPE.Percentage;
            offset++;
            return;
          }
          type = TYPE.Number;
        }
        function consumeIdentLikeToken() {
          const nameStartOffset = offset;
          offset = consumeName(source, offset);
          if (cmpStr(source, nameStartOffset, offset, "url") && getCharCode(offset) === 40) {
            offset = findWhiteSpaceEnd(source, offset + 1);
            if (getCharCode(offset) === 34 || getCharCode(offset) === 39) {
              type = TYPE.Function;
              offset = nameStartOffset + 4;
              return;
            }
            consumeUrlToken();
            return;
          }
          if (getCharCode(offset) === 40) {
            type = TYPE.Function;
            offset++;
            return;
          }
          type = TYPE.Ident;
        }
        function consumeStringToken(endingCodePoint) {
          if (!endingCodePoint) {
            endingCodePoint = getCharCode(offset++);
          }
          type = TYPE.String;
          for (; offset < source.length; offset++) {
            var code2 = source.charCodeAt(offset);
            switch (charCodeCategory(code2)) {
              case endingCodePoint:
                offset++;
                return;
              case charCodeCategory.Eof:
                return;
              case charCodeCategory.WhiteSpace:
                if (isNewline(code2)) {
                  offset += getNewlineLength(source, offset, code2);
                  type = TYPE.BadString;
                  return;
                }
                break;
              case 92:
                if (offset === source.length - 1) {
                  break;
                }
                var nextCode = getCharCode(offset + 1);
                if (isNewline(nextCode)) {
                  offset += getNewlineLength(source, offset + 1, nextCode);
                } else if (isValidEscape(code2, nextCode)) {
                  offset = consumeEscaped(source, offset) - 1;
                }
                break;
            }
          }
        }
        function consumeUrlToken() {
          type = TYPE.Url;
          offset = findWhiteSpaceEnd(source, offset);
          for (; offset < source.length; offset++) {
            var code2 = source.charCodeAt(offset);
            switch (charCodeCategory(code2)) {
              case 41:
                offset++;
                return;
              case charCodeCategory.Eof:
                return;
              case charCodeCategory.WhiteSpace:
                offset = findWhiteSpaceEnd(source, offset);
                if (getCharCode(offset) === 41 || offset >= source.length) {
                  if (offset < source.length) {
                    offset++;
                  }
                  return;
                }
                offset = consumeBadUrlRemnants(source, offset);
                type = TYPE.BadUrl;
                return;
              case 34:
              case 39:
              case 40:
              case charCodeCategory.NonPrintable:
                offset = consumeBadUrlRemnants(source, offset);
                type = TYPE.BadUrl;
                return;
              case 92:
                if (isValidEscape(code2, getCharCode(offset + 1))) {
                  offset = consumeEscaped(source, offset) - 1;
                  break;
                }
                offset = consumeBadUrlRemnants(source, offset);
                type = TYPE.BadUrl;
                return;
            }
          }
        }
        if (!stream) {
          stream = new TokenStream();
        }
        source = String(source || "");
        var sourceLength = source.length;
        var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1);
        var balance = adoptBuffer(stream.balance, sourceLength + 1);
        var tokenCount = 0;
        var start = isBOM(getCharCode(0));
        var offset = start;
        var balanceCloseType = 0;
        var balanceStart = 0;
        var balancePrev = 0;
        while (offset < sourceLength) {
          var code = source.charCodeAt(offset);
          var type = 0;
          balance[tokenCount] = sourceLength;
          switch (charCodeCategory(code)) {
            case charCodeCategory.WhiteSpace:
              type = TYPE.WhiteSpace;
              offset = findWhiteSpaceEnd(source, offset + 1);
              break;
            case 34:
              consumeStringToken();
              break;
            case 35:
              if (isName(getCharCode(offset + 1)) || isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {
                type = TYPE.Hash;
                offset = consumeName(source, offset + 1);
              } else {
                type = TYPE.Delim;
                offset++;
              }
              break;
            case 39:
              consumeStringToken();
              break;
            case 40:
              type = TYPE.LeftParenthesis;
              offset++;
              break;
            case 41:
              type = TYPE.RightParenthesis;
              offset++;
              break;
            case 43:
              if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                consumeNumericToken();
              } else {
                type = TYPE.Delim;
                offset++;
              }
              break;
            case 44:
              type = TYPE.Comma;
              offset++;
              break;
            case 45:
              if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                consumeNumericToken();
              } else {
                if (getCharCode(offset + 1) === 45 && getCharCode(offset + 2) === 62) {
                  type = TYPE.CDC;
                  offset = offset + 3;
                } else {
                  if (isIdentifierStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    consumeIdentLikeToken();
                  } else {
                    type = TYPE.Delim;
                    offset++;
                  }
                }
              }
              break;
            case 46:
              if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                consumeNumericToken();
              } else {
                type = TYPE.Delim;
                offset++;
              }
              break;
            case 47:
              if (getCharCode(offset + 1) === 42) {
                type = TYPE.Comment;
                offset = source.indexOf("*/", offset + 2) + 2;
                if (offset === 1) {
                  offset = source.length;
                }
              } else {
                type = TYPE.Delim;
                offset++;
              }
              break;
            case 58:
              type = TYPE.Colon;
              offset++;
              break;
            case 59:
              type = TYPE.Semicolon;
              offset++;
              break;
            case 60:
              if (getCharCode(offset + 1) === 33 && getCharCode(offset + 2) === 45 && getCharCode(offset + 3) === 45) {
                type = TYPE.CDO;
                offset = offset + 4;
              } else {
                type = TYPE.Delim;
                offset++;
              }
              break;
            case 64:
              if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
                type = TYPE.AtKeyword;
                offset = consumeName(source, offset + 1);
              } else {
                type = TYPE.Delim;
                offset++;
              }
              break;
            case 91:
              type = TYPE.LeftSquareBracket;
              offset++;
              break;
            case 92:
              if (isValidEscape(code, getCharCode(offset + 1))) {
                consumeIdentLikeToken();
              } else {
                type = TYPE.Delim;
                offset++;
              }
              break;
            case 93:
              type = TYPE.RightSquareBracket;
              offset++;
              break;
            case 123:
              type = TYPE.LeftCurlyBracket;
              offset++;
              break;
            case 125:
              type = TYPE.RightCurlyBracket;
              offset++;
              break;
            case charCodeCategory.Digit:
              consumeNumericToken();
              break;
            case charCodeCategory.NameStart:
              consumeIdentLikeToken();
              break;
            case charCodeCategory.Eof:
              break;
            default:
              type = TYPE.Delim;
              offset++;
          }
          switch (type) {
            case balanceCloseType:
              balancePrev = balanceStart & OFFSET_MASK;
              balanceStart = balance[balancePrev];
              balanceCloseType = balanceStart >> TYPE_SHIFT;
              balance[tokenCount] = balancePrev;
              balance[balancePrev++] = tokenCount;
              for (; balancePrev < tokenCount; balancePrev++) {
                if (balance[balancePrev] === sourceLength) {
                  balance[balancePrev] = tokenCount;
                }
              }
              break;
            case TYPE.LeftParenthesis:
            case TYPE.Function:
              balance[tokenCount] = balanceStart;
              balanceCloseType = TYPE.RightParenthesis;
              balanceStart = balanceCloseType << TYPE_SHIFT | tokenCount;
              break;
            case TYPE.LeftSquareBracket:
              balance[tokenCount] = balanceStart;
              balanceCloseType = TYPE.RightSquareBracket;
              balanceStart = balanceCloseType << TYPE_SHIFT | tokenCount;
              break;
            case TYPE.LeftCurlyBracket:
              balance[tokenCount] = balanceStart;
              balanceCloseType = TYPE.RightCurlyBracket;
              balanceStart = balanceCloseType << TYPE_SHIFT | tokenCount;
              break;
          }
          offsetAndType[tokenCount++] = type << TYPE_SHIFT | offset;
        }
        offsetAndType[tokenCount] = TYPE.EOF << TYPE_SHIFT | offset;
        balance[tokenCount] = sourceLength;
        balance[sourceLength] = sourceLength;
        while (balanceStart !== 0) {
          balancePrev = balanceStart & OFFSET_MASK;
          balanceStart = balance[balancePrev];
          balance[balancePrev] = sourceLength;
        }
        stream.source = source;
        stream.firstCharOffset = start;
        stream.offsetAndType = offsetAndType;
        stream.tokenCount = tokenCount;
        stream.balance = balance;
        stream.reset();
        stream.next();
        return stream;
      }
      Object.keys(constants).forEach(function(key) {
        tokenize[key] = constants[key];
      });
      Object.keys(charCodeDefinitions).forEach(function(key) {
        tokenize[key] = charCodeDefinitions[key];
      });
      Object.keys(utils).forEach(function(key) {
        tokenize[key] = utils[key];
      });
      module.exports = tokenize;
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/lexer/generic-an-plus-b.js
  var require_generic_an_plus_b = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/lexer/generic-an-plus-b.js"(exports, module) {
      var isDigit = require_tokenizer().isDigit;
      var cmpChar = require_tokenizer().cmpChar;
      var TYPE = require_tokenizer().TYPE;
      var DELIM = TYPE.Delim;
      var WHITESPACE = TYPE.WhiteSpace;
      var COMMENT = TYPE.Comment;
      var IDENT = TYPE.Ident;
      var NUMBER = TYPE.Number;
      var DIMENSION = TYPE.Dimension;
      var PLUSSIGN = 43;
      var HYPHENMINUS = 45;
      var N = 110;
      var DISALLOW_SIGN = true;
      var ALLOW_SIGN = false;
      function isDelim(token, code) {
        return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
      }
      function skipSC(token, offset, getNextToken) {
        while (token !== null && (token.type === WHITESPACE || token.type === COMMENT)) {
          token = getNextToken(++offset);
        }
        return offset;
      }
      function checkInteger(token, valueOffset, disallowSign, offset) {
        if (!token) {
          return 0;
        }
        var code = token.value.charCodeAt(valueOffset);
        if (code === PLUSSIGN || code === HYPHENMINUS) {
          if (disallowSign) {
            return 0;
          }
          valueOffset++;
        }
        for (; valueOffset < token.value.length; valueOffset++) {
          if (!isDigit(token.value.charCodeAt(valueOffset))) {
            return 0;
          }
        }
        return offset + 1;
      }
      function consumeB(token, offset_, getNextToken) {
        var sign = false;
        var offset = skipSC(token, offset_, getNextToken);
        token = getNextToken(offset);
        if (token === null) {
          return offset_;
        }
        if (token.type !== NUMBER) {
          if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS)) {
            sign = true;
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);
            if (token === null && token.type !== NUMBER) {
              return 0;
            }
          } else {
            return offset_;
          }
        }
        if (!sign) {
          var code = token.value.charCodeAt(0);
          if (code !== PLUSSIGN && code !== HYPHENMINUS) {
            return 0;
          }
        }
        return checkInteger(token, sign ? 0 : 1, sign, offset);
      }
      module.exports = function anPlusB(token, getNextToken) {
        var offset = 0;
        if (!token) {
          return 0;
        }
        if (token.type === NUMBER) {
          return checkInteger(token, 0, ALLOW_SIGN, offset);
        } else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS) {
          if (!cmpChar(token.value, 1, N)) {
            return 0;
          }
          switch (token.value.length) {
            case 2:
              return consumeB(getNextToken(++offset), offset, getNextToken);
            case 3:
              if (token.value.charCodeAt(2) !== HYPHENMINUS) {
                return 0;
              }
              offset = skipSC(getNextToken(++offset), offset, getNextToken);
              token = getNextToken(offset);
              return checkInteger(token, 0, DISALLOW_SIGN, offset);
            default:
              if (token.value.charCodeAt(2) !== HYPHENMINUS) {
                return 0;
              }
              return checkInteger(token, 3, DISALLOW_SIGN, offset);
          }
        } else if (token.type === IDENT || isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT) {
          if (token.type !== IDENT) {
            token = getNextToken(++offset);
          }
          if (token === null || !cmpChar(token.value, 0, N)) {
            return 0;
          }
          switch (token.value.length) {
            case 1:
              return consumeB(getNextToken(++offset), offset, getNextToken);
            case 2:
              if (token.value.charCodeAt(1) !== HYPHENMINUS) {
                return 0;
              }
              offset = skipSC(getNextToken(++offset), offset, getNextToken);
              token = getNextToken(offset);
              return checkInteger(token, 0, DISALLOW_SIGN, offset);
            default:
              if (token.value.charCodeAt(1) !== HYPHENMINUS) {
                return 0;
              }
              return checkInteger(token, 2, DISALLOW_SIGN, offset);
          }
        } else if (token.type === DIMENSION) {
          var code = token.value.charCodeAt(0);
          var sign = code === PLUSSIGN || code === HYPHENMINUS ? 1 : 0;
          for (var i = sign; i < token.value.length; i++) {
            if (!isDigit(token.value.charCodeAt(i))) {
              break;
            }
          }
          if (i === sign) {
            return 0;
          }
          if (!cmpChar(token.value, i, N)) {
            return 0;
          }
          if (i + 1 === token.value.length) {
            return consumeB(getNextToken(++offset), offset, getNextToken);
          } else {
            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS) {
              return 0;
            }
            if (i + 2 === token.value.length) {
              offset = skipSC(getNextToken(++offset), offset, getNextToken);
              token = getNextToken(offset);
              return checkInteger(token, 0, DISALLOW_SIGN, offset);
            } else {
              return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
            }
          }
        }
        return 0;
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/lexer/generic-urange.js
  var require_generic_urange = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/lexer/generic-urange.js"(exports, module) {
      var isHexDigit = require_tokenizer().isHexDigit;
      var cmpChar = require_tokenizer().cmpChar;
      var TYPE = require_tokenizer().TYPE;
      var IDENT = TYPE.Ident;
      var DELIM = TYPE.Delim;
      var NUMBER = TYPE.Number;
      var DIMENSION = TYPE.Dimension;
      var PLUSSIGN = 43;
      var HYPHENMINUS = 45;
      var QUESTIONMARK = 63;
      var U = 117;
      function isDelim(token, code) {
        return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
      }
      function startsWith(token, code) {
        return token.value.charCodeAt(0) === code;
      }
      function hexSequence(token, offset, allowDash) {
        for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
          var code = token.value.charCodeAt(pos);
          if (code === HYPHENMINUS && allowDash && hexlen !== 0) {
            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
              return 6;
            }
            return 0;
          }
          if (!isHexDigit(code)) {
            return 0;
          }
          if (++hexlen > 6) {
            return 0;
          }
          ;
        }
        return hexlen;
      }
      function withQuestionMarkSequence(consumed, length, getNextToken) {
        if (!consumed) {
          return 0;
        }
        while (isDelim(getNextToken(length), QUESTIONMARK)) {
          if (++consumed > 6) {
            return 0;
          }
          length++;
        }
        return length;
      }
      module.exports = function urange(token, getNextToken) {
        var length = 0;
        if (token === null || token.type !== IDENT || !cmpChar(token.value, 0, U)) {
          return 0;
        }
        token = getNextToken(++length);
        if (token === null) {
          return 0;
        }
        if (isDelim(token, PLUSSIGN)) {
          token = getNextToken(++length);
          if (token === null) {
            return 0;
          }
          if (token.type === IDENT) {
            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
          }
          if (isDelim(token, QUESTIONMARK)) {
            return withQuestionMarkSequence(1, ++length, getNextToken);
          }
          return 0;
        }
        if (token.type === NUMBER) {
          if (!startsWith(token, PLUSSIGN)) {
            return 0;
          }
          var consumedHexLength = hexSequence(token, 1, true);
          if (consumedHexLength === 0) {
            return 0;
          }
          token = getNextToken(++length);
          if (token === null) {
            return length;
          }
          if (token.type === DIMENSION || token.type === NUMBER) {
            if (!startsWith(token, HYPHENMINUS) || !hexSequence(token, 1, false)) {
              return 0;
            }
            return length + 1;
          }
          return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
        }
        if (token.type === DIMENSION) {
          if (!startsWith(token, PLUSSIGN)) {
            return 0;
          }
          return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
        }
        return 0;
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/lexer/generic.js
  var require_generic = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/lexer/generic.js"(exports, module) {
      var tokenizer = require_tokenizer();
      var isIdentifierStart = tokenizer.isIdentifierStart;
      var isHexDigit = tokenizer.isHexDigit;
      var isDigit = tokenizer.isDigit;
      var cmpStr = tokenizer.cmpStr;
      var consumeNumber = tokenizer.consumeNumber;
      var TYPE = tokenizer.TYPE;
      var anPlusB = require_generic_an_plus_b();
      var urange = require_generic_urange();
      var cssWideKeywords = ["unset", "initial", "inherit"];
      var calcFunctionNames = ["calc(", "-moz-calc(", "-webkit-calc("];
      var LENGTH = {
        // absolute length units
        "px": true,
        "mm": true,
        "cm": true,
        "in": true,
        "pt": true,
        "pc": true,
        "q": true,
        // relative length units
        "em": true,
        "ex": true,
        "ch": true,
        "rem": true,
        // viewport-percentage lengths
        "vh": true,
        "vw": true,
        "vmin": true,
        "vmax": true,
        "vm": true
      };
      var ANGLE = {
        "deg": true,
        "grad": true,
        "rad": true,
        "turn": true
      };
      var TIME = {
        "s": true,
        "ms": true
      };
      var FREQUENCY = {
        "hz": true,
        "khz": true
      };
      var RESOLUTION = {
        "dpi": true,
        "dpcm": true,
        "dppx": true,
        "x": true
        // https://github.com/w3c/csswg-drafts/issues/461
      };
      var FLEX = {
        "fr": true
      };
      var DECIBEL = {
        "db": true
      };
      var SEMITONES = {
        "st": true
      };
      function charCode(str, index) {
        return index < str.length ? str.charCodeAt(index) : 0;
      }
      function eqStr(actual, expected) {
        return cmpStr(actual, 0, actual.length, expected);
      }
      function eqStrAny(actual, expected) {
        for (var i = 0; i < expected.length; i++) {
          if (eqStr(actual, expected[i])) {
            return true;
          }
        }
        return false;
      }
      function isPostfixIeHack(str, offset) {
        if (offset !== str.length - 2) {
          return false;
        }
        return str.charCodeAt(offset) === 92 && // U+005C REVERSE SOLIDUS (\)
        isDigit(str.charCodeAt(offset + 1));
      }
      function outOfRange(opts, value, numEnd) {
        if (opts && opts.type === "Range") {
          var num = Number(
            numEnd !== void 0 && numEnd !== value.length ? value.substr(0, numEnd) : value
          );
          if (isNaN(num)) {
            return true;
          }
          if (opts.min !== null && num < opts.min) {
            return true;
          }
          if (opts.max !== null && num > opts.max) {
            return true;
          }
        }
        return false;
      }
      function consumeFunction(token, getNextToken) {
        var startIdx = token.index;
        var length = 0;
        do {
          length++;
          if (token.balance <= startIdx) {
            break;
          }
        } while (token = getNextToken(length));
        return length;
      }
      function calc(next) {
        return function(token, getNextToken, opts) {
          if (token === null) {
            return 0;
          }
          if (token.type === TYPE.Function && eqStrAny(token.value, calcFunctionNames)) {
            return consumeFunction(token, getNextToken);
          }
          return next(token, getNextToken, opts);
        };
      }
      function tokenType(expectedTokenType) {
        return function(token) {
          if (token === null || token.type !== expectedTokenType) {
            return 0;
          }
          return 1;
        };
      }
      function func(name) {
        name = name + "(";
        return function(token, getNextToken) {
          if (token !== null && eqStr(token.value, name)) {
            return consumeFunction(token, getNextToken);
          }
          return 0;
        };
      }
      function customIdent(token) {
        if (token === null || token.type !== TYPE.Ident) {
          return 0;
        }
        var name = token.value.toLowerCase();
        if (eqStrAny(name, cssWideKeywords)) {
          return 0;
        }
        if (eqStr(name, "default")) {
          return 0;
        }
        return 1;
      }
      function customPropertyName(token) {
        if (token === null || token.type !== TYPE.Ident) {
          return 0;
        }
        if (charCode(token.value, 0) !== 45 || charCode(token.value, 1) !== 45) {
          return 0;
        }
        return 1;
      }
      function hexColor(token) {
        if (token === null || token.type !== TYPE.Hash) {
          return 0;
        }
        var length = token.value.length;
        if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
          return 0;
        }
        for (var i = 1; i < length; i++) {
          if (!isHexDigit(token.value.charCodeAt(i))) {
            return 0;
          }
        }
        return 1;
      }
      function idSelector(token) {
        if (token === null || token.type !== TYPE.Hash) {
          return 0;
        }
        if (!isIdentifierStart(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
          return 0;
        }
        return 1;
      }
      function declarationValue(token, getNextToken) {
        if (!token) {
          return 0;
        }
        var length = 0;
        var level = 0;
        var startIdx = token.index;
        scan:
          do {
            switch (token.type) {
              case TYPE.BadString:
              case TYPE.BadUrl:
                break scan;
              case TYPE.RightCurlyBracket:
              case TYPE.RightParenthesis:
              case TYPE.RightSquareBracket:
                if (token.balance > token.index || token.balance < startIdx) {
                  break scan;
                }
                level--;
                break;
              case TYPE.Semicolon:
                if (level === 0) {
                  break scan;
                }
                break;
              case TYPE.Delim:
                if (token.value === "!" && level === 0) {
                  break scan;
                }
                break;
              case TYPE.Function:
              case TYPE.LeftParenthesis:
              case TYPE.LeftSquareBracket:
              case TYPE.LeftCurlyBracket:
                level++;
                break;
            }
            length++;
            if (token.balance <= startIdx) {
              break;
            }
          } while (token = getNextToken(length));
        return length;
      }
      function anyValue(token, getNextToken) {
        if (!token) {
          return 0;
        }
        var startIdx = token.index;
        var length = 0;
        scan:
          do {
            switch (token.type) {
              case TYPE.BadString:
              case TYPE.BadUrl:
                break scan;
              case TYPE.RightCurlyBracket:
              case TYPE.RightParenthesis:
              case TYPE.RightSquareBracket:
                if (token.balance > token.index || token.balance < startIdx) {
                  break scan;
                }
                break;
            }
            length++;
            if (token.balance <= startIdx) {
              break;
            }
          } while (token = getNextToken(length));
        return length;
      }
      function dimension(type) {
        return function(token, getNextToken, opts) {
          if (token === null || token.type !== TYPE.Dimension) {
            return 0;
          }
          var numberEnd = consumeNumber(token.value, 0);
          if (type !== null) {
            var reverseSolidusOffset = token.value.indexOf("\\", numberEnd);
            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset) ? token.value.substr(numberEnd) : token.value.substring(numberEnd, reverseSolidusOffset);
            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
              return 0;
            }
          }
          if (outOfRange(opts, token.value, numberEnd)) {
            return 0;
          }
          return 1;
        };
      }
      function percentage(token, getNextToken, opts) {
        if (token === null || token.type !== TYPE.Percentage) {
          return 0;
        }
        if (outOfRange(opts, token.value, token.value.length - 1)) {
          return 0;
        }
        return 1;
      }
      function zero(next) {
        if (typeof next !== "function") {
          next = function() {
            return 0;
          };
        }
        return function(token, getNextToken, opts) {
          if (token !== null && token.type === TYPE.Number) {
            if (Number(token.value) === 0) {
              return 1;
            }
          }
          return next(token, getNextToken, opts);
        };
      }
      function number(token, getNextToken, opts) {
        if (token === null) {
          return 0;
        }
        var numberEnd = consumeNumber(token.value, 0);
        var isNumber = numberEnd === token.value.length;
        if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
          return 0;
        }
        if (outOfRange(opts, token.value, numberEnd)) {
          return 0;
        }
        return 1;
      }
      function integer(token, getNextToken, opts) {
        if (token === null || token.type !== TYPE.Number) {
          return 0;
        }
        var i = token.value.charCodeAt(0) === 43 || // U+002B PLUS SIGN (+)
        token.value.charCodeAt(0) === 45 ? 1 : 0;
        for (; i < token.value.length; i++) {
          if (!isDigit(token.value.charCodeAt(i))) {
            return 0;
          }
        }
        if (outOfRange(opts, token.value, i)) {
          return 0;
        }
        return 1;
      }
      module.exports = {
        // token types
        "ident-token": tokenType(TYPE.Ident),
        "function-token": tokenType(TYPE.Function),
        "at-keyword-token": tokenType(TYPE.AtKeyword),
        "hash-token": tokenType(TYPE.Hash),
        "string-token": tokenType(TYPE.String),
        "bad-string-token": tokenType(TYPE.BadString),
        "url-token": tokenType(TYPE.Url),
        "bad-url-token": tokenType(TYPE.BadUrl),
        "delim-token": tokenType(TYPE.Delim),
        "number-token": tokenType(TYPE.Number),
        "percentage-token": tokenType(TYPE.Percentage),
        "dimension-token": tokenType(TYPE.Dimension),
        "whitespace-token": tokenType(TYPE.WhiteSpace),
        "CDO-token": tokenType(TYPE.CDO),
        "CDC-token": tokenType(TYPE.CDC),
        "colon-token": tokenType(TYPE.Colon),
        "semicolon-token": tokenType(TYPE.Semicolon),
        "comma-token": tokenType(TYPE.Comma),
        "[-token": tokenType(TYPE.LeftSquareBracket),
        "]-token": tokenType(TYPE.RightSquareBracket),
        "(-token": tokenType(TYPE.LeftParenthesis),
        ")-token": tokenType(TYPE.RightParenthesis),
        "{-token": tokenType(TYPE.LeftCurlyBracket),
        "}-token": tokenType(TYPE.RightCurlyBracket),
        // token type aliases
        "string": tokenType(TYPE.String),
        "ident": tokenType(TYPE.Ident),
        // complex types
        "custom-ident": customIdent,
        "custom-property-name": customPropertyName,
        "hex-color": hexColor,
        "id-selector": idSelector,
        // element( <id-selector> )
        "an-plus-b": anPlusB,
        "urange": urange,
        "declaration-value": declarationValue,
        "any-value": anyValue,
        // dimensions
        "dimension": calc(dimension(null)),
        "angle": calc(dimension(ANGLE)),
        "decibel": calc(dimension(DECIBEL)),
        "frequency": calc(dimension(FREQUENCY)),
        "flex": calc(dimension(FLEX)),
        "length": calc(zero(dimension(LENGTH))),
        "resolution": calc(dimension(RESOLUTION)),
        "semitones": calc(dimension(SEMITONES)),
        "time": calc(dimension(TIME)),
        // percentage
        "percentage": calc(percentage),
        // numeric
        "zero": zero(),
        "number": calc(number),
        "integer": calc(integer),
        // old IE stuff
        "-ms-legacy-expression": func("expression")
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/definition-syntax/SyntaxError.js
  var require_SyntaxError2 = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/definition-syntax/SyntaxError.js"(exports, module) {
      var createCustomError = require_createCustomError();
      module.exports = function SyntaxError2(message, input, offset) {
        var error = createCustomError("SyntaxError", message);
        error.input = input;
        error.offset = offset;
        error.rawMessage = message;
        error.message = error.rawMessage + "\n  " + error.input + "\n--" + new Array((error.offset || error.input.length) + 1).join("-") + "^";
        return error;
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/definition-syntax/tokenizer.js
  var require_tokenizer2 = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/definition-syntax/tokenizer.js"(exports, module) {
      var SyntaxError2 = require_SyntaxError2();
      var TAB = 9;
      var N = 10;
      var F = 12;
      var R2 = 13;
      var SPACE = 32;
      var Tokenizer = function(str) {
        this.str = str;
        this.pos = 0;
      };
      Tokenizer.prototype = {
        charCodeAt: function(pos) {
          return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
        },
        charCode: function() {
          return this.charCodeAt(this.pos);
        },
        nextCharCode: function() {
          return this.charCodeAt(this.pos + 1);
        },
        nextNonWsCode: function(pos) {
          return this.charCodeAt(this.findWsEnd(pos));
        },
        findWsEnd: function(pos) {
          for (; pos < this.str.length; pos++) {
            var code = this.str.charCodeAt(pos);
            if (code !== R2 && code !== N && code !== F && code !== SPACE && code !== TAB) {
              break;
            }
          }
          return pos;
        },
        substringToPos: function(end) {
          return this.str.substring(this.pos, this.pos = end);
        },
        eat: function(code) {
          if (this.charCode() !== code) {
            this.error("Expect `" + String.fromCharCode(code) + "`");
          }
          this.pos++;
        },
        peek: function() {
          return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
        },
        error: function(message) {
          throw new SyntaxError2(message, this.str, this.pos);
        }
      };
      module.exports = Tokenizer;
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/definition-syntax/parse.js
  var require_parse = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/definition-syntax/parse.js"(exports, module) {
      var Tokenizer = require_tokenizer2();
      var TAB = 9;
      var N = 10;
      var F = 12;
      var R2 = 13;
      var SPACE = 32;
      var EXCLAMATIONMARK = 33;
      var NUMBERSIGN = 35;
      var AMPERSAND = 38;
      var APOSTROPHE = 39;
      var LEFTPARENTHESIS = 40;
      var RIGHTPARENTHESIS = 41;
      var ASTERISK = 42;
      var PLUSSIGN = 43;
      var COMMA = 44;
      var HYPERMINUS = 45;
      var LESSTHANSIGN = 60;
      var GREATERTHANSIGN = 62;
      var QUESTIONMARK = 63;
      var COMMERCIALAT = 64;
      var LEFTSQUAREBRACKET = 91;
      var RIGHTSQUAREBRACKET = 93;
      var LEFTCURLYBRACKET = 123;
      var VERTICALLINE = 124;
      var RIGHTCURLYBRACKET = 125;
      var INFINITY = 8734;
      var NAME_CHAR = createCharMap(function(ch) {
        return /[a-zA-Z0-9\-]/.test(ch);
      });
      var COMBINATOR_PRECEDENCE = {
        " ": 1,
        "&&": 2,
        "||": 3,
        "|": 4
      };
      function createCharMap(fn) {
        var array = typeof Uint32Array === "function" ? new Uint32Array(128) : new Array(128);
        for (var i = 0; i < 128; i++) {
          array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
        }
        return array;
      }
      function scanSpaces(tokenizer) {
        return tokenizer.substringToPos(
          tokenizer.findWsEnd(tokenizer.pos)
        );
      }
      function scanWord(tokenizer) {
        var end = tokenizer.pos;
        for (; end < tokenizer.str.length; end++) {
          var code = tokenizer.str.charCodeAt(end);
          if (code >= 128 || NAME_CHAR[code] === 0) {
            break;
          }
        }
        if (tokenizer.pos === end) {
          tokenizer.error("Expect a keyword");
        }
        return tokenizer.substringToPos(end);
      }
      function scanNumber(tokenizer) {
        var end = tokenizer.pos;
        for (; end < tokenizer.str.length; end++) {
          var code = tokenizer.str.charCodeAt(end);
          if (code < 48 || code > 57) {
            break;
          }
        }
        if (tokenizer.pos === end) {
          tokenizer.error("Expect a number");
        }
        return tokenizer.substringToPos(end);
      }
      function scanString(tokenizer) {
        var end = tokenizer.str.indexOf("'", tokenizer.pos + 1);
        if (end === -1) {
          tokenizer.pos = tokenizer.str.length;
          tokenizer.error("Expect an apostrophe");
        }
        return tokenizer.substringToPos(end + 1);
      }
      function readMultiplierRange(tokenizer) {
        var min = null;
        var max = null;
        tokenizer.eat(LEFTCURLYBRACKET);
        min = scanNumber(tokenizer);
        if (tokenizer.charCode() === COMMA) {
          tokenizer.pos++;
          if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
            max = scanNumber(tokenizer);
          }
        } else {
          max = min;
        }
        tokenizer.eat(RIGHTCURLYBRACKET);
        return {
          min: Number(min),
          max: max ? Number(max) : 0
        };
      }
      function readMultiplier(tokenizer) {
        var range = null;
        var comma = false;
        switch (tokenizer.charCode()) {
          case ASTERISK:
            tokenizer.pos++;
            range = {
              min: 0,
              max: 0
            };
            break;
          case PLUSSIGN:
            tokenizer.pos++;
            range = {
              min: 1,
              max: 0
            };
            break;
          case QUESTIONMARK:
            tokenizer.pos++;
            range = {
              min: 0,
              max: 1
            };
            break;
          case NUMBERSIGN:
            tokenizer.pos++;
            comma = true;
            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
              range = readMultiplierRange(tokenizer);
            } else {
              range = {
                min: 1,
                max: 0
              };
            }
            break;
          case LEFTCURLYBRACKET:
            range = readMultiplierRange(tokenizer);
            break;
          default:
            return null;
        }
        return {
          type: "Multiplier",
          comma,
          min: range.min,
          max: range.max,
          term: null
        };
      }
      function maybeMultiplied(tokenizer, node) {
        var multiplier = readMultiplier(tokenizer);
        if (multiplier !== null) {
          multiplier.term = node;
          return multiplier;
        }
        return node;
      }
      function maybeToken(tokenizer) {
        var ch = tokenizer.peek();
        if (ch === "") {
          return null;
        }
        return {
          type: "Token",
          value: ch
        };
      }
      function readProperty(tokenizer) {
        var name;
        tokenizer.eat(LESSTHANSIGN);
        tokenizer.eat(APOSTROPHE);
        name = scanWord(tokenizer);
        tokenizer.eat(APOSTROPHE);
        tokenizer.eat(GREATERTHANSIGN);
        return maybeMultiplied(tokenizer, {
          type: "Property",
          name
        });
      }
      function readTypeRange(tokenizer) {
        var min = null;
        var max = null;
        var sign = 1;
        tokenizer.eat(LEFTSQUAREBRACKET);
        if (tokenizer.charCode() === HYPERMINUS) {
          tokenizer.peek();
          sign = -1;
        }
        if (sign == -1 && tokenizer.charCode() === INFINITY) {
          tokenizer.peek();
        } else {
          min = sign * Number(scanNumber(tokenizer));
        }
        scanSpaces(tokenizer);
        tokenizer.eat(COMMA);
        scanSpaces(tokenizer);
        if (tokenizer.charCode() === INFINITY) {
          tokenizer.peek();
        } else {
          sign = 1;
          if (tokenizer.charCode() === HYPERMINUS) {
            tokenizer.peek();
            sign = -1;
          }
          max = sign * Number(scanNumber(tokenizer));
        }
        tokenizer.eat(RIGHTSQUAREBRACKET);
        if (min === null && max === null) {
          return null;
        }
        return {
          type: "Range",
          min,
          max
        };
      }
      function readType(tokenizer) {
        var name;
        var opts = null;
        tokenizer.eat(LESSTHANSIGN);
        name = scanWord(tokenizer);
        if (tokenizer.charCode() === LEFTPARENTHESIS && tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
          tokenizer.pos += 2;
          name += "()";
        }
        if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
          scanSpaces(tokenizer);
          opts = readTypeRange(tokenizer);
        }
        tokenizer.eat(GREATERTHANSIGN);
        return maybeMultiplied(tokenizer, {
          type: "Type",
          name,
          opts
        });
      }
      function readKeywordOrFunction(tokenizer) {
        var name;
        name = scanWord(tokenizer);
        if (tokenizer.charCode() === LEFTPARENTHESIS) {
          tokenizer.pos++;
          return {
            type: "Function",
            name
          };
        }
        return maybeMultiplied(tokenizer, {
          type: "Keyword",
          name
        });
      }
      function regroupTerms(terms, combinators) {
        function createGroup(terms2, combinator2) {
          return {
            type: "Group",
            terms: terms2,
            combinator: combinator2,
            disallowEmpty: false,
            explicit: false
          };
        }
        combinators = Object.keys(combinators).sort(function(a, b) {
          return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
        });
        while (combinators.length > 0) {
          var combinator = combinators.shift();
          for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
            var term = terms[i];
            if (term.type === "Combinator") {
              if (term.value === combinator) {
                if (subgroupStart === -1) {
                  subgroupStart = i - 1;
                }
                terms.splice(i, 1);
                i--;
              } else {
                if (subgroupStart !== -1 && i - subgroupStart > 1) {
                  terms.splice(
                    subgroupStart,
                    i - subgroupStart,
                    createGroup(terms.slice(subgroupStart, i), combinator)
                  );
                  i = subgroupStart + 1;
                }
                subgroupStart = -1;
              }
            }
          }
          if (subgroupStart !== -1 && combinators.length) {
            terms.splice(
              subgroupStart,
              i - subgroupStart,
              createGroup(terms.slice(subgroupStart, i), combinator)
            );
          }
        }
        return combinator;
      }
      function readImplicitGroup(tokenizer) {
        var terms = [];
        var combinators = {};
        var token;
        var prevToken = null;
        var prevTokenPos = tokenizer.pos;
        while (token = peek(tokenizer)) {
          if (token.type !== "Spaces") {
            if (token.type === "Combinator") {
              if (prevToken === null || prevToken.type === "Combinator") {
                tokenizer.pos = prevTokenPos;
                tokenizer.error("Unexpected combinator");
              }
              combinators[token.value] = true;
            } else if (prevToken !== null && prevToken.type !== "Combinator") {
              combinators[" "] = true;
              terms.push({
                type: "Combinator",
                value: " "
              });
            }
            terms.push(token);
            prevToken = token;
            prevTokenPos = tokenizer.pos;
          }
        }
        if (prevToken !== null && prevToken.type === "Combinator") {
          tokenizer.pos -= prevTokenPos;
          tokenizer.error("Unexpected combinator");
        }
        return {
          type: "Group",
          terms,
          combinator: regroupTerms(terms, combinators) || " ",
          disallowEmpty: false,
          explicit: false
        };
      }
      function readGroup(tokenizer) {
        var result;
        tokenizer.eat(LEFTSQUAREBRACKET);
        result = readImplicitGroup(tokenizer);
        tokenizer.eat(RIGHTSQUAREBRACKET);
        result.explicit = true;
        if (tokenizer.charCode() === EXCLAMATIONMARK) {
          tokenizer.pos++;
          result.disallowEmpty = true;
        }
        return result;
      }
      function peek(tokenizer) {
        var code = tokenizer.charCode();
        if (code < 128 && NAME_CHAR[code] === 1) {
          return readKeywordOrFunction(tokenizer);
        }
        switch (code) {
          case RIGHTSQUAREBRACKET:
            break;
          case LEFTSQUAREBRACKET:
            return maybeMultiplied(tokenizer, readGroup(tokenizer));
          case LESSTHANSIGN:
            return tokenizer.nextCharCode() === APOSTROPHE ? readProperty(tokenizer) : readType(tokenizer);
          case VERTICALLINE:
            return {
              type: "Combinator",
              value: tokenizer.substringToPos(
                tokenizer.nextCharCode() === VERTICALLINE ? tokenizer.pos + 2 : tokenizer.pos + 1
              )
            };
          case AMPERSAND:
            tokenizer.pos++;
            tokenizer.eat(AMPERSAND);
            return {
              type: "Combinator",
              value: "&&"
            };
          case COMMA:
            tokenizer.pos++;
            return {
              type: "Comma"
            };
          case APOSTROPHE:
            return maybeMultiplied(tokenizer, {
              type: "String",
              value: scanString(tokenizer)
            });
          case SPACE:
          case TAB:
          case N:
          case R2:
          case F:
            return {
              type: "Spaces",
              value: scanSpaces(tokenizer)
            };
          case COMMERCIALAT:
            code = tokenizer.nextCharCode();
            if (code < 128 && NAME_CHAR[code] === 1) {
              tokenizer.pos++;
              return {
                type: "AtKeyword",
                name: scanWord(tokenizer)
              };
            }
            return maybeToken(tokenizer);
          case ASTERISK:
          case PLUSSIGN:
          case QUESTIONMARK:
          case NUMBERSIGN:
          case EXCLAMATIONMARK:
            break;
          case LEFTCURLYBRACKET:
            code = tokenizer.nextCharCode();
            if (code < 48 || code > 57) {
              return maybeToken(tokenizer);
            }
            break;
          default:
            return maybeToken(tokenizer);
        }
      }
      function parse(source) {
        var tokenizer = new Tokenizer(source);
        var result = readImplicitGroup(tokenizer);
        if (tokenizer.pos !== source.length) {
          tokenizer.error("Unexpected input");
        }
        if (result.terms.length === 1 && result.terms[0].type === "Group") {
          result = result.terms[0];
        }
        return result;
      }
      parse("[a&&<b>#|<'c'>*||e() f{2} /,(% g#{1,2} h{2,})]!");
      module.exports = parse;
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/definition-syntax/walk.js
  var require_walk = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/definition-syntax/walk.js"(exports, module) {
      var noop2 = function() {
      };
      function ensureFunction(value) {
        return typeof value === "function" ? value : noop2;
      }
      module.exports = function(node, options, context) {
        function walk2(node2) {
          enter.call(context, node2);
          switch (node2.type) {
            case "Group":
              node2.terms.forEach(walk2);
              break;
            case "Multiplier":
              walk2(node2.term);
              break;
            case "Type":
            case "Property":
            case "Keyword":
            case "AtKeyword":
            case "Function":
            case "String":
            case "Token":
            case "Comma":
              break;
            default:
              throw new Error("Unknown type: " + node2.type);
          }
          leave.call(context, node2);
        }
        var enter = noop2;
        var leave = noop2;
        if (typeof options === "function") {
          enter = options;
        } else if (options) {
          enter = ensureFunction(options.enter);
          leave = ensureFunction(options.leave);
        }
        if (enter === noop2 && leave === noop2) {
          throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
        }
        walk2(node, context);
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/lexer/prepare-tokens.js
  var require_prepare_tokens = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/lexer/prepare-tokens.js"(exports, module) {
      var tokenize = require_tokenizer();
      var TokenStream = require_TokenStream();
      var tokenStream = new TokenStream();
      var astToTokens = {
        decorator: function(handlers) {
          var curNode = null;
          var prev = { len: 0, node: null };
          var nodes = [prev];
          var buffer2 = "";
          return {
            children: handlers.children,
            node: function(node) {
              var tmp = curNode;
              curNode = node;
              handlers.node.call(this, node);
              curNode = tmp;
            },
            chunk: function(chunk) {
              buffer2 += chunk;
              if (prev.node !== curNode) {
                nodes.push({
                  len: chunk.length,
                  node: curNode
                });
              } else {
                prev.len += chunk.length;
              }
            },
            result: function() {
              return prepareTokens(buffer2, nodes);
            }
          };
        }
      };
      function prepareTokens(str, nodes) {
        var tokens = [];
        var nodesOffset = 0;
        var nodesIndex = 0;
        var currentNode = nodes ? nodes[nodesIndex].node : null;
        tokenize(str, tokenStream);
        while (!tokenStream.eof) {
          if (nodes) {
            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
              nodesOffset += nodes[nodesIndex++].len;
              currentNode = nodes[nodesIndex].node;
            }
          }
          tokens.push({
            type: tokenStream.tokenType,
            value: tokenStream.getTokenValue(),
            index: tokenStream.tokenIndex,
            // TODO: remove it, temporary solution
            balance: tokenStream.balance[tokenStream.tokenIndex],
            // TODO: remove it, temporary solution
            node: currentNode
          });
          tokenStream.next();
        }
        return tokens;
      }
      module.exports = function(value, syntax) {
        if (typeof value === "string") {
          return prepareTokens(value, null);
        }
        return syntax.generate(value, astToTokens);
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/lexer/match-graph.js
  var require_match_graph = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/lexer/match-graph.js"(exports, module) {
      var parse = require_parse();
      var MATCH = { type: "Match" };
      var MISMATCH = { type: "Mismatch" };
      var DISALLOW_EMPTY = { type: "DisallowEmpty" };
      var LEFTPARENTHESIS = 40;
      var RIGHTPARENTHESIS = 41;
      function createCondition(match, thenBranch, elseBranch) {
        if (thenBranch === MATCH && elseBranch === MISMATCH) {
          return match;
        }
        if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
          return match;
        }
        if (match.type === "If" && match.else === MISMATCH && thenBranch === MATCH) {
          thenBranch = match.then;
          match = match.match;
        }
        return {
          type: "If",
          match,
          then: thenBranch,
          else: elseBranch
        };
      }
      function isFunctionType(name) {
        return name.length > 2 && name.charCodeAt(name.length - 2) === LEFTPARENTHESIS && name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS;
      }
      function isEnumCapatible(term) {
        return term.type === "Keyword" || term.type === "AtKeyword" || term.type === "Function" || term.type === "Type" && isFunctionType(term.name);
      }
      function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
        switch (combinator) {
          case " ":
            var result = MATCH;
            for (var i = terms.length - 1; i >= 0; i--) {
              var term = terms[i];
              result = createCondition(
                term,
                result,
                MISMATCH
              );
            }
            ;
            return result;
          case "|":
            var result = MISMATCH;
            var map = null;
            for (var i = terms.length - 1; i >= 0; i--) {
              var term = terms[i];
              if (isEnumCapatible(term)) {
                if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
                  map = /* @__PURE__ */ Object.create(null);
                  result = createCondition(
                    {
                      type: "Enum",
                      map
                    },
                    MATCH,
                    result
                  );
                }
                if (map !== null) {
                  var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
                  if (key in map === false) {
                    map[key] = term;
                    continue;
                  }
                }
              }
              map = null;
              result = createCondition(
                term,
                MATCH,
                result
              );
            }
            ;
            return result;
          case "&&":
            if (terms.length > 5) {
              return {
                type: "MatchOnce",
                terms,
                all: true
              };
            }
            var result = MISMATCH;
            for (var i = terms.length - 1; i >= 0; i--) {
              var term = terms[i];
              var thenClause;
              if (terms.length > 1) {
                thenClause = buildGroupMatchGraph(
                  combinator,
                  terms.filter(function(newGroupTerm) {
                    return newGroupTerm !== term;
                  }),
                  false
                );
              } else {
                thenClause = MATCH;
              }
              result = createCondition(
                term,
                thenClause,
                result
              );
            }
            ;
            return result;
          case "||":
            if (terms.length > 5) {
              return {
                type: "MatchOnce",
                terms,
                all: false
              };
            }
            var result = atLeastOneTermMatched ? MATCH : MISMATCH;
            for (var i = terms.length - 1; i >= 0; i--) {
              var term = terms[i];
              var thenClause;
              if (terms.length > 1) {
                thenClause = buildGroupMatchGraph(
                  combinator,
                  terms.filter(function(newGroupTerm) {
                    return newGroupTerm !== term;
                  }),
                  true
                );
              } else {
                thenClause = MATCH;
              }
              result = createCondition(
                term,
                thenClause,
                result
              );
            }
            ;
            return result;
        }
      }
      function buildMultiplierMatchGraph(node) {
        var result = MATCH;
        var matchTerm = buildMatchGraph(node.term);
        if (node.max === 0) {
          matchTerm = createCondition(
            matchTerm,
            DISALLOW_EMPTY,
            MISMATCH
          );
          result = createCondition(
            matchTerm,
            null,
            // will be a loop
            MISMATCH
          );
          result.then = createCondition(
            MATCH,
            MATCH,
            result
            // make a loop
          );
          if (node.comma) {
            result.then.else = createCondition(
              { type: "Comma", syntax: node },
              result,
              MISMATCH
            );
          }
        } else {
          for (var i = node.min || 1; i <= node.max; i++) {
            if (node.comma && result !== MATCH) {
              result = createCondition(
                { type: "Comma", syntax: node },
                result,
                MISMATCH
              );
            }
            result = createCondition(
              matchTerm,
              createCondition(
                MATCH,
                MATCH,
                result
              ),
              MISMATCH
            );
          }
        }
        if (node.min === 0) {
          result = createCondition(
            MATCH,
            MATCH,
            result
          );
        } else {
          for (var i = 0; i < node.min - 1; i++) {
            if (node.comma && result !== MATCH) {
              result = createCondition(
                { type: "Comma", syntax: node },
                result,
                MISMATCH
              );
            }
            result = createCondition(
              matchTerm,
              result,
              MISMATCH
            );
          }
        }
        return result;
      }
      function buildMatchGraph(node) {
        if (typeof node === "function") {
          return {
            type: "Generic",
            fn: node
          };
        }
        switch (node.type) {
          case "Group":
            var result = buildGroupMatchGraph(
              node.combinator,
              node.terms.map(buildMatchGraph),
              false
            );
            if (node.disallowEmpty) {
              result = createCondition(
                result,
                DISALLOW_EMPTY,
                MISMATCH
              );
            }
            return result;
          case "Multiplier":
            return buildMultiplierMatchGraph(node);
          case "Type":
          case "Property":
            return {
              type: node.type,
              name: node.name,
              syntax: node
            };
          case "Keyword":
            return {
              type: node.type,
              name: node.name.toLowerCase(),
              syntax: node
            };
          case "AtKeyword":
            return {
              type: node.type,
              name: "@" + node.name.toLowerCase(),
              syntax: node
            };
          case "Function":
            return {
              type: node.type,
              name: node.name.toLowerCase() + "(",
              syntax: node
            };
          case "String":
            if (node.value.length === 3) {
              return {
                type: "Token",
                value: node.value.charAt(1),
                syntax: node
              };
            }
            return {
              type: node.type,
              value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, "'"),
              syntax: node
            };
          case "Token":
            return {
              type: node.type,
              value: node.value,
              syntax: node
            };
          case "Comma":
            return {
              type: node.type,
              syntax: node
            };
          default:
            throw new Error("Unknown node type:", node.type);
        }
      }
      module.exports = {
        MATCH,
        MISMATCH,
        DISALLOW_EMPTY,
        buildMatchGraph: function(syntaxTree, ref) {
          if (typeof syntaxTree === "string") {
            syntaxTree = parse(syntaxTree);
          }
          return {
            type: "MatchGraph",
            match: buildMatchGraph(syntaxTree),
            syntax: ref || null,
            source: syntaxTree
          };
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/lexer/match.js
  var require_match = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/lexer/match.js"(exports, module) {
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var matchGraph = require_match_graph();
      var MATCH = matchGraph.MATCH;
      var MISMATCH = matchGraph.MISMATCH;
      var DISALLOW_EMPTY = matchGraph.DISALLOW_EMPTY;
      var TYPE = require_const().TYPE;
      var STUB = 0;
      var TOKEN = 1;
      var OPEN_SYNTAX = 2;
      var CLOSE_SYNTAX = 3;
      var EXIT_REASON_MATCH = "Match";
      var EXIT_REASON_MISMATCH = "Mismatch";
      var EXIT_REASON_ITERATION_LIMIT = "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";
      var ITERATION_LIMIT = 15e3;
      var totalIterationCount = 0;
      function reverseList(list) {
        var prev = null;
        var next = null;
        var item = list;
        while (item !== null) {
          next = item.prev;
          item.prev = prev;
          prev = item;
          item = next;
        }
        return prev;
      }
      function areStringsEqualCaseInsensitive(testStr, referenceStr) {
        if (testStr.length !== referenceStr.length) {
          return false;
        }
        for (var i = 0; i < testStr.length; i++) {
          var testCode = testStr.charCodeAt(i);
          var referenceCode = referenceStr.charCodeAt(i);
          if (testCode >= 65 && testCode <= 90) {
            testCode = testCode | 32;
          }
          if (testCode !== referenceCode) {
            return false;
          }
        }
        return true;
      }
      function isContextEdgeDelim(token) {
        if (token.type !== TYPE.Delim) {
          return false;
        }
        return token.value !== "?";
      }
      function isCommaContextStart(token) {
        if (token === null) {
          return true;
        }
        return token.type === TYPE.Comma || token.type === TYPE.Function || token.type === TYPE.LeftParenthesis || token.type === TYPE.LeftSquareBracket || token.type === TYPE.LeftCurlyBracket || isContextEdgeDelim(token);
      }
      function isCommaContextEnd(token) {
        if (token === null) {
          return true;
        }
        return token.type === TYPE.RightParenthesis || token.type === TYPE.RightSquareBracket || token.type === TYPE.RightCurlyBracket || token.type === TYPE.Delim;
      }
      function internalMatch(tokens, state2, syntaxes) {
        function moveToNextToken() {
          do {
            tokenIndex++;
            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
          } while (token !== null && (token.type === TYPE.WhiteSpace || token.type === TYPE.Comment));
        }
        function getNextToken(offset) {
          var nextIndex = tokenIndex + offset;
          return nextIndex < tokens.length ? tokens[nextIndex] : null;
        }
        function stateSnapshotFromSyntax(nextState, prev) {
          return {
            nextState,
            matchStack,
            syntaxStack,
            thenStack,
            tokenIndex,
            prev
          };
        }
        function pushThenStack(nextState) {
          thenStack = {
            nextState,
            matchStack,
            syntaxStack,
            prev: thenStack
          };
        }
        function pushElseStack(nextState) {
          elseStack = stateSnapshotFromSyntax(nextState, elseStack);
        }
        function addTokenToMatch() {
          matchStack = {
            type: TOKEN,
            syntax: state2.syntax,
            token,
            prev: matchStack
          };
          moveToNextToken();
          syntaxStash = null;
          if (tokenIndex > longestMatch) {
            longestMatch = tokenIndex;
          }
        }
        function openSyntax() {
          syntaxStack = {
            syntax: state2.syntax,
            opts: state2.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,
            prev: syntaxStack
          };
          matchStack = {
            type: OPEN_SYNTAX,
            syntax: state2.syntax,
            token: matchStack.token,
            prev: matchStack
          };
        }
        function closeSyntax() {
          if (matchStack.type === OPEN_SYNTAX) {
            matchStack = matchStack.prev;
          } else {
            matchStack = {
              type: CLOSE_SYNTAX,
              syntax: syntaxStack.syntax,
              token: matchStack.token,
              prev: matchStack
            };
          }
          syntaxStack = syntaxStack.prev;
        }
        var syntaxStack = null;
        var thenStack = null;
        var elseStack = null;
        var syntaxStash = null;
        var iterationCount = 0;
        var exitReason = null;
        var token = null;
        var tokenIndex = -1;
        var longestMatch = 0;
        var matchStack = {
          type: STUB,
          syntax: null,
          token: null,
          prev: null
        };
        moveToNextToken();
        while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
          switch (state2.type) {
            case "Match":
              if (thenStack === null) {
                if (token !== null) {
                  if (tokenIndex !== tokens.length - 1 || token.value !== "\\0" && token.value !== "\\9") {
                    state2 = MISMATCH;
                    break;
                  }
                }
                exitReason = EXIT_REASON_MATCH;
                break;
              }
              state2 = thenStack.nextState;
              if (state2 === DISALLOW_EMPTY) {
                if (thenStack.matchStack === matchStack) {
                  state2 = MISMATCH;
                  break;
                } else {
                  state2 = MATCH;
                }
              }
              while (thenStack.syntaxStack !== syntaxStack) {
                closeSyntax();
              }
              thenStack = thenStack.prev;
              break;
            case "Mismatch":
              if (syntaxStash !== null && syntaxStash !== false) {
                if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
                  elseStack = syntaxStash;
                  syntaxStash = false;
                }
              } else if (elseStack === null) {
                exitReason = EXIT_REASON_MISMATCH;
                break;
              }
              state2 = elseStack.nextState;
              thenStack = elseStack.thenStack;
              syntaxStack = elseStack.syntaxStack;
              matchStack = elseStack.matchStack;
              tokenIndex = elseStack.tokenIndex;
              token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
              elseStack = elseStack.prev;
              break;
            case "MatchGraph":
              state2 = state2.match;
              break;
            case "If":
              if (state2.else !== MISMATCH) {
                pushElseStack(state2.else);
              }
              if (state2.then !== MATCH) {
                pushThenStack(state2.then);
              }
              state2 = state2.match;
              break;
            case "MatchOnce":
              state2 = {
                type: "MatchOnceBuffer",
                syntax: state2,
                index: 0,
                mask: 0
              };
              break;
            case "MatchOnceBuffer":
              var terms = state2.syntax.terms;
              if (state2.index === terms.length) {
                if (state2.mask === 0 || state2.syntax.all) {
                  state2 = MISMATCH;
                  break;
                }
                state2 = MATCH;
                break;
              }
              if (state2.mask === (1 << terms.length) - 1) {
                state2 = MATCH;
                break;
              }
              for (; state2.index < terms.length; state2.index++) {
                var matchFlag = 1 << state2.index;
                if ((state2.mask & matchFlag) === 0) {
                  pushElseStack(state2);
                  pushThenStack({
                    type: "AddMatchOnce",
                    syntax: state2.syntax,
                    mask: state2.mask | matchFlag
                  });
                  state2 = terms[state2.index++];
                  break;
                }
              }
              break;
            case "AddMatchOnce":
              state2 = {
                type: "MatchOnceBuffer",
                syntax: state2.syntax,
                index: 0,
                mask: state2.mask
              };
              break;
            case "Enum":
              if (token !== null) {
                var name = token.value.toLowerCase();
                if (name.indexOf("\\") !== -1) {
                  name = name.replace(/\\[09].*$/, "");
                }
                if (hasOwnProperty2.call(state2.map, name)) {
                  state2 = state2.map[name];
                  break;
                }
              }
              state2 = MISMATCH;
              break;
            case "Generic":
              var opts = syntaxStack !== null ? syntaxStack.opts : null;
              var lastTokenIndex = tokenIndex + Math.floor(state2.fn(token, getNextToken, opts));
              if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
                while (tokenIndex < lastTokenIndex) {
                  addTokenToMatch();
                }
                state2 = MATCH;
              } else {
                state2 = MISMATCH;
              }
              break;
            case "Type":
            case "Property":
              var syntaxDict = state2.type === "Type" ? "types" : "properties";
              var dictSyntax = hasOwnProperty2.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state2.name] : null;
              if (!dictSyntax || !dictSyntax.match) {
                throw new Error(
                  "Bad syntax reference: " + (state2.type === "Type" ? "<" + state2.name + ">" : "<'" + state2.name + "'>")
                );
              }
              if (syntaxStash !== false && token !== null && state2.type === "Type") {
                var lowPriorityMatching = (
                  // https://drafts.csswg.org/css-values-4/#custom-idents
                  // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
                  // can only claim the keyword if no other unfulfilled production can claim it.
                  state2.name === "custom-ident" && token.type === TYPE.Ident || // https://drafts.csswg.org/css-values-4/#lengths
                  // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
                  // it must parse as a <number>
                  state2.name === "length" && token.value === "0"
                );
                if (lowPriorityMatching) {
                  if (syntaxStash === null) {
                    syntaxStash = stateSnapshotFromSyntax(state2, elseStack);
                  }
                  state2 = MISMATCH;
                  break;
                }
              }
              openSyntax();
              state2 = dictSyntax.match;
              break;
            case "Keyword":
              var name = state2.name;
              if (token !== null) {
                var keywordName = token.value;
                if (keywordName.indexOf("\\") !== -1) {
                  keywordName = keywordName.replace(/\\[09].*$/, "");
                }
                if (areStringsEqualCaseInsensitive(keywordName, name)) {
                  addTokenToMatch();
                  state2 = MATCH;
                  break;
                }
              }
              state2 = MISMATCH;
              break;
            case "AtKeyword":
            case "Function":
              if (token !== null && areStringsEqualCaseInsensitive(token.value, state2.name)) {
                addTokenToMatch();
                state2 = MATCH;
                break;
              }
              state2 = MISMATCH;
              break;
            case "Token":
              if (token !== null && token.value === state2.value) {
                addTokenToMatch();
                state2 = MATCH;
                break;
              }
              state2 = MISMATCH;
              break;
            case "Comma":
              if (token !== null && token.type === TYPE.Comma) {
                if (isCommaContextStart(matchStack.token)) {
                  state2 = MISMATCH;
                } else {
                  addTokenToMatch();
                  state2 = isCommaContextEnd(token) ? MISMATCH : MATCH;
                }
              } else {
                state2 = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;
              }
              break;
            case "String":
              var string = "";
              for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state2.value.length; lastTokenIndex++) {
                string += tokens[lastTokenIndex].value;
              }
              if (areStringsEqualCaseInsensitive(string, state2.value)) {
                while (tokenIndex < lastTokenIndex) {
                  addTokenToMatch();
                }
                state2 = MATCH;
              } else {
                state2 = MISMATCH;
              }
              break;
            default:
              throw new Error("Unknown node type: " + state2.type);
          }
        }
        totalIterationCount += iterationCount;
        switch (exitReason) {
          case null:
            console.warn("[csstree-match] BREAK after " + ITERATION_LIMIT + " iterations");
            exitReason = EXIT_REASON_ITERATION_LIMIT;
            matchStack = null;
            break;
          case EXIT_REASON_MATCH:
            while (syntaxStack !== null) {
              closeSyntax();
            }
            break;
          default:
            matchStack = null;
        }
        return {
          tokens,
          reason: exitReason,
          iterations: iterationCount,
          match: matchStack,
          longestMatch
        };
      }
      function matchAsList(tokens, matchGraph2, syntaxes) {
        var matchResult = internalMatch(tokens, matchGraph2, syntaxes || {});
        if (matchResult.match !== null) {
          var item = reverseList(matchResult.match).prev;
          matchResult.match = [];
          while (item !== null) {
            switch (item.type) {
              case STUB:
                break;
              case OPEN_SYNTAX:
              case CLOSE_SYNTAX:
                matchResult.match.push({
                  type: item.type,
                  syntax: item.syntax
                });
                break;
              default:
                matchResult.match.push({
                  token: item.token.value,
                  node: item.token.node
                });
                break;
            }
            item = item.prev;
          }
        }
        return matchResult;
      }
      function matchAsTree(tokens, matchGraph2, syntaxes) {
        var matchResult = internalMatch(tokens, matchGraph2, syntaxes || {});
        if (matchResult.match === null) {
          return matchResult;
        }
        var item = matchResult.match;
        var host = matchResult.match = {
          syntax: matchGraph2.syntax || null,
          match: []
        };
        var hostStack = [host];
        item = reverseList(item).prev;
        while (item !== null) {
          switch (item.type) {
            case OPEN_SYNTAX:
              host.match.push(host = {
                syntax: item.syntax,
                match: []
              });
              hostStack.push(host);
              break;
            case CLOSE_SYNTAX:
              hostStack.pop();
              host = hostStack[hostStack.length - 1];
              break;
            default:
              host.match.push({
                syntax: item.syntax || null,
                token: item.token.value,
                node: item.token.node
              });
          }
          item = item.prev;
        }
        return matchResult;
      }
      module.exports = {
        matchAsList,
        matchAsTree,
        getTotalIterationCount: function() {
          return totalIterationCount;
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/lexer/trace.js
  var require_trace = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/lexer/trace.js"(exports, module) {
      function getTrace(node) {
        function shouldPutToTrace(syntax) {
          if (syntax === null) {
            return false;
          }
          return syntax.type === "Type" || syntax.type === "Property" || syntax.type === "Keyword";
        }
        function hasMatch(matchNode) {
          if (Array.isArray(matchNode.match)) {
            for (var i = 0; i < matchNode.match.length; i++) {
              if (hasMatch(matchNode.match[i])) {
                if (shouldPutToTrace(matchNode.syntax)) {
                  result.unshift(matchNode.syntax);
                }
                return true;
              }
            }
          } else if (matchNode.node === node) {
            result = shouldPutToTrace(matchNode.syntax) ? [matchNode.syntax] : [];
            return true;
          }
          return false;
        }
        var result = null;
        if (this.matched !== null) {
          hasMatch(this.matched);
        }
        return result;
      }
      function testNode(match, node, fn) {
        var trace = getTrace.call(match, node);
        if (trace === null) {
          return false;
        }
        return trace.some(fn);
      }
      function isType(node, type) {
        return testNode(this, node, function(matchNode) {
          return matchNode.type === "Type" && matchNode.name === type;
        });
      }
      function isProperty(node, property) {
        return testNode(this, node, function(matchNode) {
          return matchNode.type === "Property" && matchNode.name === property;
        });
      }
      function isKeyword(node) {
        return testNode(this, node, function(matchNode) {
          return matchNode.type === "Keyword";
        });
      }
      module.exports = {
        getTrace,
        isType,
        isProperty,
        isKeyword
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/lexer/search.js
  var require_search = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/lexer/search.js"(exports, module) {
      var List = require_List();
      function getFirstMatchNode(matchNode) {
        if ("node" in matchNode) {
          return matchNode.node;
        }
        return getFirstMatchNode(matchNode.match[0]);
      }
      function getLastMatchNode(matchNode) {
        if ("node" in matchNode) {
          return matchNode.node;
        }
        return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
      }
      function matchFragments(lexer, ast, match, type, name) {
        function findFragments(matchNode) {
          if (matchNode.syntax !== null && matchNode.syntax.type === type && matchNode.syntax.name === name) {
            var start = getFirstMatchNode(matchNode);
            var end = getLastMatchNode(matchNode);
            lexer.syntax.walk(ast, function(node, item, list) {
              if (node === start) {
                var nodes = new List();
                do {
                  nodes.appendData(item.data);
                  if (item.data === end) {
                    break;
                  }
                  item = item.next;
                } while (item !== null);
                fragments.push({
                  parent: list,
                  nodes
                });
              }
            });
          }
          if (Array.isArray(matchNode.match)) {
            matchNode.match.forEach(findFragments);
          }
        }
        var fragments = [];
        if (match.matched !== null) {
          findFragments(match.matched);
        }
        return fragments;
      }
      module.exports = {
        matchFragments
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/lexer/structure.js
  var require_structure = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/lexer/structure.js"(exports, module) {
      var List = require_List();
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      function isValidNumber(value) {
        return typeof value === "number" && isFinite(value) && Math.floor(value) === value && value >= 0;
      }
      function isValidLocation(loc) {
        return Boolean(loc) && isValidNumber(loc.offset) && isValidNumber(loc.line) && isValidNumber(loc.column);
      }
      function createNodeStructureChecker(type, fields) {
        return function checkNode(node, warn) {
          if (!node || node.constructor !== Object) {
            return warn(node, "Type of node should be an Object");
          }
          for (var key in node) {
            var valid = true;
            if (hasOwnProperty2.call(node, key) === false) {
              continue;
            }
            if (key === "type") {
              if (node.type !== type) {
                warn(node, "Wrong node type `" + node.type + "`, expected `" + type + "`");
              }
            } else if (key === "loc") {
              if (node.loc === null) {
                continue;
              } else if (node.loc && node.loc.constructor === Object) {
                if (typeof node.loc.source !== "string") {
                  key += ".source";
                } else if (!isValidLocation(node.loc.start)) {
                  key += ".start";
                } else if (!isValidLocation(node.loc.end)) {
                  key += ".end";
                } else {
                  continue;
                }
              }
              valid = false;
            } else if (fields.hasOwnProperty(key)) {
              for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
                var fieldType = fields[key][i];
                switch (fieldType) {
                  case String:
                    valid = typeof node[key] === "string";
                    break;
                  case Boolean:
                    valid = typeof node[key] === "boolean";
                    break;
                  case null:
                    valid = node[key] === null;
                    break;
                  default:
                    if (typeof fieldType === "string") {
                      valid = node[key] && node[key].type === fieldType;
                    } else if (Array.isArray(fieldType)) {
                      valid = node[key] instanceof List;
                    }
                }
              }
            } else {
              warn(node, "Unknown field `" + key + "` for " + type + " node type");
            }
            if (!valid) {
              warn(node, "Bad value for `" + type + "." + key + "`");
            }
          }
          for (var key in fields) {
            if (hasOwnProperty2.call(fields, key) && hasOwnProperty2.call(node, key) === false) {
              warn(node, "Field `" + type + "." + key + "` is missed");
            }
          }
        };
      }
      function processStructure(name, nodeType) {
        var structure = nodeType.structure;
        var fields = {
          type: String,
          loc: true
        };
        var docs = {
          type: '"' + name + '"'
        };
        for (var key in structure) {
          if (hasOwnProperty2.call(structure, key) === false) {
            continue;
          }
          var docsTypes = [];
          var fieldTypes = fields[key] = Array.isArray(structure[key]) ? structure[key].slice() : [structure[key]];
          for (var i = 0; i < fieldTypes.length; i++) {
            var fieldType = fieldTypes[i];
            if (fieldType === String || fieldType === Boolean) {
              docsTypes.push(fieldType.name);
            } else if (fieldType === null) {
              docsTypes.push("null");
            } else if (typeof fieldType === "string") {
              docsTypes.push("<" + fieldType + ">");
            } else if (Array.isArray(fieldType)) {
              docsTypes.push("List");
            } else {
              throw new Error("Wrong value `" + fieldType + "` in `" + name + "." + key + "` structure definition");
            }
          }
          docs[key] = docsTypes.join(" | ");
        }
        return {
          docs,
          check: createNodeStructureChecker(name, fields)
        };
      }
      module.exports = {
        getStructureFromConfig: function(config) {
          var structure = {};
          if (config.node) {
            for (var name in config.node) {
              if (hasOwnProperty2.call(config.node, name)) {
                var nodeType = config.node[name];
                if (nodeType.structure) {
                  structure[name] = processStructure(name, nodeType);
                } else {
                  throw new Error("Missed `structure` field in `" + name + "` node type definition");
                }
              }
            }
          }
          return structure;
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/lexer/Lexer.js
  var require_Lexer = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/lexer/Lexer.js"(exports, module) {
      var SyntaxReferenceError = require_error().SyntaxReferenceError;
      var SyntaxMatchError = require_error().SyntaxMatchError;
      var names = require_names();
      var generic = require_generic();
      var parse = require_parse();
      var generate = require_generate();
      var walk2 = require_walk();
      var prepareTokens = require_prepare_tokens();
      var buildMatchGraph = require_match_graph().buildMatchGraph;
      var matchAsTree = require_match().matchAsTree;
      var trace = require_trace();
      var search = require_search();
      var getStructureFromConfig = require_structure().getStructureFromConfig;
      var cssWideKeywords = buildMatchGraph("inherit | initial | unset");
      var cssWideKeywordsWithExpression = buildMatchGraph("inherit | initial | unset | <-ms-legacy-expression>");
      function dumpMapSyntax(map, compact, syntaxAsAst) {
        var result = {};
        for (var name in map) {
          if (map[name].syntax) {
            result[name] = syntaxAsAst ? map[name].syntax : generate(map[name].syntax, { compact });
          }
        }
        return result;
      }
      function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
        const result = {};
        for (const [name, atrule] of Object.entries(map)) {
          result[name] = {
            prelude: atrule.prelude && (syntaxAsAst ? atrule.prelude.syntax : generate(atrule.prelude.syntax, { compact })),
            descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)
          };
        }
        return result;
      }
      function valueHasVar(tokens) {
        for (var i = 0; i < tokens.length; i++) {
          if (tokens[i].value.toLowerCase() === "var(") {
            return true;
          }
        }
        return false;
      }
      function buildMatchResult(match, error, iterations) {
        return {
          matched: match,
          iterations,
          error,
          getTrace: trace.getTrace,
          isType: trace.isType,
          isProperty: trace.isProperty,
          isKeyword: trace.isKeyword
        };
      }
      function matchSyntax(lexer, syntax, value, useCommon) {
        var tokens = prepareTokens(value, lexer.syntax);
        var result;
        if (valueHasVar(tokens)) {
          return buildMatchResult(null, new Error("Matching for a tree with var() is not supported"));
        }
        if (useCommon) {
          result = matchAsTree(tokens, lexer.valueCommonSyntax, lexer);
        }
        if (!useCommon || !result.match) {
          result = matchAsTree(tokens, syntax.match, lexer);
          if (!result.match) {
            return buildMatchResult(
              null,
              new SyntaxMatchError(result.reason, syntax.syntax, value, result),
              result.iterations
            );
          }
        }
        return buildMatchResult(result.match, null, result.iterations);
      }
      var Lexer = function(config, syntax, structure) {
        this.valueCommonSyntax = cssWideKeywords;
        this.syntax = syntax;
        this.generic = false;
        this.atrules = {};
        this.properties = {};
        this.types = {};
        this.structure = structure || getStructureFromConfig(config);
        if (config) {
          if (config.types) {
            for (var name in config.types) {
              this.addType_(name, config.types[name]);
            }
          }
          if (config.generic) {
            this.generic = true;
            for (var name in generic) {
              this.addType_(name, generic[name]);
            }
          }
          if (config.atrules) {
            for (var name in config.atrules) {
              this.addAtrule_(name, config.atrules[name]);
            }
          }
          if (config.properties) {
            for (var name in config.properties) {
              this.addProperty_(name, config.properties[name]);
            }
          }
        }
      };
      Lexer.prototype = {
        structure: {},
        checkStructure: function(ast) {
          function collectWarning(node, message) {
            warns.push({
              node,
              message
            });
          }
          var structure = this.structure;
          var warns = [];
          this.syntax.walk(ast, function(node) {
            if (structure.hasOwnProperty(node.type)) {
              structure[node.type].check(node, collectWarning);
            } else {
              collectWarning(node, "Unknown node type `" + node.type + "`");
            }
          });
          return warns.length ? warns : false;
        },
        createDescriptor: function(syntax, type, name, parent = null) {
          var ref = {
            type,
            name
          };
          var descriptor = {
            type,
            name,
            parent,
            syntax: null,
            match: null
          };
          if (typeof syntax === "function") {
            descriptor.match = buildMatchGraph(syntax, ref);
          } else {
            if (typeof syntax === "string") {
              Object.defineProperty(descriptor, "syntax", {
                get: function() {
                  Object.defineProperty(descriptor, "syntax", {
                    value: parse(syntax)
                  });
                  return descriptor.syntax;
                }
              });
            } else {
              descriptor.syntax = syntax;
            }
            Object.defineProperty(descriptor, "match", {
              get: function() {
                Object.defineProperty(descriptor, "match", {
                  value: buildMatchGraph(descriptor.syntax, ref)
                });
                return descriptor.match;
              }
            });
          }
          return descriptor;
        },
        addAtrule_: function(name, syntax) {
          if (!syntax) {
            return;
          }
          this.atrules[name] = {
            type: "Atrule",
            name,
            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, "AtrulePrelude", name) : null,
            descriptors: syntax.descriptors ? Object.keys(syntax.descriptors).reduce((res, descName) => {
              res[descName] = this.createDescriptor(syntax.descriptors[descName], "AtruleDescriptor", descName, name);
              return res;
            }, {}) : null
          };
        },
        addProperty_: function(name, syntax) {
          if (!syntax) {
            return;
          }
          this.properties[name] = this.createDescriptor(syntax, "Property", name);
        },
        addType_: function(name, syntax) {
          if (!syntax) {
            return;
          }
          this.types[name] = this.createDescriptor(syntax, "Type", name);
          if (syntax === generic["-ms-legacy-expression"]) {
            this.valueCommonSyntax = cssWideKeywordsWithExpression;
          }
        },
        checkAtruleName: function(atruleName) {
          if (!this.getAtrule(atruleName)) {
            return new SyntaxReferenceError("Unknown at-rule", "@" + atruleName);
          }
        },
        checkAtrulePrelude: function(atruleName, prelude) {
          let error = this.checkAtruleName(atruleName);
          if (error) {
            return error;
          }
          var atrule = this.getAtrule(atruleName);
          if (!atrule.prelude && prelude) {
            return new SyntaxError("At-rule `@" + atruleName + "` should not contain a prelude");
          }
          if (atrule.prelude && !prelude) {
            return new SyntaxError("At-rule `@" + atruleName + "` should contain a prelude");
          }
        },
        checkAtruleDescriptorName: function(atruleName, descriptorName) {
          let error = this.checkAtruleName(atruleName);
          if (error) {
            return error;
          }
          var atrule = this.getAtrule(atruleName);
          var descriptor = names.keyword(descriptorName);
          if (!atrule.descriptors) {
            return new SyntaxError("At-rule `@" + atruleName + "` has no known descriptors");
          }
          if (!atrule.descriptors[descriptor.name] && !atrule.descriptors[descriptor.basename]) {
            return new SyntaxReferenceError("Unknown at-rule descriptor", descriptorName);
          }
        },
        checkPropertyName: function(propertyName) {
          var property = names.property(propertyName);
          if (property.custom) {
            return new Error("Lexer matching doesn't applicable for custom properties");
          }
          if (!this.getProperty(propertyName)) {
            return new SyntaxReferenceError("Unknown property", propertyName);
          }
        },
        matchAtrulePrelude: function(atruleName, prelude) {
          var error = this.checkAtrulePrelude(atruleName, prelude);
          if (error) {
            return buildMatchResult(null, error);
          }
          if (!prelude) {
            return buildMatchResult(null, null);
          }
          return matchSyntax(this, this.getAtrule(atruleName).prelude, prelude, false);
        },
        matchAtruleDescriptor: function(atruleName, descriptorName, value) {
          var error = this.checkAtruleDescriptorName(atruleName, descriptorName);
          if (error) {
            return buildMatchResult(null, error);
          }
          var atrule = this.getAtrule(atruleName);
          var descriptor = names.keyword(descriptorName);
          return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);
        },
        matchDeclaration: function(node) {
          if (node.type !== "Declaration") {
            return buildMatchResult(null, new Error("Not a Declaration node"));
          }
          return this.matchProperty(node.property, node.value);
        },
        matchProperty: function(propertyName, value) {
          var error = this.checkPropertyName(propertyName);
          if (error) {
            return buildMatchResult(null, error);
          }
          return matchSyntax(this, this.getProperty(propertyName), value, true);
        },
        matchType: function(typeName, value) {
          var typeSyntax = this.getType(typeName);
          if (!typeSyntax) {
            return buildMatchResult(null, new SyntaxReferenceError("Unknown type", typeName));
          }
          return matchSyntax(this, typeSyntax, value, false);
        },
        match: function(syntax, value) {
          if (typeof syntax !== "string" && (!syntax || !syntax.type)) {
            return buildMatchResult(null, new SyntaxReferenceError("Bad syntax"));
          }
          if (typeof syntax === "string" || !syntax.match) {
            syntax = this.createDescriptor(syntax, "Type", "anonymous");
          }
          return matchSyntax(this, syntax, value, false);
        },
        findValueFragments: function(propertyName, value, type, name) {
          return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
        },
        findDeclarationValueFragments: function(declaration, type, name) {
          return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
        },
        findAllFragments: function(ast, type, name) {
          var result = [];
          this.syntax.walk(ast, {
            visit: "Declaration",
            enter: function(declaration) {
              result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
            }.bind(this)
          });
          return result;
        },
        getAtrule: function(atruleName, fallbackBasename = true) {
          var atrule = names.keyword(atruleName);
          var atruleEntry = atrule.vendor && fallbackBasename ? this.atrules[atrule.name] || this.atrules[atrule.basename] : this.atrules[atrule.name];
          return atruleEntry || null;
        },
        getAtrulePrelude: function(atruleName, fallbackBasename = true) {
          const atrule = this.getAtrule(atruleName, fallbackBasename);
          return atrule && atrule.prelude || null;
        },
        getAtruleDescriptor: function(atruleName, name) {
          return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name] || null : null;
        },
        getProperty: function(propertyName, fallbackBasename = true) {
          var property = names.property(propertyName);
          var propertyEntry = property.vendor && fallbackBasename ? this.properties[property.name] || this.properties[property.basename] : this.properties[property.name];
          return propertyEntry || null;
        },
        getType: function(name) {
          return this.types.hasOwnProperty(name) ? this.types[name] : null;
        },
        validate: function() {
          function validate(syntax, name, broken, descriptor) {
            if (broken.hasOwnProperty(name)) {
              return broken[name];
            }
            broken[name] = false;
            if (descriptor.syntax !== null) {
              walk2(descriptor.syntax, function(node) {
                if (node.type !== "Type" && node.type !== "Property") {
                  return;
                }
                var map = node.type === "Type" ? syntax.types : syntax.properties;
                var brokenMap = node.type === "Type" ? brokenTypes : brokenProperties;
                if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
                  broken[name] = true;
                }
              }, this);
            }
          }
          var brokenTypes = {};
          var brokenProperties = {};
          for (var key in this.types) {
            validate(this, key, brokenTypes, this.types[key]);
          }
          for (var key in this.properties) {
            validate(this, key, brokenProperties, this.properties[key]);
          }
          brokenTypes = Object.keys(brokenTypes).filter(function(name) {
            return brokenTypes[name];
          });
          brokenProperties = Object.keys(brokenProperties).filter(function(name) {
            return brokenProperties[name];
          });
          if (brokenTypes.length || brokenProperties.length) {
            return {
              types: brokenTypes,
              properties: brokenProperties
            };
          }
          return null;
        },
        dump: function(syntaxAsAst, pretty) {
          return {
            generic: this.generic,
            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
            atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
          };
        },
        toString: function() {
          return JSON.stringify(this.dump());
        }
      };
      module.exports = Lexer;
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/definition-syntax/index.js
  var require_definition_syntax = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/definition-syntax/index.js"(exports, module) {
      module.exports = {
        SyntaxError: require_SyntaxError2(),
        parse: require_parse(),
        generate: require_generate(),
        walk: require_walk()
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/common/OffsetToLocation.js
  var require_OffsetToLocation = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/common/OffsetToLocation.js"(exports, module) {
      var adoptBuffer = require_adopt_buffer();
      var isBOM = require_tokenizer().isBOM;
      var N = 10;
      var F = 12;
      var R2 = 13;
      function computeLinesAndColumns(host, source) {
        var sourceLength = source.length;
        var lines = adoptBuffer(host.lines, sourceLength);
        var line = host.startLine;
        var columns = adoptBuffer(host.columns, sourceLength);
        var column = host.startColumn;
        var startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;
        for (var i = startOffset; i < sourceLength; i++) {
          var code = source.charCodeAt(i);
          lines[i] = line;
          columns[i] = column++;
          if (code === N || code === R2 || code === F) {
            if (code === R2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {
              i++;
              lines[i] = line;
              columns[i] = column;
            }
            line++;
            column = 1;
          }
        }
        lines[i] = line;
        columns[i] = column;
        host.lines = lines;
        host.columns = columns;
      }
      var OffsetToLocation = function() {
        this.lines = null;
        this.columns = null;
        this.linesAndColumnsComputed = false;
      };
      OffsetToLocation.prototype = {
        setSource: function(source, startOffset, startLine, startColumn) {
          this.source = source;
          this.startOffset = typeof startOffset === "undefined" ? 0 : startOffset;
          this.startLine = typeof startLine === "undefined" ? 1 : startLine;
          this.startColumn = typeof startColumn === "undefined" ? 1 : startColumn;
          this.linesAndColumnsComputed = false;
        },
        ensureLinesAndColumnsComputed: function() {
          if (!this.linesAndColumnsComputed) {
            computeLinesAndColumns(this, this.source);
            this.linesAndColumnsComputed = true;
          }
        },
        getLocation: function(offset, filename) {
          this.ensureLinesAndColumnsComputed();
          return {
            source: filename,
            offset: this.startOffset + offset,
            line: this.lines[offset],
            column: this.columns[offset]
          };
        },
        getLocationRange: function(start, end, filename) {
          this.ensureLinesAndColumnsComputed();
          return {
            source: filename,
            start: {
              offset: this.startOffset + start,
              line: this.lines[start],
              column: this.columns[start]
            },
            end: {
              offset: this.startOffset + end,
              line: this.lines[end],
              column: this.columns[end]
            }
          };
        }
      };
      module.exports = OffsetToLocation;
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/parser/sequence.js
  var require_sequence = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/parser/sequence.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var WHITESPACE = TYPE.WhiteSpace;
      var COMMENT = TYPE.Comment;
      module.exports = function readSequence(recognizer) {
        var children = this.createList();
        var child2 = null;
        var context = {
          recognizer,
          space: null,
          ignoreWS: false,
          ignoreWSAfter: false
        };
        this.scanner.skipSC();
        while (!this.scanner.eof) {
          switch (this.scanner.tokenType) {
            case COMMENT:
              this.scanner.next();
              continue;
            case WHITESPACE:
              if (context.ignoreWS) {
                this.scanner.next();
              } else {
                context.space = this.WhiteSpace();
              }
              continue;
          }
          child2 = recognizer.getNode.call(this, context);
          if (child2 === void 0) {
            break;
          }
          if (context.space !== null) {
            children.push(context.space);
            context.space = null;
          }
          children.push(child2);
          if (context.ignoreWSAfter) {
            context.ignoreWSAfter = false;
            context.ignoreWS = true;
          } else {
            context.ignoreWS = false;
          }
        }
        return children;
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/parser/create.js
  var require_create = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/parser/create.js"(exports, module) {
      var OffsetToLocation = require_OffsetToLocation();
      var SyntaxError2 = require_SyntaxError();
      var TokenStream = require_TokenStream();
      var List = require_List();
      var tokenize = require_tokenizer();
      var constants = require_const();
      var { findWhiteSpaceStart, cmpStr } = require_utils();
      var sequence = require_sequence();
      var noop2 = function() {
      };
      var TYPE = constants.TYPE;
      var NAME = constants.NAME;
      var WHITESPACE = TYPE.WhiteSpace;
      var COMMENT = TYPE.Comment;
      var IDENT = TYPE.Ident;
      var FUNCTION = TYPE.Function;
      var URL2 = TYPE.Url;
      var HASH = TYPE.Hash;
      var PERCENTAGE = TYPE.Percentage;
      var NUMBER = TYPE.Number;
      var NUMBERSIGN = 35;
      var NULL = 0;
      function createParseContext(name) {
        return function() {
          return this[name]();
        };
      }
      function processConfig(config) {
        var parserConfig = {
          context: {},
          scope: {},
          atrule: {},
          pseudo: {}
        };
        if (config.parseContext) {
          for (var name in config.parseContext) {
            switch (typeof config.parseContext[name]) {
              case "function":
                parserConfig.context[name] = config.parseContext[name];
                break;
              case "string":
                parserConfig.context[name] = createParseContext(config.parseContext[name]);
                break;
            }
          }
        }
        if (config.scope) {
          for (var name in config.scope) {
            parserConfig.scope[name] = config.scope[name];
          }
        }
        if (config.atrule) {
          for (var name in config.atrule) {
            var atrule = config.atrule[name];
            if (atrule.parse) {
              parserConfig.atrule[name] = atrule.parse;
            }
          }
        }
        if (config.pseudo) {
          for (var name in config.pseudo) {
            var pseudo = config.pseudo[name];
            if (pseudo.parse) {
              parserConfig.pseudo[name] = pseudo.parse;
            }
          }
        }
        if (config.node) {
          for (var name in config.node) {
            parserConfig[name] = config.node[name].parse;
          }
        }
        return parserConfig;
      }
      module.exports = function createParser(config) {
        var parser = {
          scanner: new TokenStream(),
          locationMap: new OffsetToLocation(),
          filename: "<unknown>",
          needPositions: false,
          onParseError: noop2,
          onParseErrorThrow: false,
          parseAtrulePrelude: true,
          parseRulePrelude: true,
          parseValue: true,
          parseCustomProperty: false,
          readSequence: sequence,
          createList: function() {
            return new List();
          },
          createSingleNodeList: function(node) {
            return new List().appendData(node);
          },
          getFirstListNode: function(list) {
            return list && list.first();
          },
          getLastListNode: function(list) {
            return list.last();
          },
          parseWithFallback: function(consumer, fallback) {
            var startToken = this.scanner.tokenIndex;
            try {
              return consumer.call(this);
            } catch (e) {
              if (this.onParseErrorThrow) {
                throw e;
              }
              var fallbackNode = fallback.call(this, startToken);
              this.onParseErrorThrow = true;
              this.onParseError(e, fallbackNode);
              this.onParseErrorThrow = false;
              return fallbackNode;
            }
          },
          lookupNonWSType: function(offset) {
            do {
              var type = this.scanner.lookupType(offset++);
              if (type !== WHITESPACE) {
                return type;
              }
            } while (type !== NULL);
            return NULL;
          },
          eat: function(tokenType) {
            if (this.scanner.tokenType !== tokenType) {
              var offset = this.scanner.tokenStart;
              var message = NAME[tokenType] + " is expected";
              switch (tokenType) {
                case IDENT:
                  if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL2) {
                    offset = this.scanner.tokenEnd - 1;
                    message = "Identifier is expected but function found";
                  } else {
                    message = "Identifier is expected";
                  }
                  break;
                case HASH:
                  if (this.scanner.isDelim(NUMBERSIGN)) {
                    this.scanner.next();
                    offset++;
                    message = "Name is expected";
                  }
                  break;
                case PERCENTAGE:
                  if (this.scanner.tokenType === NUMBER) {
                    offset = this.scanner.tokenEnd;
                    message = "Percent sign is expected";
                  }
                  break;
                default:
                  if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
                    offset = offset + 1;
                  }
              }
              this.error(message, offset);
            }
            this.scanner.next();
          },
          consume: function(tokenType) {
            var value = this.scanner.getTokenValue();
            this.eat(tokenType);
            return value;
          },
          consumeFunctionName: function() {
            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);
            this.eat(FUNCTION);
            return name;
          },
          getLocation: function(start, end) {
            if (this.needPositions) {
              return this.locationMap.getLocationRange(
                start,
                end,
                this.filename
              );
            }
            return null;
          },
          getLocationFromList: function(list) {
            if (this.needPositions) {
              var head = this.getFirstListNode(list);
              var tail = this.getLastListNode(list);
              return this.locationMap.getLocationRange(
                head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
                tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
                this.filename
              );
            }
            return null;
          },
          error: function(message, offset) {
            var location = typeof offset !== "undefined" && offset < this.scanner.source.length ? this.locationMap.getLocation(offset) : this.scanner.eof ? this.locationMap.getLocation(findWhiteSpaceStart(this.scanner.source, this.scanner.source.length - 1)) : this.locationMap.getLocation(this.scanner.tokenStart);
            throw new SyntaxError2(
              message || "Unexpected input",
              this.scanner.source,
              location.offset,
              location.line,
              location.column
            );
          }
        };
        config = processConfig(config || {});
        for (var key in config) {
          parser[key] = config[key];
        }
        return function(source, options) {
          options = options || {};
          var context = options.context || "default";
          var onComment = options.onComment;
          var ast;
          tokenize(source, parser.scanner);
          parser.locationMap.setSource(
            source,
            options.offset,
            options.line,
            options.column
          );
          parser.filename = options.filename || "<unknown>";
          parser.needPositions = Boolean(options.positions);
          parser.onParseError = typeof options.onParseError === "function" ? options.onParseError : noop2;
          parser.onParseErrorThrow = false;
          parser.parseAtrulePrelude = "parseAtrulePrelude" in options ? Boolean(options.parseAtrulePrelude) : true;
          parser.parseRulePrelude = "parseRulePrelude" in options ? Boolean(options.parseRulePrelude) : true;
          parser.parseValue = "parseValue" in options ? Boolean(options.parseValue) : true;
          parser.parseCustomProperty = "parseCustomProperty" in options ? Boolean(options.parseCustomProperty) : false;
          if (!parser.context.hasOwnProperty(context)) {
            throw new Error("Unknown context `" + context + "`");
          }
          if (typeof onComment === "function") {
            parser.scanner.forEachToken((type, start, end) => {
              if (type === COMMENT) {
                const loc = parser.getLocation(start, end);
                const value = cmpStr(source, end - 2, end, "*/") ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);
                onComment(value, loc);
              }
            });
          }
          ast = parser.context[context].call(parser, options);
          if (!parser.scanner.eof) {
            parser.error();
          }
          return ast;
        };
      };
    }
  });

  // node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64.js
  var require_base64 = __commonJS({
    "node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64.js"(exports) {
      var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
      exports.encode = function(number) {
        if (0 <= number && number < intToCharMap.length) {
          return intToCharMap[number];
        }
        throw new TypeError("Must be between 0 and 63: " + number);
      };
      exports.decode = function(charCode) {
        var bigA = 65;
        var bigZ = 90;
        var littleA = 97;
        var littleZ = 122;
        var zero = 48;
        var nine = 57;
        var plus = 43;
        var slash = 47;
        var littleOffset = 26;
        var numberOffset = 52;
        if (bigA <= charCode && charCode <= bigZ) {
          return charCode - bigA;
        }
        if (littleA <= charCode && charCode <= littleZ) {
          return charCode - littleA + littleOffset;
        }
        if (zero <= charCode && charCode <= nine) {
          return charCode - zero + numberOffset;
        }
        if (charCode == plus) {
          return 62;
        }
        if (charCode == slash) {
          return 63;
        }
        return -1;
      };
    }
  });

  // node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64-vlq.js
  var require_base64_vlq = __commonJS({
    "node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64-vlq.js"(exports) {
      var base64 = require_base64();
      var VLQ_BASE_SHIFT = 5;
      var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
      var VLQ_BASE_MASK = VLQ_BASE - 1;
      var VLQ_CONTINUATION_BIT = VLQ_BASE;
      function toVLQSigned(aValue) {
        return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
      }
      function fromVLQSigned(aValue) {
        var isNegative = (aValue & 1) === 1;
        var shifted = aValue >> 1;
        return isNegative ? -shifted : shifted;
      }
      exports.encode = function base64VLQ_encode(aValue) {
        var encoded = "";
        var digit;
        var vlq = toVLQSigned(aValue);
        do {
          digit = vlq & VLQ_BASE_MASK;
          vlq >>>= VLQ_BASE_SHIFT;
          if (vlq > 0) {
            digit |= VLQ_CONTINUATION_BIT;
          }
          encoded += base64.encode(digit);
        } while (vlq > 0);
        return encoded;
      };
      exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
        var strLen = aStr.length;
        var result = 0;
        var shift = 0;
        var continuation, digit;
        do {
          if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
          }
          digit = base64.decode(aStr.charCodeAt(aIndex++));
          if (digit === -1) {
            throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
          }
          continuation = !!(digit & VLQ_CONTINUATION_BIT);
          digit &= VLQ_BASE_MASK;
          result = result + (digit << shift);
          shift += VLQ_BASE_SHIFT;
        } while (continuation);
        aOutParam.value = fromVLQSigned(result);
        aOutParam.rest = aIndex;
      };
    }
  });

  // node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/util.js
  var require_util = __commonJS({
    "node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/util.js"(exports) {
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
          return aArgs[aName];
        } else if (arguments.length === 3) {
          return aDefaultValue;
        } else {
          throw new Error('"' + aName + '" is a required argument.');
        }
      }
      exports.getArg = getArg;
      var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
      var dataUrlRegexp = /^data:.+\,.+$/;
      function urlParse(aUrl) {
        var match = aUrl.match(urlRegexp);
        if (!match) {
          return null;
        }
        return {
          scheme: match[1],
          auth: match[2],
          host: match[3],
          port: match[4],
          path: match[5]
        };
      }
      exports.urlParse = urlParse;
      function urlGenerate(aParsedUrl) {
        var url = "";
        if (aParsedUrl.scheme) {
          url += aParsedUrl.scheme + ":";
        }
        url += "//";
        if (aParsedUrl.auth) {
          url += aParsedUrl.auth + "@";
        }
        if (aParsedUrl.host) {
          url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
          url += ":" + aParsedUrl.port;
        }
        if (aParsedUrl.path) {
          url += aParsedUrl.path;
        }
        return url;
      }
      exports.urlGenerate = urlGenerate;
      function normalize(aPath) {
        var path = aPath;
        var url = urlParse(aPath);
        if (url) {
          if (!url.path) {
            return aPath;
          }
          path = url.path;
        }
        var isAbsolute = exports.isAbsolute(path);
        var parts = path.split(/\/+/);
        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
          part = parts[i];
          if (part === ".") {
            parts.splice(i, 1);
          } else if (part === "..") {
            up++;
          } else if (up > 0) {
            if (part === "") {
              parts.splice(i + 1, up);
              up = 0;
            } else {
              parts.splice(i, 2);
              up--;
            }
          }
        }
        path = parts.join("/");
        if (path === "") {
          path = isAbsolute ? "/" : ".";
        }
        if (url) {
          url.path = path;
          return urlGenerate(url);
        }
        return path;
      }
      exports.normalize = normalize;
      function join(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        if (aPath === "") {
          aPath = ".";
        }
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
          aRoot = aRootUrl.path || "/";
        }
        if (aPathUrl && !aPathUrl.scheme) {
          if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
          }
          return urlGenerate(aPathUrl);
        }
        if (aPathUrl || aPath.match(dataUrlRegexp)) {
          return aPath;
        }
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
          aRootUrl.host = aPath;
          return urlGenerate(aRootUrl);
        }
        var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
        if (aRootUrl) {
          aRootUrl.path = joined;
          return urlGenerate(aRootUrl);
        }
        return joined;
      }
      exports.join = join;
      exports.isAbsolute = function(aPath) {
        return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
      };
      function relative(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        aRoot = aRoot.replace(/\/$/, "");
        var level = 0;
        while (aPath.indexOf(aRoot + "/") !== 0) {
          var index = aRoot.lastIndexOf("/");
          if (index < 0) {
            return aPath;
          }
          aRoot = aRoot.slice(0, index);
          if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
            return aPath;
          }
          ++level;
        }
        return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
      }
      exports.relative = relative;
      var supportsNullProto = function() {
        var obj = /* @__PURE__ */ Object.create(null);
        return !("__proto__" in obj);
      }();
      function identity(s) {
        return s;
      }
      function toSetString(aStr) {
        if (isProtoString(aStr)) {
          return "$" + aStr;
        }
        return aStr;
      }
      exports.toSetString = supportsNullProto ? identity : toSetString;
      function fromSetString(aStr) {
        if (isProtoString(aStr)) {
          return aStr.slice(1);
        }
        return aStr;
      }
      exports.fromSetString = supportsNullProto ? identity : fromSetString;
      function isProtoString(s) {
        if (!s) {
          return false;
        }
        var length = s.length;
        if (length < 9) {
          return false;
        }
        if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
          return false;
        }
        for (var i = length - 10; i >= 0; i--) {
          if (s.charCodeAt(i) !== 36) {
            return false;
          }
        }
        return true;
      }
      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
        var cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0 || onlyCompareOriginal) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByOriginalPositions = compareByOriginalPositions;
      function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0 || onlyCompareGenerated) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
      function strcmp(aStr1, aStr2) {
        if (aStr1 === aStr2) {
          return 0;
        }
        if (aStr1 === null) {
          return 1;
        }
        if (aStr2 === null) {
          return -1;
        }
        if (aStr1 > aStr2) {
          return 1;
        }
        return -1;
      }
      function compareByGeneratedPositionsInflated(mappingA, mappingB) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
      function parseSourceMapInput(str) {
        return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
      }
      exports.parseSourceMapInput = parseSourceMapInput;
      function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
        sourceURL = sourceURL || "";
        if (sourceRoot) {
          if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
            sourceRoot += "/";
          }
          sourceURL = sourceRoot + sourceURL;
        }
        if (sourceMapURL) {
          var parsed = urlParse(sourceMapURL);
          if (!parsed) {
            throw new Error("sourceMapURL could not be parsed");
          }
          if (parsed.path) {
            var index = parsed.path.lastIndexOf("/");
            if (index >= 0) {
              parsed.path = parsed.path.substring(0, index + 1);
            }
          }
          sourceURL = join(urlGenerate(parsed), sourceURL);
        }
        return normalize(sourceURL);
      }
      exports.computeSourceURL = computeSourceURL;
    }
  });

  // node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/array-set.js
  var require_array_set = __commonJS({
    "node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/array-set.js"(exports) {
      var util2 = require_util();
      var has = Object.prototype.hasOwnProperty;
      var hasNativeMap = typeof Map !== "undefined";
      function ArraySet() {
        this._array = [];
        this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
      }
      ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
        var set = new ArraySet();
        for (var i = 0, len = aArray.length; i < len; i++) {
          set.add(aArray[i], aAllowDuplicates);
        }
        return set;
      };
      ArraySet.prototype.size = function ArraySet_size() {
        return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
      };
      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
        var sStr = hasNativeMap ? aStr : util2.toSetString(aStr);
        var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
        var idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          if (hasNativeMap) {
            this._set.set(aStr, idx);
          } else {
            this._set[sStr] = idx;
          }
        }
      };
      ArraySet.prototype.has = function ArraySet_has(aStr) {
        if (hasNativeMap) {
          return this._set.has(aStr);
        } else {
          var sStr = util2.toSetString(aStr);
          return has.call(this._set, sStr);
        }
      };
      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
        if (hasNativeMap) {
          var idx = this._set.get(aStr);
          if (idx >= 0) {
            return idx;
          }
        } else {
          var sStr = util2.toSetString(aStr);
          if (has.call(this._set, sStr)) {
            return this._set[sStr];
          }
        }
        throw new Error('"' + aStr + '" is not in the set.');
      };
      ArraySet.prototype.at = function ArraySet_at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error("No element indexed by " + aIdx);
      };
      ArraySet.prototype.toArray = function ArraySet_toArray() {
        return this._array.slice();
      };
      exports.ArraySet = ArraySet;
    }
  });

  // node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/mapping-list.js
  var require_mapping_list = __commonJS({
    "node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/mapping-list.js"(exports) {
      var util2 = require_util();
      function generatedPositionAfter(mappingA, mappingB) {
        var lineA = mappingA.generatedLine;
        var lineB = mappingB.generatedLine;
        var columnA = mappingA.generatedColumn;
        var columnB = mappingB.generatedColumn;
        return lineB > lineA || lineB == lineA && columnB >= columnA || util2.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
      }
      function MappingList() {
        this._array = [];
        this._sorted = true;
        this._last = { generatedLine: -1, generatedColumn: 0 };
      }
      MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
        this._array.forEach(aCallback, aThisArg);
      };
      MappingList.prototype.add = function MappingList_add(aMapping) {
        if (generatedPositionAfter(this._last, aMapping)) {
          this._last = aMapping;
          this._array.push(aMapping);
        } else {
          this._sorted = false;
          this._array.push(aMapping);
        }
      };
      MappingList.prototype.toArray = function MappingList_toArray() {
        if (!this._sorted) {
          this._array.sort(util2.compareByGeneratedPositionsInflated);
          this._sorted = true;
        }
        return this._array;
      };
      exports.MappingList = MappingList;
    }
  });

  // node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-generator.js
  var require_source_map_generator = __commonJS({
    "node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-generator.js"(exports) {
      var base64VLQ = require_base64_vlq();
      var util2 = require_util();
      var ArraySet = require_array_set().ArraySet;
      var MappingList = require_mapping_list().MappingList;
      function SourceMapGenerator(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util2.getArg(aArgs, "file", null);
        this._sourceRoot = util2.getArg(aArgs, "sourceRoot", null);
        this._skipValidation = util2.getArg(aArgs, "skipValidation", false);
        this._sources = new ArraySet();
        this._names = new ArraySet();
        this._mappings = new MappingList();
        this._sourcesContents = null;
      }
      SourceMapGenerator.prototype._version = 3;
      SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
        var sourceRoot = aSourceMapConsumer.sourceRoot;
        var generator = new SourceMapGenerator({
          file: aSourceMapConsumer.file,
          sourceRoot
        });
        aSourceMapConsumer.eachMapping(function(mapping) {
          var newMapping = {
            generated: {
              line: mapping.generatedLine,
              column: mapping.generatedColumn
            }
          };
          if (mapping.source != null) {
            newMapping.source = mapping.source;
            if (sourceRoot != null) {
              newMapping.source = util2.relative(sourceRoot, newMapping.source);
            }
            newMapping.original = {
              line: mapping.originalLine,
              column: mapping.originalColumn
            };
            if (mapping.name != null) {
              newMapping.name = mapping.name;
            }
          }
          generator.addMapping(newMapping);
        });
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          var sourceRelative = sourceFile;
          if (sourceRoot !== null) {
            sourceRelative = util2.relative(sourceRoot, sourceFile);
          }
          if (!generator._sources.has(sourceRelative)) {
            generator._sources.add(sourceRelative);
          }
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            generator.setSourceContent(sourceFile, content);
          }
        });
        return generator;
      };
      SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
        var generated = util2.getArg(aArgs, "generated");
        var original = util2.getArg(aArgs, "original", null);
        var source = util2.getArg(aArgs, "source", null);
        var name = util2.getArg(aArgs, "name", null);
        if (!this._skipValidation) {
          this._validateMapping(generated, original, source, name);
        }
        if (source != null) {
          source = String(source);
          if (!this._sources.has(source)) {
            this._sources.add(source);
          }
        }
        if (name != null) {
          name = String(name);
          if (!this._names.has(name)) {
            this._names.add(name);
          }
        }
        this._mappings.add({
          generatedLine: generated.line,
          generatedColumn: generated.column,
          originalLine: original != null && original.line,
          originalColumn: original != null && original.column,
          source,
          name
        });
      };
      SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
        var source = aSourceFile;
        if (this._sourceRoot != null) {
          source = util2.relative(this._sourceRoot, source);
        }
        if (aSourceContent != null) {
          if (!this._sourcesContents) {
            this._sourcesContents = /* @__PURE__ */ Object.create(null);
          }
          this._sourcesContents[util2.toSetString(source)] = aSourceContent;
        } else if (this._sourcesContents) {
          delete this._sourcesContents[util2.toSetString(source)];
          if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
          }
        }
      };
      SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
        var sourceFile = aSourceFile;
        if (aSourceFile == null) {
          if (aSourceMapConsumer.file == null) {
            throw new Error(
              `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
            );
          }
          sourceFile = aSourceMapConsumer.file;
        }
        var sourceRoot = this._sourceRoot;
        if (sourceRoot != null) {
          sourceFile = util2.relative(sourceRoot, sourceFile);
        }
        var newSources = new ArraySet();
        var newNames = new ArraySet();
        this._mappings.unsortedForEach(function(mapping) {
          if (mapping.source === sourceFile && mapping.originalLine != null) {
            var original = aSourceMapConsumer.originalPositionFor({
              line: mapping.originalLine,
              column: mapping.originalColumn
            });
            if (original.source != null) {
              mapping.source = original.source;
              if (aSourceMapPath != null) {
                mapping.source = util2.join(aSourceMapPath, mapping.source);
              }
              if (sourceRoot != null) {
                mapping.source = util2.relative(sourceRoot, mapping.source);
              }
              mapping.originalLine = original.line;
              mapping.originalColumn = original.column;
              if (original.name != null) {
                mapping.name = original.name;
              }
            }
          }
          var source = mapping.source;
          if (source != null && !newSources.has(source)) {
            newSources.add(source);
          }
          var name = mapping.name;
          if (name != null && !newNames.has(name)) {
            newNames.add(name);
          }
        }, this);
        this._sources = newSources;
        this._names = newNames;
        aSourceMapConsumer.sources.forEach(function(sourceFile2) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
          if (content != null) {
            if (aSourceMapPath != null) {
              sourceFile2 = util2.join(aSourceMapPath, sourceFile2);
            }
            if (sourceRoot != null) {
              sourceFile2 = util2.relative(sourceRoot, sourceFile2);
            }
            this.setSourceContent(sourceFile2, content);
          }
        }, this);
      };
      SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
        if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
          throw new Error(
            "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
          );
        }
        if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
          return;
        } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
          return;
        } else {
          throw new Error("Invalid mapping: " + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
          }));
        }
      };
      SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
        var previousGeneratedColumn = 0;
        var previousGeneratedLine = 1;
        var previousOriginalColumn = 0;
        var previousOriginalLine = 0;
        var previousName = 0;
        var previousSource = 0;
        var result = "";
        var next;
        var mapping;
        var nameIdx;
        var sourceIdx;
        var mappings = this._mappings.toArray();
        for (var i = 0, len = mappings.length; i < len; i++) {
          mapping = mappings[i];
          next = "";
          if (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while (mapping.generatedLine !== previousGeneratedLine) {
              next += ";";
              previousGeneratedLine++;
            }
          } else {
            if (i > 0) {
              if (!util2.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
                continue;
              }
              next += ",";
            }
          }
          next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
          previousGeneratedColumn = mapping.generatedColumn;
          if (mapping.source != null) {
            sourceIdx = this._sources.indexOf(mapping.source);
            next += base64VLQ.encode(sourceIdx - previousSource);
            previousSource = sourceIdx;
            next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
            previousOriginalLine = mapping.originalLine - 1;
            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;
            if (mapping.name != null) {
              nameIdx = this._names.indexOf(mapping.name);
              next += base64VLQ.encode(nameIdx - previousName);
              previousName = nameIdx;
            }
          }
          result += next;
        }
        return result;
      };
      SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
        return aSources.map(function(source) {
          if (!this._sourcesContents) {
            return null;
          }
          if (aSourceRoot != null) {
            source = util2.relative(aSourceRoot, source);
          }
          var key = util2.toSetString(source);
          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
        }, this);
      };
      SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
        var map = {
          version: this._version,
          sources: this._sources.toArray(),
          names: this._names.toArray(),
          mappings: this._serializeMappings()
        };
        if (this._file != null) {
          map.file = this._file;
        }
        if (this._sourceRoot != null) {
          map.sourceRoot = this._sourceRoot;
        }
        if (this._sourcesContents) {
          map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
        }
        return map;
      };
      SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
        return JSON.stringify(this.toJSON());
      };
      exports.SourceMapGenerator = SourceMapGenerator;
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/generator/sourceMap.js
  var require_sourceMap = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/generator/sourceMap.js"(exports, module) {
      var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
      var trackNodes = {
        Atrule: true,
        Selector: true,
        Declaration: true
      };
      module.exports = function generateSourceMap(handlers) {
        var map = new SourceMapGenerator();
        var line = 1;
        var column = 0;
        var generated = {
          line: 1,
          column: 0
        };
        var original = {
          line: 0,
          // should be zero to add first mapping
          column: 0
        };
        var sourceMappingActive = false;
        var activatedGenerated = {
          line: 1,
          column: 0
        };
        var activatedMapping = {
          generated: activatedGenerated
        };
        var handlersNode = handlers.node;
        handlers.node = function(node) {
          if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
            var nodeLine = node.loc.start.line;
            var nodeColumn = node.loc.start.column - 1;
            if (original.line !== nodeLine || original.column !== nodeColumn) {
              original.line = nodeLine;
              original.column = nodeColumn;
              generated.line = line;
              generated.column = column;
              if (sourceMappingActive) {
                sourceMappingActive = false;
                if (generated.line !== activatedGenerated.line || generated.column !== activatedGenerated.column) {
                  map.addMapping(activatedMapping);
                }
              }
              sourceMappingActive = true;
              map.addMapping({
                source: node.loc.source,
                original,
                generated
              });
            }
          }
          handlersNode.call(this, node);
          if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
            activatedGenerated.line = line;
            activatedGenerated.column = column;
          }
        };
        var handlersChunk = handlers.chunk;
        handlers.chunk = function(chunk) {
          for (var i = 0; i < chunk.length; i++) {
            if (chunk.charCodeAt(i) === 10) {
              line++;
              column = 0;
            } else {
              column++;
            }
          }
          handlersChunk(chunk);
        };
        var handlersResult = handlers.result;
        handlers.result = function() {
          if (sourceMappingActive) {
            map.addMapping(activatedMapping);
          }
          return {
            css: handlersResult(),
            map
          };
        };
        return handlers;
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/generator/create.js
  var require_create2 = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/generator/create.js"(exports, module) {
      var sourceMap = require_sourceMap();
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      function processChildren(node, delimeter) {
        var list = node.children;
        var prev = null;
        if (typeof delimeter !== "function") {
          list.forEach(this.node, this);
        } else {
          list.forEach(function(node2) {
            if (prev !== null) {
              delimeter.call(this, prev);
            }
            this.node(node2);
            prev = node2;
          }, this);
        }
      }
      module.exports = function createGenerator(config) {
        function processNode(node) {
          if (hasOwnProperty2.call(types2, node.type)) {
            types2[node.type].call(this, node);
          } else {
            throw new Error("Unknown node type: " + node.type);
          }
        }
        var types2 = {};
        if (config.node) {
          for (var name in config.node) {
            types2[name] = config.node[name].generate;
          }
        }
        return function(node, options) {
          var buffer2 = "";
          var handlers = {
            children: processChildren,
            node: processNode,
            chunk: function(chunk) {
              buffer2 += chunk;
            },
            result: function() {
              return buffer2;
            }
          };
          if (options) {
            if (typeof options.decorator === "function") {
              handlers = options.decorator(handlers);
            }
            if (options.sourceMap) {
              handlers = sourceMap(handlers);
            }
          }
          handlers.node(node);
          return handlers.result();
        };
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/convertor/create.js
  var require_create3 = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/convertor/create.js"(exports, module) {
      var List = require_List();
      module.exports = function createConvertors(walk2) {
        return {
          fromPlainObject: function(ast) {
            walk2(ast, {
              enter: function(node) {
                if (node.children && node.children instanceof List === false) {
                  node.children = new List().fromArray(node.children);
                }
              }
            });
            return ast;
          },
          toPlainObject: function(ast) {
            walk2(ast, {
              leave: function(node) {
                if (node.children && node.children instanceof List) {
                  node.children = node.children.toArray();
                }
              }
            });
            return ast;
          }
        };
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/walker/create.js
  var require_create4 = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/walker/create.js"(exports, module) {
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var noop2 = function() {
      };
      function ensureFunction(value) {
        return typeof value === "function" ? value : noop2;
      }
      function invokeForType(fn, type) {
        return function(node, item, list) {
          if (node.type === type) {
            fn.call(this, node, item, list);
          }
        };
      }
      function getWalkersFromStructure(name, nodeType) {
        var structure = nodeType.structure;
        var walkers = [];
        for (var key in structure) {
          if (hasOwnProperty2.call(structure, key) === false) {
            continue;
          }
          var fieldTypes = structure[key];
          var walker = {
            name: key,
            type: false,
            nullable: false
          };
          if (!Array.isArray(structure[key])) {
            fieldTypes = [structure[key]];
          }
          for (var i = 0; i < fieldTypes.length; i++) {
            var fieldType = fieldTypes[i];
            if (fieldType === null) {
              walker.nullable = true;
            } else if (typeof fieldType === "string") {
              walker.type = "node";
            } else if (Array.isArray(fieldType)) {
              walker.type = "list";
            }
          }
          if (walker.type) {
            walkers.push(walker);
          }
        }
        if (walkers.length) {
          return {
            context: nodeType.walkContext,
            fields: walkers
          };
        }
        return null;
      }
      function getTypesFromConfig(config) {
        var types2 = {};
        for (var name in config.node) {
          if (hasOwnProperty2.call(config.node, name)) {
            var nodeType = config.node[name];
            if (!nodeType.structure) {
              throw new Error("Missed `structure` field in `" + name + "` node type definition");
            }
            types2[name] = getWalkersFromStructure(name, nodeType);
          }
        }
        return types2;
      }
      function createTypeIterator(config, reverse) {
        var fields = config.fields.slice();
        var contextName = config.context;
        var useContext = typeof contextName === "string";
        if (reverse) {
          fields.reverse();
        }
        return function(node, context, walk2, walkReducer) {
          var prevContextValue;
          if (useContext) {
            prevContextValue = context[contextName];
            context[contextName] = node;
          }
          for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            var ref = node[field.name];
            if (!field.nullable || ref) {
              if (field.type === "list") {
                var breakWalk = reverse ? ref.reduceRight(walkReducer, false) : ref.reduce(walkReducer, false);
                if (breakWalk) {
                  return true;
                }
              } else if (walk2(ref)) {
                return true;
              }
            }
          }
          if (useContext) {
            context[contextName] = prevContextValue;
          }
        };
      }
      function createFastTraveralMap(iterators) {
        return {
          Atrule: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block
          },
          Rule: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block
          },
          Declaration: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block,
            DeclarationList: iterators.DeclarationList
          }
        };
      }
      module.exports = function createWalker(config) {
        var types2 = getTypesFromConfig(config);
        var iteratorsNatural = {};
        var iteratorsReverse = {};
        var breakWalk = Symbol("break-walk");
        var skipNode = Symbol("skip-node");
        for (var name in types2) {
          if (hasOwnProperty2.call(types2, name) && types2[name] !== null) {
            iteratorsNatural[name] = createTypeIterator(types2[name], false);
            iteratorsReverse[name] = createTypeIterator(types2[name], true);
          }
        }
        var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
        var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);
        var walk2 = function(root, options) {
          function walkNode(node, item, list) {
            var enterRet = enter.call(context, node, item, list);
            if (enterRet === breakWalk) {
              debugger;
              return true;
            }
            if (enterRet === skipNode) {
              return false;
            }
            if (iterators.hasOwnProperty(node.type)) {
              if (iterators[node.type](node, context, walkNode, walkReducer)) {
                return true;
              }
            }
            if (leave.call(context, node, item, list) === breakWalk) {
              return true;
            }
            return false;
          }
          var walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);
          var enter = noop2;
          var leave = noop2;
          var iterators = iteratorsNatural;
          var context = {
            break: breakWalk,
            skip: skipNode,
            root,
            stylesheet: null,
            atrule: null,
            atrulePrelude: null,
            rule: null,
            selector: null,
            block: null,
            declaration: null,
            function: null
          };
          if (typeof options === "function") {
            enter = options;
          } else if (options) {
            enter = ensureFunction(options.enter);
            leave = ensureFunction(options.leave);
            if (options.reverse) {
              iterators = iteratorsReverse;
            }
            if (options.visit) {
              if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
                iterators = options.reverse ? fastTraversalIteratorsReverse[options.visit] : fastTraversalIteratorsNatural[options.visit];
              } else if (!types2.hasOwnProperty(options.visit)) {
                throw new Error("Bad value `" + options.visit + "` for `visit` option (should be: " + Object.keys(types2).join(", ") + ")");
              }
              enter = invokeForType(enter, options.visit);
              leave = invokeForType(leave, options.visit);
            }
          }
          if (enter === noop2 && leave === noop2) {
            throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
          }
          walkNode(root);
        };
        walk2.break = breakWalk;
        walk2.skip = skipNode;
        walk2.find = function(ast, fn) {
          var found = null;
          walk2(ast, function(node, item, list) {
            if (fn.call(this, node, item, list)) {
              found = node;
              return breakWalk;
            }
          });
          return found;
        };
        walk2.findLast = function(ast, fn) {
          var found = null;
          walk2(ast, {
            reverse: true,
            enter: function(node, item, list) {
              if (fn.call(this, node, item, list)) {
                found = node;
                return breakWalk;
              }
            }
          });
          return found;
        };
        walk2.findAll = function(ast, fn) {
          var found = [];
          walk2(ast, function(node, item, list) {
            if (fn.call(this, node, item, list)) {
              found.push(node);
            }
          });
          return found;
        };
        return walk2;
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/utils/clone.js
  var require_clone = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/utils/clone.js"(exports, module) {
      var List = require_List();
      module.exports = function clone(node) {
        var result = {};
        for (var key in node) {
          var value = node[key];
          if (value) {
            if (Array.isArray(value) || value instanceof List) {
              value = value.map(clone);
            } else if (value.constructor === Object) {
              value = clone(value);
            }
          }
          result[key] = value;
        }
        return result;
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/config/mix.js
  var require_mix = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/config/mix.js"(exports, module) {
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var shape = {
        generic: true,
        types: appendOrAssign,
        atrules: {
          prelude: appendOrAssignOrNull,
          descriptors: appendOrAssignOrNull
        },
        properties: appendOrAssign,
        parseContext: assign,
        scope: deepAssign,
        atrule: ["parse"],
        pseudo: ["parse"],
        node: ["name", "structure", "parse", "generate", "walkContext"]
      };
      function isObject(value) {
        return value && value.constructor === Object;
      }
      function copy(value) {
        return isObject(value) ? Object.assign({}, value) : value;
      }
      function assign(dest, src2) {
        return Object.assign(dest, src2);
      }
      function deepAssign(dest, src2) {
        for (const key in src2) {
          if (hasOwnProperty2.call(src2, key)) {
            if (isObject(dest[key])) {
              deepAssign(dest[key], copy(src2[key]));
            } else {
              dest[key] = copy(src2[key]);
            }
          }
        }
        return dest;
      }
      function append(a, b) {
        if (typeof b === "string" && /^\s*\|/.test(b)) {
          return typeof a === "string" ? a + b : b.replace(/^\s*\|\s*/, "");
        }
        return b || null;
      }
      function appendOrAssign(a, b) {
        if (typeof b === "string") {
          return append(a, b);
        }
        const result = Object.assign({}, a);
        for (let key in b) {
          if (hasOwnProperty2.call(b, key)) {
            result[key] = append(hasOwnProperty2.call(a, key) ? a[key] : void 0, b[key]);
          }
        }
        return result;
      }
      function appendOrAssignOrNull(a, b) {
        const result = appendOrAssign(a, b);
        return !isObject(result) || Object.keys(result).length ? result : null;
      }
      function mix(dest, src2, shape2) {
        for (const key in shape2) {
          if (hasOwnProperty2.call(shape2, key) === false) {
            continue;
          }
          if (shape2[key] === true) {
            if (key in src2) {
              if (hasOwnProperty2.call(src2, key)) {
                dest[key] = copy(src2[key]);
              }
            }
          } else if (shape2[key]) {
            if (typeof shape2[key] === "function") {
              const fn = shape2[key];
              dest[key] = fn({}, dest[key]);
              dest[key] = fn(dest[key] || {}, src2[key]);
            } else if (isObject(shape2[key])) {
              const result = {};
              for (let name in dest[key]) {
                result[name] = mix({}, dest[key][name], shape2[key]);
              }
              for (let name in src2[key]) {
                result[name] = mix(result[name] || {}, src2[key][name], shape2[key]);
              }
              dest[key] = result;
            } else if (Array.isArray(shape2[key])) {
              const res = {};
              const innerShape = shape2[key].reduce(function(s, k) {
                s[k] = true;
                return s;
              }, {});
              for (const [name, value] of Object.entries(dest[key] || {})) {
                res[name] = {};
                if (value) {
                  mix(res[name], value, innerShape);
                }
              }
              for (const name in src2[key]) {
                if (hasOwnProperty2.call(src2[key], name)) {
                  if (!res[name]) {
                    res[name] = {};
                  }
                  if (src2[key] && src2[key][name]) {
                    mix(res[name], src2[key][name], innerShape);
                  }
                }
              }
              dest[key] = res;
            }
          }
        }
        return dest;
      }
      module.exports = (dest, src2) => mix(dest, src2, shape);
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/create.js
  var require_create5 = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/create.js"(exports) {
      var List = require_List();
      var SyntaxError2 = require_SyntaxError();
      var TokenStream = require_TokenStream();
      var Lexer = require_Lexer();
      var definitionSyntax = require_definition_syntax();
      var tokenize = require_tokenizer();
      var createParser = require_create();
      var createGenerator = require_create2();
      var createConvertor = require_create3();
      var createWalker = require_create4();
      var clone = require_clone();
      var names = require_names();
      var mix = require_mix();
      function createSyntax(config) {
        var parse = createParser(config);
        var walk2 = createWalker(config);
        var generate = createGenerator(config);
        var convert = createConvertor(walk2);
        var syntax = {
          List,
          SyntaxError: SyntaxError2,
          TokenStream,
          Lexer,
          vendorPrefix: names.vendorPrefix,
          keyword: names.keyword,
          property: names.property,
          isCustomProperty: names.isCustomProperty,
          definitionSyntax,
          lexer: null,
          createLexer: function(config2) {
            return new Lexer(config2, syntax, syntax.lexer.structure);
          },
          tokenize,
          parse,
          walk: walk2,
          generate,
          find: walk2.find,
          findLast: walk2.findLast,
          findAll: walk2.findAll,
          clone,
          fromPlainObject: convert.fromPlainObject,
          toPlainObject: convert.toPlainObject,
          createSyntax: function(config2) {
            return createSyntax(mix({}, config2));
          },
          fork: function(extension) {
            var base = mix({}, config);
            return createSyntax(
              typeof extension === "function" ? extension(base, Object.assign) : mix(base, extension)
            );
          }
        };
        syntax.lexer = new Lexer({
          generic: true,
          types: config.types,
          atrules: config.atrules,
          properties: config.properties,
          node: config.node
        }, syntax);
        return syntax;
      }
      exports.create = function(config) {
        return createSyntax(mix({}, config));
      };
    }
  });

  // node_modules/.pnpm/mdn-data@2.0.14/node_modules/mdn-data/css/at-rules.json
  var require_at_rules = __commonJS({
    "node_modules/.pnpm/mdn-data@2.0.14/node_modules/mdn-data/css/at-rules.json"(exports, module) {
      module.exports = {
        "@charset": {
          syntax: '@charset "<charset>";',
          groups: [
            "CSS Charsets"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
        },
        "@counter-style": {
          syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
          interfaces: [
            "CSSCounterStyleRule"
          ],
          groups: [
            "CSS Counter Styles"
          ],
          descriptors: {
            "additive-symbols": {
              syntax: "[ <integer> && <symbol> ]#",
              media: "all",
              initial: "n/a (required)",
              percentages: "no",
              computed: "asSpecified",
              order: "orderOfAppearance",
              status: "standard"
            },
            fallback: {
              syntax: "<counter-style-name>",
              media: "all",
              initial: "decimal",
              percentages: "no",
              computed: "asSpecified",
              order: "uniqueOrder",
              status: "standard"
            },
            negative: {
              syntax: "<symbol> <symbol>?",
              media: "all",
              initial: '"-" hyphen-minus',
              percentages: "no",
              computed: "asSpecified",
              order: "orderOfAppearance",
              status: "standard"
            },
            pad: {
              syntax: "<integer> && <symbol>",
              media: "all",
              initial: '0 ""',
              percentages: "no",
              computed: "asSpecified",
              order: "uniqueOrder",
              status: "standard"
            },
            prefix: {
              syntax: "<symbol>",
              media: "all",
              initial: '""',
              percentages: "no",
              computed: "asSpecified",
              order: "uniqueOrder",
              status: "standard"
            },
            range: {
              syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
              media: "all",
              initial: "auto",
              percentages: "no",
              computed: "asSpecified",
              order: "orderOfAppearance",
              status: "standard"
            },
            "speak-as": {
              syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
              media: "all",
              initial: "auto",
              percentages: "no",
              computed: "asSpecified",
              order: "uniqueOrder",
              status: "standard"
            },
            suffix: {
              syntax: "<symbol>",
              media: "all",
              initial: '". "',
              percentages: "no",
              computed: "asSpecified",
              order: "uniqueOrder",
              status: "standard"
            },
            symbols: {
              syntax: "<symbol>+",
              media: "all",
              initial: "n/a (required)",
              percentages: "no",
              computed: "asSpecified",
              order: "orderOfAppearance",
              status: "standard"
            },
            system: {
              syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
              media: "all",
              initial: "symbolic",
              percentages: "no",
              computed: "asSpecified",
              order: "uniqueOrder",
              status: "standard"
            }
          },
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
        },
        "@document": {
          syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
          interfaces: [
            "CSSGroupingRule",
            "CSSConditionRule"
          ],
          groups: [
            "CSS Conditional Rules"
          ],
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
        },
        "@font-face": {
          syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
          interfaces: [
            "CSSFontFaceRule"
          ],
          groups: [
            "CSS Fonts"
          ],
          descriptors: {
            "font-display": {
              syntax: "[ auto | block | swap | fallback | optional ]",
              media: "visual",
              percentages: "no",
              initial: "auto",
              computed: "asSpecified",
              order: "uniqueOrder",
              status: "experimental"
            },
            "font-family": {
              syntax: "<family-name>",
              media: "all",
              initial: "n/a (required)",
              percentages: "no",
              computed: "asSpecified",
              order: "uniqueOrder",
              status: "standard"
            },
            "font-feature-settings": {
              syntax: "normal | <feature-tag-value>#",
              media: "all",
              initial: "normal",
              percentages: "no",
              computed: "asSpecified",
              order: "orderOfAppearance",
              status: "standard"
            },
            "font-variation-settings": {
              syntax: "normal | [ <string> <number> ]#",
              media: "all",
              initial: "normal",
              percentages: "no",
              computed: "asSpecified",
              order: "orderOfAppearance",
              status: "standard"
            },
            "font-stretch": {
              syntax: "<font-stretch-absolute>{1,2}",
              media: "all",
              initial: "normal",
              percentages: "no",
              computed: "asSpecified",
              order: "uniqueOrder",
              status: "standard"
            },
            "font-style": {
              syntax: "normal | italic | oblique <angle>{0,2}",
              media: "all",
              initial: "normal",
              percentages: "no",
              computed: "asSpecified",
              order: "uniqueOrder",
              status: "standard"
            },
            "font-weight": {
              syntax: "<font-weight-absolute>{1,2}",
              media: "all",
              initial: "normal",
              percentages: "no",
              computed: "asSpecified",
              order: "uniqueOrder",
              status: "standard"
            },
            "font-variant": {
              syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
              media: "all",
              initial: "normal",
              percentages: "no",
              computed: "asSpecified",
              order: "orderOfAppearance",
              status: "standard"
            },
            src: {
              syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
              media: "all",
              initial: "n/a (required)",
              percentages: "no",
              computed: "asSpecified",
              order: "orderOfAppearance",
              status: "standard"
            },
            "unicode-range": {
              syntax: "<unicode-range>#",
              media: "all",
              initial: "U+0-10FFFF",
              percentages: "no",
              computed: "asSpecified",
              order: "orderOfAppearance",
              status: "standard"
            }
          },
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
        },
        "@font-feature-values": {
          syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
          interfaces: [
            "CSSFontFeatureValuesRule"
          ],
          groups: [
            "CSS Fonts"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
        },
        "@import": {
          syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
          groups: [
            "Media Queries"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
        },
        "@keyframes": {
          syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
          interfaces: [
            "CSSKeyframeRule",
            "CSSKeyframesRule"
          ],
          groups: [
            "CSS Animations"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
        },
        "@media": {
          syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
          interfaces: [
            "CSSGroupingRule",
            "CSSConditionRule",
            "CSSMediaRule",
            "CSSCustomMediaRule"
          ],
          groups: [
            "CSS Conditional Rules",
            "Media Queries"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
        },
        "@namespace": {
          syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
          groups: [
            "CSS Namespaces"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
        },
        "@page": {
          syntax: "@page <page-selector-list> {\n  <page-body>\n}",
          interfaces: [
            "CSSPageRule"
          ],
          groups: [
            "CSS Pages"
          ],
          descriptors: {
            bleed: {
              syntax: "auto | <length>",
              media: [
                "visual",
                "paged"
              ],
              initial: "auto",
              percentages: "no",
              computed: "asSpecified",
              order: "uniqueOrder",
              status: "standard"
            },
            marks: {
              syntax: "none | [ crop || cross ]",
              media: [
                "visual",
                "paged"
              ],
              initial: "none",
              percentages: "no",
              computed: "asSpecified",
              order: "orderOfAppearance",
              status: "standard"
            },
            size: {
              syntax: "<length>{1,2} | auto | [ <page-size> || [ portrait | landscape ] ]",
              media: [
                "visual",
                "paged"
              ],
              initial: "auto",
              percentages: "no",
              computed: "asSpecifiedRelativeToAbsoluteLengths",
              order: "orderOfAppearance",
              status: "standard"
            }
          },
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
        },
        "@property": {
          syntax: "@property <custom-property-name> {\n  <declaration-list>\n}",
          interfaces: [
            "CSS",
            "CSSPropertyRule"
          ],
          groups: [
            "CSS Houdini"
          ],
          descriptors: {
            syntax: {
              syntax: "<string>",
              media: "all",
              percentages: "no",
              initial: "n/a (required)",
              computed: "asSpecified",
              order: "uniqueOrder",
              status: "experimental"
            },
            inherits: {
              syntax: "true | false",
              media: "all",
              percentages: "no",
              initial: "auto",
              computed: "asSpecified",
              order: "uniqueOrder",
              status: "experimental"
            },
            "initial-value": {
              syntax: "<string>",
              media: "all",
              initial: "n/a (required)",
              percentages: "no",
              computed: "asSpecified",
              order: "uniqueOrder",
              status: "experimental"
            }
          },
          status: "experimental",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@property"
        },
        "@supports": {
          syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
          interfaces: [
            "CSSGroupingRule",
            "CSSConditionRule",
            "CSSSupportsRule"
          ],
          groups: [
            "CSS Conditional Rules"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
        },
        "@viewport": {
          syntax: "@viewport {\n  <group-rule-body>\n}",
          interfaces: [
            "CSSViewportRule"
          ],
          groups: [
            "CSS Device Adaptation"
          ],
          descriptors: {
            height: {
              syntax: "<viewport-length>{1,2}",
              media: [
                "visual",
                "continuous"
              ],
              initial: [
                "min-height",
                "max-height"
              ],
              percentages: [
                "min-height",
                "max-height"
              ],
              computed: [
                "min-height",
                "max-height"
              ],
              order: "orderOfAppearance",
              status: "standard"
            },
            "max-height": {
              syntax: "<viewport-length>",
              media: [
                "visual",
                "continuous"
              ],
              initial: "auto",
              percentages: "referToHeightOfInitialViewport",
              computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
              order: "uniqueOrder",
              status: "standard"
            },
            "max-width": {
              syntax: "<viewport-length>",
              media: [
                "visual",
                "continuous"
              ],
              initial: "auto",
              percentages: "referToWidthOfInitialViewport",
              computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
              order: "uniqueOrder",
              status: "standard"
            },
            "max-zoom": {
              syntax: "auto | <number> | <percentage>",
              media: [
                "visual",
                "continuous"
              ],
              initial: "auto",
              percentages: "the zoom factor itself",
              computed: "autoNonNegativeOrPercentage",
              order: "uniqueOrder",
              status: "standard"
            },
            "min-height": {
              syntax: "<viewport-length>",
              media: [
                "visual",
                "continuous"
              ],
              initial: "auto",
              percentages: "referToHeightOfInitialViewport",
              computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
              order: "uniqueOrder",
              status: "standard"
            },
            "min-width": {
              syntax: "<viewport-length>",
              media: [
                "visual",
                "continuous"
              ],
              initial: "auto",
              percentages: "referToWidthOfInitialViewport",
              computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
              order: "uniqueOrder",
              status: "standard"
            },
            "min-zoom": {
              syntax: "auto | <number> | <percentage>",
              media: [
                "visual",
                "continuous"
              ],
              initial: "auto",
              percentages: "the zoom factor itself",
              computed: "autoNonNegativeOrPercentage",
              order: "uniqueOrder",
              status: "standard"
            },
            orientation: {
              syntax: "auto | portrait | landscape",
              media: [
                "visual",
                "continuous"
              ],
              initial: "auto",
              percentages: "referToSizeOfBoundingBox",
              computed: "asSpecified",
              order: "uniqueOrder",
              status: "standard"
            },
            "user-zoom": {
              syntax: "zoom | fixed",
              media: [
                "visual",
                "continuous"
              ],
              initial: "zoom",
              percentages: "referToSizeOfBoundingBox",
              computed: "asSpecified",
              order: "uniqueOrder",
              status: "standard"
            },
            "viewport-fit": {
              syntax: "auto | contain | cover",
              media: [
                "visual",
                "continuous"
              ],
              initial: "auto",
              percentages: "no",
              computed: "asSpecified",
              order: "uniqueOrder",
              status: "standard"
            },
            width: {
              syntax: "<viewport-length>{1,2}",
              media: [
                "visual",
                "continuous"
              ],
              initial: [
                "min-width",
                "max-width"
              ],
              percentages: [
                "min-width",
                "max-width"
              ],
              computed: [
                "min-width",
                "max-width"
              ],
              order: "orderOfAppearance",
              status: "standard"
            },
            zoom: {
              syntax: "auto | <number> | <percentage>",
              media: [
                "visual",
                "continuous"
              ],
              initial: "auto",
              percentages: "the zoom factor itself",
              computed: "autoNonNegativeOrPercentage",
              order: "uniqueOrder",
              status: "standard"
            }
          },
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
        }
      };
    }
  });

  // node_modules/.pnpm/mdn-data@2.0.14/node_modules/mdn-data/css/properties.json
  var require_properties = __commonJS({
    "node_modules/.pnpm/mdn-data@2.0.14/node_modules/mdn-data/css/properties.json"(exports, module) {
      module.exports = {
        "--*": {
          syntax: "<declaration-value>",
          media: "all",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Variables"
          ],
          initial: "seeProse",
          appliesto: "allElements",
          computed: "asSpecifiedWithVarsSubstituted",
          order: "perGrammar",
          status: "experimental",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
        },
        "-ms-accelerator": {
          syntax: "false | true",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "false",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
        },
        "-ms-block-progression": {
          syntax: "tb | rl | bt | lr",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "tb",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
        },
        "-ms-content-zoom-chaining": {
          syntax: "none | chained",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "none",
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
        },
        "-ms-content-zooming": {
          syntax: "none | zoom",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "zoomForTheTopLevelNoneForTheRest",
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
        },
        "-ms-content-zoom-limit": {
          syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: [
            "-ms-content-zoom-limit-max",
            "-ms-content-zoom-limit-min"
          ],
          groups: [
            "Microsoft Extensions"
          ],
          initial: [
            "-ms-content-zoom-limit-max",
            "-ms-content-zoom-limit-min"
          ],
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: [
            "-ms-content-zoom-limit-max",
            "-ms-content-zoom-limit-min"
          ],
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
        },
        "-ms-content-zoom-limit-max": {
          syntax: "<percentage>",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "maxZoomFactor",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "400%",
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
        },
        "-ms-content-zoom-limit-min": {
          syntax: "<percentage>",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "minZoomFactor",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "100%",
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
        },
        "-ms-content-zoom-snap": {
          syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: [
            "-ms-content-zoom-snap-type",
            "-ms-content-zoom-snap-points"
          ],
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: [
            "-ms-content-zoom-snap-type",
            "-ms-content-zoom-snap-points"
          ],
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
        },
        "-ms-content-zoom-snap-points": {
          syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "snapInterval(0%, 100%)",
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
        },
        "-ms-content-zoom-snap-type": {
          syntax: "none | proximity | mandatory",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "none",
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
        },
        "-ms-filter": {
          syntax: "<string>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: '""',
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
        },
        "-ms-flow-from": {
          syntax: "[ none | <custom-ident> ]#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "none",
          appliesto: "nonReplacedElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
        },
        "-ms-flow-into": {
          syntax: "[ none | <custom-ident> ]#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "none",
          appliesto: "iframeElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
        },
        "-ms-grid-columns": {
          syntax: "none | <track-list> | <auto-track-list>",
          media: "visual",
          inherited: false,
          animationType: "simpleListOfLpcDifferenceLpc",
          percentages: "referToDimensionOfContentArea",
          groups: [
            "CSS Grid Layout"
          ],
          initial: "none",
          appliesto: "gridContainers",
          computed: "asSpecifiedRelativeToAbsoluteLengths",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-columns"
        },
        "-ms-grid-rows": {
          syntax: "none | <track-list> | <auto-track-list>",
          media: "visual",
          inherited: false,
          animationType: "simpleListOfLpcDifferenceLpc",
          percentages: "referToDimensionOfContentArea",
          groups: [
            "CSS Grid Layout"
          ],
          initial: "none",
          appliesto: "gridContainers",
          computed: "asSpecifiedRelativeToAbsoluteLengths",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-rows"
        },
        "-ms-high-contrast-adjust": {
          syntax: "auto | none",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "auto",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
        },
        "-ms-hyphenate-limit-chars": {
          syntax: "auto | <integer>{1,3}",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "auto",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
        },
        "-ms-hyphenate-limit-lines": {
          syntax: "no-limit | <integer>",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "no-limit",
          appliesto: "blockContainerElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
        },
        "-ms-hyphenate-limit-zone": {
          syntax: "<percentage> | <length>",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "referToLineBoxWidth",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "0",
          appliesto: "blockContainerElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
        },
        "-ms-ime-align": {
          syntax: "auto | after",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "auto",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
        },
        "-ms-overflow-style": {
          syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
          media: "interactive",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "auto",
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
        },
        "-ms-scrollbar-3dlight-color": {
          syntax: "<color>",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "dependsOnUserAgent",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
        },
        "-ms-scrollbar-arrow-color": {
          syntax: "<color>",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "ButtonText",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
        },
        "-ms-scrollbar-base-color": {
          syntax: "<color>",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "dependsOnUserAgent",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
        },
        "-ms-scrollbar-darkshadow-color": {
          syntax: "<color>",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "ThreeDDarkShadow",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
        },
        "-ms-scrollbar-face-color": {
          syntax: "<color>",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "ThreeDFace",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
        },
        "-ms-scrollbar-highlight-color": {
          syntax: "<color>",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "ThreeDHighlight",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
        },
        "-ms-scrollbar-shadow-color": {
          syntax: "<color>",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "ThreeDDarkShadow",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
        },
        "-ms-scrollbar-track-color": {
          syntax: "<color>",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "Scrollbar",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
        },
        "-ms-scroll-chaining": {
          syntax: "chained | none",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "chained",
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
        },
        "-ms-scroll-limit": {
          syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: [
            "-ms-scroll-limit-x-min",
            "-ms-scroll-limit-y-min",
            "-ms-scroll-limit-x-max",
            "-ms-scroll-limit-y-max"
          ],
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: [
            "-ms-scroll-limit-x-min",
            "-ms-scroll-limit-y-min",
            "-ms-scroll-limit-x-max",
            "-ms-scroll-limit-y-max"
          ],
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
        },
        "-ms-scroll-limit-x-max": {
          syntax: "auto | <length>",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "auto",
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
        },
        "-ms-scroll-limit-x-min": {
          syntax: "<length>",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "0",
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
        },
        "-ms-scroll-limit-y-max": {
          syntax: "auto | <length>",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "auto",
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
        },
        "-ms-scroll-limit-y-min": {
          syntax: "<length>",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "0",
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
        },
        "-ms-scroll-rails": {
          syntax: "none | railed",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "railed",
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
        },
        "-ms-scroll-snap-points-x": {
          syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "snapInterval(0px, 100%)",
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
        },
        "-ms-scroll-snap-points-y": {
          syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "snapInterval(0px, 100%)",
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
        },
        "-ms-scroll-snap-type": {
          syntax: "none | proximity | mandatory",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "none",
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
        },
        "-ms-scroll-snap-x": {
          syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: [
            "-ms-scroll-snap-type",
            "-ms-scroll-snap-points-x"
          ],
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: [
            "-ms-scroll-snap-type",
            "-ms-scroll-snap-points-x"
          ],
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
        },
        "-ms-scroll-snap-y": {
          syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: [
            "-ms-scroll-snap-type",
            "-ms-scroll-snap-points-y"
          ],
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: [
            "-ms-scroll-snap-type",
            "-ms-scroll-snap-points-y"
          ],
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
        },
        "-ms-scroll-translation": {
          syntax: "none | vertical-to-horizontal",
          media: "interactive",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
        },
        "-ms-text-autospace": {
          syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
        },
        "-ms-touch-select": {
          syntax: "grippers | none",
          media: "interactive",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "grippers",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
        },
        "-ms-user-select": {
          syntax: "none | element | text",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "text",
          appliesto: "nonReplacedElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
        },
        "-ms-wrap-flow": {
          syntax: "auto | both | start | end | maximum | clear",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "auto",
          appliesto: "blockLevelElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
        },
        "-ms-wrap-margin": {
          syntax: "<length>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "0",
          appliesto: "exclusionElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
        },
        "-ms-wrap-through": {
          syntax: "wrap | none",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "wrap",
          appliesto: "blockLevelElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
        },
        "-moz-appearance": {
          syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions",
            "WebKit Extensions"
          ],
          initial: "noneButOverriddenInUserAgentCSS",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
        },
        "-moz-binding": {
          syntax: "<url> | none",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions"
          ],
          initial: "none",
          appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
        },
        "-moz-border-bottom-colors": {
          syntax: "<color>+ | none",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
        },
        "-moz-border-left-colors": {
          syntax: "<color>+ | none",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
        },
        "-moz-border-right-colors": {
          syntax: "<color>+ | none",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
        },
        "-moz-border-top-colors": {
          syntax: "<color>+ | none",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
        },
        "-moz-context-properties": {
          syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions"
          ],
          initial: "none",
          appliesto: "allElementsThatCanReferenceImages",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
        },
        "-moz-float-edge": {
          syntax: "border-box | content-box | margin-box | padding-box",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions"
          ],
          initial: "content-box",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
        },
        "-moz-force-broken-image-icon": {
          syntax: "<integer [0,1]>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions"
          ],
          initial: "0",
          appliesto: "images",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
        },
        "-moz-image-region": {
          syntax: "<shape> | auto",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions"
          ],
          initial: "auto",
          appliesto: "xulImageElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
        },
        "-moz-orient": {
          syntax: "inline | block | horizontal | vertical",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions"
          ],
          initial: "inline",
          appliesto: "anyElementEffectOnProgressAndMeter",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
        },
        "-moz-outline-radius": {
          syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
          media: "visual",
          inherited: false,
          animationType: [
            "-moz-outline-radius-topleft",
            "-moz-outline-radius-topright",
            "-moz-outline-radius-bottomright",
            "-moz-outline-radius-bottomleft"
          ],
          percentages: [
            "-moz-outline-radius-topleft",
            "-moz-outline-radius-topright",
            "-moz-outline-radius-bottomright",
            "-moz-outline-radius-bottomleft"
          ],
          groups: [
            "Mozilla Extensions"
          ],
          initial: [
            "-moz-outline-radius-topleft",
            "-moz-outline-radius-topright",
            "-moz-outline-radius-bottomright",
            "-moz-outline-radius-bottomleft"
          ],
          appliesto: "allElements",
          computed: [
            "-moz-outline-radius-topleft",
            "-moz-outline-radius-topright",
            "-moz-outline-radius-bottomright",
            "-moz-outline-radius-bottomleft"
          ],
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
        },
        "-moz-outline-radius-bottomleft": {
          syntax: "<outline-radius>",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "referToDimensionOfBorderBox",
          groups: [
            "Mozilla Extensions"
          ],
          initial: "0",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
        },
        "-moz-outline-radius-bottomright": {
          syntax: "<outline-radius>",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "referToDimensionOfBorderBox",
          groups: [
            "Mozilla Extensions"
          ],
          initial: "0",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
        },
        "-moz-outline-radius-topleft": {
          syntax: "<outline-radius>",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "referToDimensionOfBorderBox",
          groups: [
            "Mozilla Extensions"
          ],
          initial: "0",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
        },
        "-moz-outline-radius-topright": {
          syntax: "<outline-radius>",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "referToDimensionOfBorderBox",
          groups: [
            "Mozilla Extensions"
          ],
          initial: "0",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
        },
        "-moz-stack-sizing": {
          syntax: "ignore | stretch-to-fit",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions"
          ],
          initial: "stretch-to-fit",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
        },
        "-moz-text-blink": {
          syntax: "none | blink",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
        },
        "-moz-user-focus": {
          syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
        },
        "-moz-user-input": {
          syntax: "auto | none | enabled | disabled",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions"
          ],
          initial: "auto",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
        },
        "-moz-user-modify": {
          syntax: "read-only | read-write | write-only",
          media: "interactive",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions"
          ],
          initial: "read-only",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
        },
        "-moz-window-dragging": {
          syntax: "drag | no-drag",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions"
          ],
          initial: "drag",
          appliesto: "allElementsCreatingNativeWindows",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
        },
        "-moz-window-shadow": {
          syntax: "default | menu | tooltip | sheet | none",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions"
          ],
          initial: "default",
          appliesto: "allElementsCreatingNativeWindows",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
        },
        "-webkit-appearance": {
          syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "WebKit Extensions"
          ],
          initial: "noneButOverriddenInUserAgentCSS",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
        },
        "-webkit-border-before": {
          syntax: "<'border-width'> || <'border-style'> || <'color'>",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: [
            "-webkit-border-before-width"
          ],
          groups: [
            "WebKit Extensions"
          ],
          initial: [
            "border-width",
            "border-style",
            "color"
          ],
          appliesto: "allElements",
          computed: [
            "border-width",
            "border-style",
            "color"
          ],
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
        },
        "-webkit-border-before-color": {
          syntax: "<'color'>",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "WebKit Extensions"
          ],
          initial: "currentcolor",
          appliesto: "allElements",
          computed: "computedColor",
          order: "uniqueOrder",
          status: "nonstandard"
        },
        "-webkit-border-before-style": {
          syntax: "<'border-style'>",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "WebKit Extensions"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard"
        },
        "-webkit-border-before-width": {
          syntax: "<'border-width'>",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "logicalWidthOfContainingBlock",
          groups: [
            "WebKit Extensions"
          ],
          initial: "medium",
          appliesto: "allElements",
          computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
          order: "uniqueOrder",
          status: "nonstandard"
        },
        "-webkit-box-reflect": {
          syntax: "[ above | below | right | left ]? <length>? <image>?",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "WebKit Extensions"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
        },
        "-webkit-line-clamp": {
          syntax: "none | <integer>",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "no",
          groups: [
            "WebKit Extensions",
            "CSS Overflow"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
        },
        "-webkit-mask": {
          syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "WebKit Extensions"
          ],
          initial: [
            "-webkit-mask-image",
            "-webkit-mask-repeat",
            "-webkit-mask-attachment",
            "-webkit-mask-position",
            "-webkit-mask-origin",
            "-webkit-mask-clip"
          ],
          appliesto: "allElements",
          computed: [
            "-webkit-mask-image",
            "-webkit-mask-repeat",
            "-webkit-mask-attachment",
            "-webkit-mask-position",
            "-webkit-mask-origin",
            "-webkit-mask-clip"
          ],
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
        },
        "-webkit-mask-attachment": {
          syntax: "<attachment>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "WebKit Extensions"
          ],
          initial: "scroll",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
        },
        "-webkit-mask-clip": {
          syntax: "[ <box> | border | padding | content | text ]#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "WebKit Extensions"
          ],
          initial: "border",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
        },
        "-webkit-mask-composite": {
          syntax: "<composite-style>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "WebKit Extensions"
          ],
          initial: "source-over",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
        },
        "-webkit-mask-image": {
          syntax: "<mask-reference>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "WebKit Extensions"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "absoluteURIOrNone",
          order: "orderOfAppearance",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
        },
        "-webkit-mask-origin": {
          syntax: "[ <box> | border | padding | content ]#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "WebKit Extensions"
          ],
          initial: "padding",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
        },
        "-webkit-mask-position": {
          syntax: "<position>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "referToSizeOfElement",
          groups: [
            "WebKit Extensions"
          ],
          initial: "0% 0%",
          appliesto: "allElements",
          computed: "absoluteLengthOrPercentage",
          order: "orderOfAppearance",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
        },
        "-webkit-mask-position-x": {
          syntax: "[ <length-percentage> | left | center | right ]#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "referToSizeOfElement",
          groups: [
            "WebKit Extensions"
          ],
          initial: "0%",
          appliesto: "allElements",
          computed: "absoluteLengthOrPercentage",
          order: "orderOfAppearance",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
        },
        "-webkit-mask-position-y": {
          syntax: "[ <length-percentage> | top | center | bottom ]#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "referToSizeOfElement",
          groups: [
            "WebKit Extensions"
          ],
          initial: "0%",
          appliesto: "allElements",
          computed: "absoluteLengthOrPercentage",
          order: "orderOfAppearance",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
        },
        "-webkit-mask-repeat": {
          syntax: "<repeat-style>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "WebKit Extensions"
          ],
          initial: "repeat",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
        },
        "-webkit-mask-repeat-x": {
          syntax: "repeat | no-repeat | space | round",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "WebKit Extensions"
          ],
          initial: "repeat",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
        },
        "-webkit-mask-repeat-y": {
          syntax: "repeat | no-repeat | space | round",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "WebKit Extensions"
          ],
          initial: "repeat",
          appliesto: "allElements",
          computed: "absoluteLengthOrPercentage",
          order: "orderOfAppearance",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
        },
        "-webkit-mask-size": {
          syntax: "<bg-size>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "relativeToBackgroundPositioningArea",
          groups: [
            "WebKit Extensions"
          ],
          initial: "auto auto",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
        },
        "-webkit-overflow-scrolling": {
          syntax: "auto | touch",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "WebKit Extensions"
          ],
          initial: "auto",
          appliesto: "scrollingBoxes",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
        },
        "-webkit-tap-highlight-color": {
          syntax: "<color>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "WebKit Extensions"
          ],
          initial: "black",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
        },
        "-webkit-text-fill-color": {
          syntax: "<color>",
          media: "visual",
          inherited: true,
          animationType: "color",
          percentages: "no",
          groups: [
            "WebKit Extensions"
          ],
          initial: "currentcolor",
          appliesto: "allElements",
          computed: "computedColor",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
        },
        "-webkit-text-stroke": {
          syntax: "<length> || <color>",
          media: "visual",
          inherited: true,
          animationType: [
            "-webkit-text-stroke-width",
            "-webkit-text-stroke-color"
          ],
          percentages: "no",
          groups: [
            "WebKit Extensions"
          ],
          initial: [
            "-webkit-text-stroke-width",
            "-webkit-text-stroke-color"
          ],
          appliesto: "allElements",
          computed: [
            "-webkit-text-stroke-width",
            "-webkit-text-stroke-color"
          ],
          order: "canonicalOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
        },
        "-webkit-text-stroke-color": {
          syntax: "<color>",
          media: "visual",
          inherited: true,
          animationType: "color",
          percentages: "no",
          groups: [
            "WebKit Extensions"
          ],
          initial: "currentcolor",
          appliesto: "allElements",
          computed: "computedColor",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
        },
        "-webkit-text-stroke-width": {
          syntax: "<length>",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "WebKit Extensions"
          ],
          initial: "0",
          appliesto: "allElements",
          computed: "absoluteLength",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
        },
        "-webkit-touch-callout": {
          syntax: "default | none",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "WebKit Extensions"
          ],
          initial: "default",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
        },
        "-webkit-user-modify": {
          syntax: "read-only | read-write | read-write-plaintext-only",
          media: "interactive",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "WebKit Extensions"
          ],
          initial: "read-only",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard"
        },
        "align-content": {
          syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Box Alignment"
          ],
          initial: "normal",
          appliesto: "multilineFlexContainers",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
        },
        "align-items": {
          syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Box Alignment"
          ],
          initial: "normal",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
        },
        "align-self": {
          syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Box Alignment"
          ],
          initial: "auto",
          appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
          computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
        },
        "align-tracks": {
          syntax: "[ normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position> ]#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Grid Layout"
          ],
          initial: "normal",
          appliesto: "gridContainersWithMasonryLayoutInTheirBlockAxis",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "experimental",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-tracks"
        },
        all: {
          syntax: "initial | inherit | unset | revert",
          media: "noPracticalMedia",
          inherited: false,
          animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
          percentages: "no",
          groups: [
            "CSS Miscellaneous"
          ],
          initial: "noPracticalInitialValue",
          appliesto: "allElements",
          computed: "asSpecifiedAppliesToEachProperty",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
        },
        animation: {
          syntax: "<single-animation>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Animations"
          ],
          initial: [
            "animation-name",
            "animation-duration",
            "animation-timing-function",
            "animation-delay",
            "animation-iteration-count",
            "animation-direction",
            "animation-fill-mode",
            "animation-play-state"
          ],
          appliesto: "allElementsAndPseudos",
          computed: [
            "animation-name",
            "animation-duration",
            "animation-timing-function",
            "animation-delay",
            "animation-direction",
            "animation-iteration-count",
            "animation-fill-mode",
            "animation-play-state"
          ],
          order: "orderOfAppearance",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
        },
        "animation-delay": {
          syntax: "<time>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Animations"
          ],
          initial: "0s",
          appliesto: "allElementsAndPseudos",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
        },
        "animation-direction": {
          syntax: "<single-animation-direction>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Animations"
          ],
          initial: "normal",
          appliesto: "allElementsAndPseudos",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
        },
        "animation-duration": {
          syntax: "<time>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Animations"
          ],
          initial: "0s",
          appliesto: "allElementsAndPseudos",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
        },
        "animation-fill-mode": {
          syntax: "<single-animation-fill-mode>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Animations"
          ],
          initial: "none",
          appliesto: "allElementsAndPseudos",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
        },
        "animation-iteration-count": {
          syntax: "<single-animation-iteration-count>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Animations"
          ],
          initial: "1",
          appliesto: "allElementsAndPseudos",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
        },
        "animation-name": {
          syntax: "[ none | <keyframes-name> ]#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Animations"
          ],
          initial: "none",
          appliesto: "allElementsAndPseudos",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
        },
        "animation-play-state": {
          syntax: "<single-animation-play-state>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Animations"
          ],
          initial: "running",
          appliesto: "allElementsAndPseudos",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
        },
        "animation-timing-function": {
          syntax: "<timing-function>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Animations"
          ],
          initial: "ease",
          appliesto: "allElementsAndPseudos",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
        },
        appearance: {
          syntax: "none | auto | textfield | menulist-button | <compat-auto>",
          media: "all",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Basic User Interface"
          ],
          initial: "auto",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "experimental",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
        },
        "aspect-ratio": {
          syntax: "auto | <ratio>",
          media: "all",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Basic User Interface"
          ],
          initial: "auto",
          appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
          computed: "asSpecified",
          order: "perGrammar",
          status: "experimental",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
        },
        azimuth: {
          syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
          media: "aural",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Speech"
          ],
          initial: "center",
          appliesto: "allElements",
          computed: "normalizedAngle",
          order: "orderOfAppearance",
          status: "obsolete",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
        },
        "backdrop-filter": {
          syntax: "none | <filter-function-list>",
          media: "visual",
          inherited: false,
          animationType: "filterList",
          percentages: "no",
          groups: [
            "Filter Effects"
          ],
          initial: "none",
          appliesto: "allElementsSVGContainerElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
        },
        "backface-visibility": {
          syntax: "visible | hidden",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Transforms"
          ],
          initial: "visible",
          appliesto: "transformableElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
        },
        background: {
          syntax: "[ <bg-layer> , ]* <final-bg-layer>",
          media: "visual",
          inherited: false,
          animationType: [
            "background-color",
            "background-image",
            "background-clip",
            "background-position",
            "background-size",
            "background-repeat",
            "background-attachment"
          ],
          percentages: [
            "background-position",
            "background-size"
          ],
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: [
            "background-image",
            "background-position",
            "background-size",
            "background-repeat",
            "background-origin",
            "background-clip",
            "background-attachment",
            "background-color"
          ],
          appliesto: "allElements",
          computed: [
            "background-image",
            "background-position",
            "background-size",
            "background-repeat",
            "background-origin",
            "background-clip",
            "background-attachment",
            "background-color"
          ],
          order: "orderOfAppearance",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
        },
        "background-attachment": {
          syntax: "<attachment>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "scroll",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
        },
        "background-blend-mode": {
          syntax: "<blend-mode>#",
          media: "none",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Compositing and Blending"
          ],
          initial: "normal",
          appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
        },
        "background-clip": {
          syntax: "<box>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "border-box",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
        },
        "background-color": {
          syntax: "<color>",
          media: "visual",
          inherited: false,
          animationType: "color",
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "transparent",
          appliesto: "allElements",
          computed: "computedColor",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
        },
        "background-image": {
          syntax: "<bg-image>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecifiedURLsAbsolute",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
        },
        "background-origin": {
          syntax: "<box>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "padding-box",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
        },
        "background-position": {
          syntax: "<bg-position>#",
          media: "visual",
          inherited: false,
          animationType: "repeatableListOfSimpleListOfLpc",
          percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "0% 0%",
          appliesto: "allElements",
          computed: "listEachItemTwoKeywordsOriginOffsets",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
        },
        "background-position-x": {
          syntax: "[ center | [ [ left | right | x-start | x-end ]? <length-percentage>? ]! ]#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "left",
          appliesto: "allElements",
          computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
          order: "uniqueOrder",
          status: "experimental",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
        },
        "background-position-y": {
          syntax: "[ center | [ [ top | bottom | y-start | y-end ]? <length-percentage>? ]! ]#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "top",
          appliesto: "allElements",
          computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
          order: "uniqueOrder",
          status: "experimental",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
        },
        "background-repeat": {
          syntax: "<repeat-style>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "repeat",
          appliesto: "allElements",
          computed: "listEachItemHasTwoKeywordsOnePerDimension",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
        },
        "background-size": {
          syntax: "<bg-size>#",
          media: "visual",
          inherited: false,
          animationType: "repeatableListOfSimpleListOfLpc",
          percentages: "relativeToBackgroundPositioningArea",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "auto auto",
          appliesto: "allElements",
          computed: "asSpecifiedRelativeToAbsoluteLengths",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
        },
        "block-overflow": {
          syntax: "clip | ellipsis | <string>",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Overflow"
          ],
          initial: "clip",
          appliesto: "blockContainers",
          computed: "asSpecified",
          order: "perGrammar",
          status: "experimental"
        },
        "block-size": {
          syntax: "<'width'>",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "blockSizeOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "auto",
          appliesto: "sameAsWidthAndHeight",
          computed: "sameAsWidthAndHeight",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
        },
        border: {
          syntax: "<line-width> || <line-style> || <color>",
          media: "visual",
          inherited: false,
          animationType: [
            "border-color",
            "border-style",
            "border-width"
          ],
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: [
            "border-width",
            "border-style",
            "border-color"
          ],
          appliesto: "allElements",
          computed: [
            "border-width",
            "border-style",
            "border-color"
          ],
          order: "orderOfAppearance",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
        },
        "border-block": {
          syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Logical Properties"
          ],
          initial: [
            "border-top-width",
            "border-top-style",
            "border-top-color"
          ],
          appliesto: "allElements",
          computed: [
            "border-top-width",
            "border-top-style",
            "border-top-color"
          ],
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
        },
        "border-block-color": {
          syntax: "<'border-top-color'>{1,2}",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "currentcolor",
          appliesto: "allElements",
          computed: "computedColor",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
        },
        "border-block-style": {
          syntax: "<'border-top-style'>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
        },
        "border-block-width": {
          syntax: "<'border-top-width'>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "logicalWidthOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "medium",
          appliesto: "allElements",
          computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
        },
        "border-block-end": {
          syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
          media: "visual",
          inherited: false,
          animationType: [
            "border-block-end-color",
            "border-block-end-style",
            "border-block-end-width"
          ],
          percentages: "no",
          groups: [
            "CSS Logical Properties"
          ],
          initial: [
            "border-top-width",
            "border-top-style",
            "border-top-color"
          ],
          appliesto: "allElements",
          computed: [
            "border-top-width",
            "border-top-style",
            "border-top-color"
          ],
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
        },
        "border-block-end-color": {
          syntax: "<'border-top-color'>",
          media: "visual",
          inherited: false,
          animationType: "color",
          percentages: "no",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "currentcolor",
          appliesto: "allElements",
          computed: "computedColor",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
        },
        "border-block-end-style": {
          syntax: "<'border-top-style'>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
        },
        "border-block-end-width": {
          syntax: "<'border-top-width'>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "logicalWidthOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "medium",
          appliesto: "allElements",
          computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
        },
        "border-block-start": {
          syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
          media: "visual",
          inherited: false,
          animationType: [
            "border-block-start-color",
            "border-block-start-style",
            "border-block-start-width"
          ],
          percentages: "no",
          groups: [
            "CSS Logical Properties"
          ],
          initial: [
            "border-width",
            "border-style",
            "color"
          ],
          appliesto: "allElements",
          computed: [
            "border-width",
            "border-style",
            "border-block-start-color"
          ],
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
        },
        "border-block-start-color": {
          syntax: "<'border-top-color'>",
          media: "visual",
          inherited: false,
          animationType: "color",
          percentages: "no",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "currentcolor",
          appliesto: "allElements",
          computed: "computedColor",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
        },
        "border-block-start-style": {
          syntax: "<'border-top-style'>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
        },
        "border-block-start-width": {
          syntax: "<'border-top-width'>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "logicalWidthOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "medium",
          appliesto: "allElements",
          computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
        },
        "border-bottom": {
          syntax: "<line-width> || <line-style> || <color>",
          media: "visual",
          inherited: false,
          animationType: [
            "border-bottom-color",
            "border-bottom-style",
            "border-bottom-width"
          ],
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: [
            "border-bottom-width",
            "border-bottom-style",
            "border-bottom-color"
          ],
          appliesto: "allElements",
          computed: [
            "border-bottom-width",
            "border-bottom-style",
            "border-bottom-color"
          ],
          order: "orderOfAppearance",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
        },
        "border-bottom-color": {
          syntax: "<'border-top-color'>",
          media: "visual",
          inherited: false,
          animationType: "color",
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "currentcolor",
          appliesto: "allElements",
          computed: "computedColor",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
        },
        "border-bottom-left-radius": {
          syntax: "<length-percentage>{1,2}",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "referToDimensionOfBorderBox",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "0",
          appliesto: "allElementsUAsNotRequiredWhenCollapse",
          computed: "twoAbsoluteLengthOrPercentages",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
        },
        "border-bottom-right-radius": {
          syntax: "<length-percentage>{1,2}",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "referToDimensionOfBorderBox",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "0",
          appliesto: "allElementsUAsNotRequiredWhenCollapse",
          computed: "twoAbsoluteLengthOrPercentages",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
        },
        "border-bottom-style": {
          syntax: "<line-style>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
        },
        "border-bottom-width": {
          syntax: "<line-width>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "medium",
          appliesto: "allElements",
          computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
        },
        "border-collapse": {
          syntax: "collapse | separate",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Table"
          ],
          initial: "separate",
          appliesto: "tableElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
        },
        "border-color": {
          syntax: "<color>{1,4}",
          media: "visual",
          inherited: false,
          animationType: [
            "border-bottom-color",
            "border-left-color",
            "border-right-color",
            "border-top-color"
          ],
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: [
            "border-top-color",
            "border-right-color",
            "border-bottom-color",
            "border-left-color"
          ],
          appliesto: "allElements",
          computed: [
            "border-bottom-color",
            "border-left-color",
            "border-right-color",
            "border-top-color"
          ],
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
        },
        "border-end-end-radius": {
          syntax: "<length-percentage>{1,2}",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "referToDimensionOfBorderBox",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "0",
          appliesto: "allElementsUAsNotRequiredWhenCollapse",
          computed: "twoAbsoluteLengthOrPercentages",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
        },
        "border-end-start-radius": {
          syntax: "<length-percentage>{1,2}",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "referToDimensionOfBorderBox",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "0",
          appliesto: "allElementsUAsNotRequiredWhenCollapse",
          computed: "twoAbsoluteLengthOrPercentages",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
        },
        "border-image": {
          syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: [
            "border-image-slice",
            "border-image-width"
          ],
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: [
            "border-image-source",
            "border-image-slice",
            "border-image-width",
            "border-image-outset",
            "border-image-repeat"
          ],
          appliesto: "allElementsExceptTableElementsWhenCollapse",
          computed: [
            "border-image-outset",
            "border-image-repeat",
            "border-image-slice",
            "border-image-source",
            "border-image-width"
          ],
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
        },
        "border-image-outset": {
          syntax: "[ <length> | <number> ]{1,4}",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "0",
          appliesto: "allElementsExceptTableElementsWhenCollapse",
          computed: "asSpecifiedRelativeToAbsoluteLengths",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
        },
        "border-image-repeat": {
          syntax: "[ stretch | repeat | round | space ]{1,2}",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "stretch",
          appliesto: "allElementsExceptTableElementsWhenCollapse",
          computed: "asSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
        },
        "border-image-slice": {
          syntax: "<number-percentage>{1,4} && fill?",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "referToSizeOfBorderImage",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "100%",
          appliesto: "allElementsExceptTableElementsWhenCollapse",
          computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
          order: "percentagesOrLengthsFollowedByFill",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
        },
        "border-image-source": {
          syntax: "none | <image>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "none",
          appliesto: "allElementsExceptTableElementsWhenCollapse",
          computed: "noneOrImageWithAbsoluteURI",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
        },
        "border-image-width": {
          syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "referToWidthOrHeightOfBorderImageArea",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "1",
          appliesto: "allElementsExceptTableElementsWhenCollapse",
          computed: "asSpecifiedRelativeToAbsoluteLengths",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
        },
        "border-inline": {
          syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Logical Properties"
          ],
          initial: [
            "border-top-width",
            "border-top-style",
            "border-top-color"
          ],
          appliesto: "allElements",
          computed: [
            "border-top-width",
            "border-top-style",
            "border-top-color"
          ],
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
        },
        "border-inline-end": {
          syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
          media: "visual",
          inherited: false,
          animationType: [
            "border-inline-end-color",
            "border-inline-end-style",
            "border-inline-end-width"
          ],
          percentages: "no",
          groups: [
            "CSS Logical Properties"
          ],
          initial: [
            "border-width",
            "border-style",
            "color"
          ],
          appliesto: "allElements",
          computed: [
            "border-width",
            "border-style",
            "border-inline-end-color"
          ],
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
        },
        "border-inline-color": {
          syntax: "<'border-top-color'>{1,2}",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "currentcolor",
          appliesto: "allElements",
          computed: "computedColor",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
        },
        "border-inline-style": {
          syntax: "<'border-top-style'>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
        },
        "border-inline-width": {
          syntax: "<'border-top-width'>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "logicalWidthOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "medium",
          appliesto: "allElements",
          computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
        },
        "border-inline-end-color": {
          syntax: "<'border-top-color'>",
          media: "visual",
          inherited: false,
          animationType: "color",
          percentages: "no",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "currentcolor",
          appliesto: "allElements",
          computed: "computedColor",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
        },
        "border-inline-end-style": {
          syntax: "<'border-top-style'>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
        },
        "border-inline-end-width": {
          syntax: "<'border-top-width'>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "logicalWidthOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "medium",
          appliesto: "allElements",
          computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
        },
        "border-inline-start": {
          syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
          media: "visual",
          inherited: false,
          animationType: [
            "border-inline-start-color",
            "border-inline-start-style",
            "border-inline-start-width"
          ],
          percentages: "no",
          groups: [
            "CSS Logical Properties"
          ],
          initial: [
            "border-width",
            "border-style",
            "color"
          ],
          appliesto: "allElements",
          computed: [
            "border-width",
            "border-style",
            "border-inline-start-color"
          ],
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
        },
        "border-inline-start-color": {
          syntax: "<'border-top-color'>",
          media: "visual",
          inherited: false,
          animationType: "color",
          percentages: "no",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "currentcolor",
          appliesto: "allElements",
          computed: "computedColor",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
        },
        "border-inline-start-style": {
          syntax: "<'border-top-style'>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
        },
        "border-inline-start-width": {
          syntax: "<'border-top-width'>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "logicalWidthOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "medium",
          appliesto: "allElements",
          computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
        },
        "border-left": {
          syntax: "<line-width> || <line-style> || <color>",
          media: "visual",
          inherited: false,
          animationType: [
            "border-left-color",
            "border-left-style",
            "border-left-width"
          ],
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: [
            "border-left-width",
            "border-left-style",
            "border-left-color"
          ],
          appliesto: "allElements",
          computed: [
            "border-left-width",
            "border-left-style",
            "border-left-color"
          ],
          order: "orderOfAppearance",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
        },
        "border-left-color": {
          syntax: "<color>",
          media: "visual",
          inherited: false,
          animationType: "color",
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "currentcolor",
          appliesto: "allElements",
          computed: "computedColor",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
        },
        "border-left-style": {
          syntax: "<line-style>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
        },
        "border-left-width": {
          syntax: "<line-width>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "medium",
          appliesto: "allElements",
          computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
        },
        "border-radius": {
          syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
          media: "visual",
          inherited: false,
          animationType: [
            "border-top-left-radius",
            "border-top-right-radius",
            "border-bottom-right-radius",
            "border-bottom-left-radius"
          ],
          percentages: "referToDimensionOfBorderBox",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: [
            "border-top-left-radius",
            "border-top-right-radius",
            "border-bottom-right-radius",
            "border-bottom-left-radius"
          ],
          appliesto: "allElementsUAsNotRequiredWhenCollapse",
          computed: [
            "border-bottom-left-radius",
            "border-bottom-right-radius",
            "border-top-left-radius",
            "border-top-right-radius"
          ],
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
        },
        "border-right": {
          syntax: "<line-width> || <line-style> || <color>",
          media: "visual",
          inherited: false,
          animationType: [
            "border-right-color",
            "border-right-style",
            "border-right-width"
          ],
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: [
            "border-right-width",
            "border-right-style",
            "border-right-color"
          ],
          appliesto: "allElements",
          computed: [
            "border-right-width",
            "border-right-style",
            "border-right-color"
          ],
          order: "orderOfAppearance",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
        },
        "border-right-color": {
          syntax: "<color>",
          media: "visual",
          inherited: false,
          animationType: "color",
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "currentcolor",
          appliesto: "allElements",
          computed: "computedColor",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
        },
        "border-right-style": {
          syntax: "<line-style>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
        },
        "border-right-width": {
          syntax: "<line-width>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "medium",
          appliesto: "allElements",
          computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
        },
        "border-spacing": {
          syntax: "<length> <length>?",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Table"
          ],
          initial: "0",
          appliesto: "tableElements",
          computed: "twoAbsoluteLengths",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
        },
        "border-start-end-radius": {
          syntax: "<length-percentage>{1,2}",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "referToDimensionOfBorderBox",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "0",
          appliesto: "allElementsUAsNotRequiredWhenCollapse",
          computed: "twoAbsoluteLengthOrPercentages",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
        },
        "border-start-start-radius": {
          syntax: "<length-percentage>{1,2}",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "referToDimensionOfBorderBox",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "0",
          appliesto: "allElementsUAsNotRequiredWhenCollapse",
          computed: "twoAbsoluteLengthOrPercentages",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
        },
        "border-style": {
          syntax: "<line-style>{1,4}",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: [
            "border-top-style",
            "border-right-style",
            "border-bottom-style",
            "border-left-style"
          ],
          appliesto: "allElements",
          computed: [
            "border-bottom-style",
            "border-left-style",
            "border-right-style",
            "border-top-style"
          ],
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
        },
        "border-top": {
          syntax: "<line-width> || <line-style> || <color>",
          media: "visual",
          inherited: false,
          animationType: [
            "border-top-color",
            "border-top-style",
            "border-top-width"
          ],
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: [
            "border-top-width",
            "border-top-style",
            "border-top-color"
          ],
          appliesto: "allElements",
          computed: [
            "border-top-width",
            "border-top-style",
            "border-top-color"
          ],
          order: "orderOfAppearance",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
        },
        "border-top-color": {
          syntax: "<color>",
          media: "visual",
          inherited: false,
          animationType: "color",
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "currentcolor",
          appliesto: "allElements",
          computed: "computedColor",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
        },
        "border-top-left-radius": {
          syntax: "<length-percentage>{1,2}",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "referToDimensionOfBorderBox",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "0",
          appliesto: "allElementsUAsNotRequiredWhenCollapse",
          computed: "twoAbsoluteLengthOrPercentages",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
        },
        "border-top-right-radius": {
          syntax: "<length-percentage>{1,2}",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "referToDimensionOfBorderBox",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "0",
          appliesto: "allElementsUAsNotRequiredWhenCollapse",
          computed: "twoAbsoluteLengthOrPercentages",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
        },
        "border-top-style": {
          syntax: "<line-style>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
        },
        "border-top-width": {
          syntax: "<line-width>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "medium",
          appliesto: "allElements",
          computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
        },
        "border-width": {
          syntax: "<line-width>{1,4}",
          media: "visual",
          inherited: false,
          animationType: [
            "border-bottom-width",
            "border-left-width",
            "border-right-width",
            "border-top-width"
          ],
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: [
            "border-top-width",
            "border-right-width",
            "border-bottom-width",
            "border-left-width"
          ],
          appliesto: "allElements",
          computed: [
            "border-bottom-width",
            "border-left-width",
            "border-right-width",
            "border-top-width"
          ],
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
        },
        bottom: {
          syntax: "<length> | <percentage> | auto",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "referToContainingBlockHeight",
          groups: [
            "CSS Positioning"
          ],
          initial: "auto",
          appliesto: "positionedElements",
          computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
        },
        "box-align": {
          syntax: "start | center | end | baseline | stretch",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions",
            "WebKit Extensions"
          ],
          initial: "stretch",
          appliesto: "elementsWithDisplayBoxOrInlineBox",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
        },
        "box-decoration-break": {
          syntax: "slice | clone",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Fragmentation"
          ],
          initial: "slice",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
        },
        "box-direction": {
          syntax: "normal | reverse | inherit",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions",
            "WebKit Extensions"
          ],
          initial: "normal",
          appliesto: "elementsWithDisplayBoxOrInlineBox",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
        },
        "box-flex": {
          syntax: "<number>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions",
            "WebKit Extensions"
          ],
          initial: "0",
          appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
        },
        "box-flex-group": {
          syntax: "<integer>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions",
            "WebKit Extensions"
          ],
          initial: "1",
          appliesto: "inFlowChildrenOfBoxElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
        },
        "box-lines": {
          syntax: "single | multiple",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions",
            "WebKit Extensions"
          ],
          initial: "single",
          appliesto: "boxElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
        },
        "box-ordinal-group": {
          syntax: "<integer>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions",
            "WebKit Extensions"
          ],
          initial: "1",
          appliesto: "childrenOfBoxElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
        },
        "box-orient": {
          syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions",
            "WebKit Extensions"
          ],
          initial: "inlineAxisHorizontalInXUL",
          appliesto: "elementsWithDisplayBoxOrInlineBox",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
        },
        "box-pack": {
          syntax: "start | center | end | justify",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions",
            "WebKit Extensions"
          ],
          initial: "start",
          appliesto: "elementsWithDisplayMozBoxMozInlineBox",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
        },
        "box-shadow": {
          syntax: "none | <shadow>#",
          media: "visual",
          inherited: false,
          animationType: "shadowList",
          percentages: "no",
          groups: [
            "CSS Backgrounds and Borders"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "absoluteLengthsSpecifiedColorAsSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
        },
        "box-sizing": {
          syntax: "content-box | border-box",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Basic User Interface"
          ],
          initial: "content-box",
          appliesto: "allElementsAcceptingWidthOrHeight",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
        },
        "break-after": {
          syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Fragmentation"
          ],
          initial: "auto",
          appliesto: "blockLevelElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
        },
        "break-before": {
          syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Fragmentation"
          ],
          initial: "auto",
          appliesto: "blockLevelElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
        },
        "break-inside": {
          syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Fragmentation"
          ],
          initial: "auto",
          appliesto: "blockLevelElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
        },
        "caption-side": {
          syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Table"
          ],
          initial: "top",
          appliesto: "tableCaptionElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
        },
        "caret-color": {
          syntax: "auto | <color>",
          media: "interactive",
          inherited: true,
          animationType: "color",
          percentages: "no",
          groups: [
            "CSS Basic User Interface"
          ],
          initial: "auto",
          appliesto: "allElements",
          computed: "asAutoOrColor",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
        },
        clear: {
          syntax: "none | left | right | both | inline-start | inline-end",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Positioning"
          ],
          initial: "none",
          appliesto: "blockLevelElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
        },
        clip: {
          syntax: "<shape> | auto",
          media: "visual",
          inherited: false,
          animationType: "rectangle",
          percentages: "no",
          groups: [
            "CSS Masking"
          ],
          initial: "auto",
          appliesto: "absolutelyPositionedElements",
          computed: "autoOrRectangle",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
        },
        "clip-path": {
          syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
          media: "visual",
          inherited: false,
          animationType: "basicShapeOtherwiseNo",
          percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
          groups: [
            "CSS Masking"
          ],
          initial: "none",
          appliesto: "allElementsSVGContainerElements",
          computed: "asSpecifiedURLsAbsolute",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
        },
        color: {
          syntax: "<color>",
          media: "visual",
          inherited: true,
          animationType: "color",
          percentages: "no",
          groups: [
            "CSS Color"
          ],
          initial: "variesFromBrowserToBrowser",
          appliesto: "allElements",
          computed: "translucentValuesRGBAOtherwiseRGB",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
        },
        "color-adjust": {
          syntax: "economy | exact",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Color"
          ],
          initial: "economy",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
        },
        "column-count": {
          syntax: "<integer> | auto",
          media: "visual",
          inherited: false,
          animationType: "integer",
          percentages: "no",
          groups: [
            "CSS Columns"
          ],
          initial: "auto",
          appliesto: "blockContainersExceptTableWrappers",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
        },
        "column-fill": {
          syntax: "auto | balance | balance-all",
          media: "visualInContinuousMediaNoEffectInOverflowColumns",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Columns"
          ],
          initial: "balance",
          appliesto: "multicolElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
        },
        "column-gap": {
          syntax: "normal | <length-percentage>",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "referToDimensionOfContentArea",
          groups: [
            "CSS Box Alignment"
          ],
          initial: "normal",
          appliesto: "multiColumnElementsFlexContainersGridContainers",
          computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
        },
        "column-rule": {
          syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
          media: "visual",
          inherited: false,
          animationType: [
            "column-rule-color",
            "column-rule-style",
            "column-rule-width"
          ],
          percentages: "no",
          groups: [
            "CSS Columns"
          ],
          initial: [
            "column-rule-width",
            "column-rule-style",
            "column-rule-color"
          ],
          appliesto: "multicolElements",
          computed: [
            "column-rule-color",
            "column-rule-style",
            "column-rule-width"
          ],
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
        },
        "column-rule-color": {
          syntax: "<color>",
          media: "visual",
          inherited: false,
          animationType: "color",
          percentages: "no",
          groups: [
            "CSS Columns"
          ],
          initial: "currentcolor",
          appliesto: "multicolElements",
          computed: "computedColor",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
        },
        "column-rule-style": {
          syntax: "<'border-style'>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Columns"
          ],
          initial: "none",
          appliesto: "multicolElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
        },
        "column-rule-width": {
          syntax: "<'border-width'>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "no",
          groups: [
            "CSS Columns"
          ],
          initial: "medium",
          appliesto: "multicolElements",
          computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
        },
        "column-span": {
          syntax: "none | all",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Columns"
          ],
          initial: "none",
          appliesto: "inFlowBlockLevelElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
        },
        "column-width": {
          syntax: "<length> | auto",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "no",
          groups: [
            "CSS Columns"
          ],
          initial: "auto",
          appliesto: "blockContainersExceptTableWrappers",
          computed: "absoluteLengthZeroOrLarger",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
        },
        columns: {
          syntax: "<'column-width'> || <'column-count'>",
          media: "visual",
          inherited: false,
          animationType: [
            "column-width",
            "column-count"
          ],
          percentages: "no",
          groups: [
            "CSS Columns"
          ],
          initial: [
            "column-width",
            "column-count"
          ],
          appliesto: "blockContainersExceptTableWrappers",
          computed: [
            "column-width",
            "column-count"
          ],
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
        },
        contain: {
          syntax: "none | strict | content | [ size || layout || style || paint ]",
          media: "all",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Containment"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
        },
        content: {
          syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
          media: "all",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Generated Content"
          ],
          initial: "normal",
          appliesto: "beforeAndAfterPseudos",
          computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
        },
        "counter-increment": {
          syntax: "[ <custom-ident> <integer>? ]+ | none",
          media: "all",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Counter Styles"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
        },
        "counter-reset": {
          syntax: "[ <custom-ident> <integer>? ]+ | none",
          media: "all",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Counter Styles"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
        },
        "counter-set": {
          syntax: "[ <custom-ident> <integer>? ]+ | none",
          media: "all",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Counter Styles"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
        },
        cursor: {
          syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
          media: [
            "visual",
            "interactive"
          ],
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Basic User Interface"
          ],
          initial: "auto",
          appliesto: "allElements",
          computed: "asSpecifiedURLsAbsolute",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
        },
        direction: {
          syntax: "ltr | rtl",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Writing Modes"
          ],
          initial: "ltr",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
        },
        display: {
          syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
          media: "all",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Display"
          ],
          initial: "inline",
          appliesto: "allElements",
          computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
        },
        "empty-cells": {
          syntax: "show | hide",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Table"
          ],
          initial: "show",
          appliesto: "tableCellElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
        },
        filter: {
          syntax: "none | <filter-function-list>",
          media: "visual",
          inherited: false,
          animationType: "filterList",
          percentages: "no",
          groups: [
            "Filter Effects"
          ],
          initial: "none",
          appliesto: "allElementsSVGContainerElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
        },
        flex: {
          syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
          media: "visual",
          inherited: false,
          animationType: [
            "flex-grow",
            "flex-shrink",
            "flex-basis"
          ],
          percentages: "no",
          groups: [
            "CSS Flexible Box Layout"
          ],
          initial: [
            "flex-grow",
            "flex-shrink",
            "flex-basis"
          ],
          appliesto: "flexItemsAndInFlowPseudos",
          computed: [
            "flex-grow",
            "flex-shrink",
            "flex-basis"
          ],
          order: "orderOfAppearance",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
        },
        "flex-basis": {
          syntax: "content | <'width'>",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "referToFlexContainersInnerMainSize",
          groups: [
            "CSS Flexible Box Layout"
          ],
          initial: "auto",
          appliesto: "flexItemsAndInFlowPseudos",
          computed: "asSpecifiedRelativeToAbsoluteLengths",
          order: "lengthOrPercentageBeforeKeywordIfBothPresent",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
        },
        "flex-direction": {
          syntax: "row | row-reverse | column | column-reverse",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Flexible Box Layout"
          ],
          initial: "row",
          appliesto: "flexContainers",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
        },
        "flex-flow": {
          syntax: "<'flex-direction'> || <'flex-wrap'>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Flexible Box Layout"
          ],
          initial: [
            "flex-direction",
            "flex-wrap"
          ],
          appliesto: "flexContainers",
          computed: [
            "flex-direction",
            "flex-wrap"
          ],
          order: "orderOfAppearance",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
        },
        "flex-grow": {
          syntax: "<number>",
          media: "visual",
          inherited: false,
          animationType: "number",
          percentages: "no",
          groups: [
            "CSS Flexible Box Layout"
          ],
          initial: "0",
          appliesto: "flexItemsAndInFlowPseudos",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
        },
        "flex-shrink": {
          syntax: "<number>",
          media: "visual",
          inherited: false,
          animationType: "number",
          percentages: "no",
          groups: [
            "CSS Flexible Box Layout"
          ],
          initial: "1",
          appliesto: "flexItemsAndInFlowPseudos",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
        },
        "flex-wrap": {
          syntax: "nowrap | wrap | wrap-reverse",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Flexible Box Layout"
          ],
          initial: "nowrap",
          appliesto: "flexContainers",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
        },
        float: {
          syntax: "left | right | none | inline-start | inline-end",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Positioning"
          ],
          initial: "none",
          appliesto: "allElementsNoEffectIfDisplayNone",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
        },
        font: {
          syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
          media: "visual",
          inherited: true,
          animationType: [
            "font-style",
            "font-variant",
            "font-weight",
            "font-stretch",
            "font-size",
            "line-height",
            "font-family"
          ],
          percentages: [
            "font-size",
            "line-height"
          ],
          groups: [
            "CSS Fonts"
          ],
          initial: [
            "font-style",
            "font-variant",
            "font-weight",
            "font-stretch",
            "font-size",
            "line-height",
            "font-family"
          ],
          appliesto: "allElements",
          computed: [
            "font-style",
            "font-variant",
            "font-weight",
            "font-stretch",
            "font-size",
            "line-height",
            "font-family"
          ],
          order: "orderOfAppearance",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
        },
        "font-family": {
          syntax: "[ <family-name> | <generic-family> ]#",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Fonts"
          ],
          initial: "dependsOnUserAgent",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
        },
        "font-feature-settings": {
          syntax: "normal | <feature-tag-value>#",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Fonts"
          ],
          initial: "normal",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
        },
        "font-kerning": {
          syntax: "auto | normal | none",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Fonts"
          ],
          initial: "auto",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
        },
        "font-language-override": {
          syntax: "normal | <string>",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Fonts"
          ],
          initial: "normal",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
        },
        "font-optical-sizing": {
          syntax: "auto | none",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Fonts"
          ],
          initial: "auto",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "perGrammar",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
        },
        "font-variation-settings": {
          syntax: "normal | [ <string> <number> ]#",
          media: "visual",
          inherited: true,
          animationType: "transform",
          percentages: "no",
          groups: [
            "CSS Fonts"
          ],
          initial: "normal",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "perGrammar",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
        },
        "font-size": {
          syntax: "<absolute-size> | <relative-size> | <length-percentage>",
          media: "visual",
          inherited: true,
          animationType: "length",
          percentages: "referToParentElementsFontSize",
          groups: [
            "CSS Fonts"
          ],
          initial: "medium",
          appliesto: "allElements",
          computed: "asSpecifiedRelativeToAbsoluteLengths",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
        },
        "font-size-adjust": {
          syntax: "none | <number>",
          media: "visual",
          inherited: true,
          animationType: "number",
          percentages: "no",
          groups: [
            "CSS Fonts"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
        },
        "font-smooth": {
          syntax: "auto | never | always | <absolute-size> | <length>",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Fonts"
          ],
          initial: "auto",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-smooth"
        },
        "font-stretch": {
          syntax: "<font-stretch-absolute>",
          media: "visual",
          inherited: true,
          animationType: "fontStretch",
          percentages: "no",
          groups: [
            "CSS Fonts"
          ],
          initial: "normal",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
        },
        "font-style": {
          syntax: "normal | italic | oblique <angle>?",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Fonts"
          ],
          initial: "normal",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
        },
        "font-synthesis": {
          syntax: "none | [ weight || style ]",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Fonts"
          ],
          initial: "weight style",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "orderOfAppearance",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
        },
        "font-variant": {
          syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Fonts"
          ],
          initial: "normal",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
        },
        "font-variant-alternates": {
          syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Fonts"
          ],
          initial: "normal",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "orderOfAppearance",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
        },
        "font-variant-caps": {
          syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Fonts"
          ],
          initial: "normal",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
        },
        "font-variant-east-asian": {
          syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Fonts"
          ],
          initial: "normal",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "orderOfAppearance",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
        },
        "font-variant-ligatures": {
          syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Fonts"
          ],
          initial: "normal",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "orderOfAppearance",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
        },
        "font-variant-numeric": {
          syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Fonts"
          ],
          initial: "normal",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "orderOfAppearance",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
        },
        "font-variant-position": {
          syntax: "normal | sub | super",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Fonts"
          ],
          initial: "normal",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
        },
        "font-weight": {
          syntax: "<font-weight-absolute> | bolder | lighter",
          media: "visual",
          inherited: true,
          animationType: "fontWeight",
          percentages: "no",
          groups: [
            "CSS Fonts"
          ],
          initial: "normal",
          appliesto: "allElements",
          computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
        },
        gap: {
          syntax: "<'row-gap'> <'column-gap'>?",
          media: "visual",
          inherited: false,
          animationType: [
            "row-gap",
            "column-gap"
          ],
          percentages: "no",
          groups: [
            "CSS Box Alignment"
          ],
          initial: [
            "row-gap",
            "column-gap"
          ],
          appliesto: "multiColumnElementsFlexContainersGridContainers",
          computed: [
            "row-gap",
            "column-gap"
          ],
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
        },
        grid: {
          syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: [
            "grid-template-rows",
            "grid-template-columns",
            "grid-auto-rows",
            "grid-auto-columns"
          ],
          groups: [
            "CSS Grid Layout"
          ],
          initial: [
            "grid-template-rows",
            "grid-template-columns",
            "grid-template-areas",
            "grid-auto-rows",
            "grid-auto-columns",
            "grid-auto-flow",
            "grid-column-gap",
            "grid-row-gap",
            "column-gap",
            "row-gap"
          ],
          appliesto: "gridContainers",
          computed: [
            "grid-template-rows",
            "grid-template-columns",
            "grid-template-areas",
            "grid-auto-rows",
            "grid-auto-columns",
            "grid-auto-flow",
            "grid-column-gap",
            "grid-row-gap",
            "column-gap",
            "row-gap"
          ],
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
        },
        "grid-area": {
          syntax: "<grid-line> [ / <grid-line> ]{0,3}",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Grid Layout"
          ],
          initial: [
            "grid-row-start",
            "grid-column-start",
            "grid-row-end",
            "grid-column-end"
          ],
          appliesto: "gridItemsAndBoxesWithinGridContainer",
          computed: [
            "grid-row-start",
            "grid-column-start",
            "grid-row-end",
            "grid-column-end"
          ],
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
        },
        "grid-auto-columns": {
          syntax: "<track-size>+",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "referToDimensionOfContentArea",
          groups: [
            "CSS Grid Layout"
          ],
          initial: "auto",
          appliesto: "gridContainers",
          computed: "percentageAsSpecifiedOrAbsoluteLength",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
        },
        "grid-auto-flow": {
          syntax: "[ row | column ] || dense",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Grid Layout"
          ],
          initial: "row",
          appliesto: "gridContainers",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
        },
        "grid-auto-rows": {
          syntax: "<track-size>+",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "referToDimensionOfContentArea",
          groups: [
            "CSS Grid Layout"
          ],
          initial: "auto",
          appliesto: "gridContainers",
          computed: "percentageAsSpecifiedOrAbsoluteLength",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
        },
        "grid-column": {
          syntax: "<grid-line> [ / <grid-line> ]?",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Grid Layout"
          ],
          initial: [
            "grid-column-start",
            "grid-column-end"
          ],
          appliesto: "gridItemsAndBoxesWithinGridContainer",
          computed: [
            "grid-column-start",
            "grid-column-end"
          ],
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
        },
        "grid-column-end": {
          syntax: "<grid-line>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Grid Layout"
          ],
          initial: "auto",
          appliesto: "gridItemsAndBoxesWithinGridContainer",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
        },
        "grid-column-gap": {
          syntax: "<length-percentage>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "referToDimensionOfContentArea",
          groups: [
            "CSS Grid Layout"
          ],
          initial: "0",
          appliesto: "gridContainers",
          computed: "percentageAsSpecifiedOrAbsoluteLength",
          order: "uniqueOrder",
          status: "obsolete",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
        },
        "grid-column-start": {
          syntax: "<grid-line>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Grid Layout"
          ],
          initial: "auto",
          appliesto: "gridItemsAndBoxesWithinGridContainer",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
        },
        "grid-gap": {
          syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
          media: "visual",
          inherited: false,
          animationType: [
            "grid-row-gap",
            "grid-column-gap"
          ],
          percentages: "no",
          groups: [
            "CSS Grid Layout"
          ],
          initial: [
            "grid-row-gap",
            "grid-column-gap"
          ],
          appliesto: "gridContainers",
          computed: [
            "grid-row-gap",
            "grid-column-gap"
          ],
          order: "uniqueOrder",
          status: "obsolete",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
        },
        "grid-row": {
          syntax: "<grid-line> [ / <grid-line> ]?",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Grid Layout"
          ],
          initial: [
            "grid-row-start",
            "grid-row-end"
          ],
          appliesto: "gridItemsAndBoxesWithinGridContainer",
          computed: [
            "grid-row-start",
            "grid-row-end"
          ],
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
        },
        "grid-row-end": {
          syntax: "<grid-line>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Grid Layout"
          ],
          initial: "auto",
          appliesto: "gridItemsAndBoxesWithinGridContainer",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
        },
        "grid-row-gap": {
          syntax: "<length-percentage>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "referToDimensionOfContentArea",
          groups: [
            "CSS Grid Layout"
          ],
          initial: "0",
          appliesto: "gridContainers",
          computed: "percentageAsSpecifiedOrAbsoluteLength",
          order: "uniqueOrder",
          status: "obsolete",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
        },
        "grid-row-start": {
          syntax: "<grid-line>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Grid Layout"
          ],
          initial: "auto",
          appliesto: "gridItemsAndBoxesWithinGridContainer",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
        },
        "grid-template": {
          syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: [
            "grid-template-columns",
            "grid-template-rows"
          ],
          groups: [
            "CSS Grid Layout"
          ],
          initial: [
            "grid-template-columns",
            "grid-template-rows",
            "grid-template-areas"
          ],
          appliesto: "gridContainers",
          computed: [
            "grid-template-columns",
            "grid-template-rows",
            "grid-template-areas"
          ],
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
        },
        "grid-template-areas": {
          syntax: "none | <string>+",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Grid Layout"
          ],
          initial: "none",
          appliesto: "gridContainers",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
        },
        "grid-template-columns": {
          syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
          media: "visual",
          inherited: false,
          animationType: "simpleListOfLpcDifferenceLpc",
          percentages: "referToDimensionOfContentArea",
          groups: [
            "CSS Grid Layout"
          ],
          initial: "none",
          appliesto: "gridContainers",
          computed: "asSpecifiedRelativeToAbsoluteLengths",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
        },
        "grid-template-rows": {
          syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
          media: "visual",
          inherited: false,
          animationType: "simpleListOfLpcDifferenceLpc",
          percentages: "referToDimensionOfContentArea",
          groups: [
            "CSS Grid Layout"
          ],
          initial: "none",
          appliesto: "gridContainers",
          computed: "asSpecifiedRelativeToAbsoluteLengths",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
        },
        "hanging-punctuation": {
          syntax: "none | [ first || [ force-end | allow-end ] || last ]",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Text"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
        },
        height: {
          syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
          groups: [
            "CSS Box Model"
          ],
          initial: "auto",
          appliesto: "allElementsButNonReplacedAndTableColumns",
          computed: "percentageAutoOrAbsoluteLength",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
        },
        hyphens: {
          syntax: "none | manual | auto",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Text"
          ],
          initial: "manual",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
        },
        "image-orientation": {
          syntax: "from-image | <angle> | [ <angle>? flip ]",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Images"
          ],
          initial: "from-image",
          appliesto: "allElements",
          computed: "angleRoundedToNextQuarter",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
        },
        "image-rendering": {
          syntax: "auto | crisp-edges | pixelated",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Images"
          ],
          initial: "auto",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
        },
        "image-resolution": {
          syntax: "[ from-image || <resolution> ] && snap?",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Images"
          ],
          initial: "1dppx",
          appliesto: "allElements",
          computed: "asSpecifiedWithExceptionOfResolution",
          order: "uniqueOrder",
          status: "experimental"
        },
        "ime-mode": {
          syntax: "auto | normal | active | inactive | disabled",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Basic User Interface"
          ],
          initial: "auto",
          appliesto: "textFields",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "obsolete",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
        },
        "initial-letter": {
          syntax: "normal | [ <number> <integer>? ]",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Inline"
          ],
          initial: "normal",
          appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "experimental",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
        },
        "initial-letter-align": {
          syntax: "[ auto | alphabetic | hanging | ideographic ]",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Inline"
          ],
          initial: "auto",
          appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "experimental",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
        },
        "inline-size": {
          syntax: "<'width'>",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "inlineSizeOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "auto",
          appliesto: "sameAsWidthAndHeight",
          computed: "sameAsWidthAndHeight",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
        },
        inset: {
          syntax: "<'top'>{1,4}",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "logicalHeightOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "auto",
          appliesto: "positionedElements",
          computed: "sameAsBoxOffsets",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
        },
        "inset-block": {
          syntax: "<'top'>{1,2}",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "logicalHeightOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "auto",
          appliesto: "positionedElements",
          computed: "sameAsBoxOffsets",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
        },
        "inset-block-end": {
          syntax: "<'top'>",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "logicalHeightOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "auto",
          appliesto: "positionedElements",
          computed: "sameAsBoxOffsets",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
        },
        "inset-block-start": {
          syntax: "<'top'>",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "logicalHeightOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "auto",
          appliesto: "positionedElements",
          computed: "sameAsBoxOffsets",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
        },
        "inset-inline": {
          syntax: "<'top'>{1,2}",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "logicalWidthOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "auto",
          appliesto: "positionedElements",
          computed: "sameAsBoxOffsets",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
        },
        "inset-inline-end": {
          syntax: "<'top'>",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "logicalWidthOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "auto",
          appliesto: "positionedElements",
          computed: "sameAsBoxOffsets",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
        },
        "inset-inline-start": {
          syntax: "<'top'>",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "logicalWidthOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "auto",
          appliesto: "positionedElements",
          computed: "sameAsBoxOffsets",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
        },
        isolation: {
          syntax: "auto | isolate",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Compositing and Blending"
          ],
          initial: "auto",
          appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
        },
        "justify-content": {
          syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Box Alignment"
          ],
          initial: "normal",
          appliesto: "flexContainers",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
        },
        "justify-items": {
          syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Box Alignment"
          ],
          initial: "legacy",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
        },
        "justify-self": {
          syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Box Alignment"
          ],
          initial: "auto",
          appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
        },
        "justify-tracks": {
          syntax: "[ normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ] ]#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Grid Layout"
          ],
          initial: "normal",
          appliesto: "gridContainersWithMasonryLayoutInTheirInlineAxis",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "experimental",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-tracks"
        },
        left: {
          syntax: "<length> | <percentage> | auto",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "referToWidthOfContainingBlock",
          groups: [
            "CSS Positioning"
          ],
          initial: "auto",
          appliesto: "positionedElements",
          computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
        },
        "letter-spacing": {
          syntax: "normal | <length>",
          media: "visual",
          inherited: true,
          animationType: "length",
          percentages: "no",
          groups: [
            "CSS Text"
          ],
          initial: "normal",
          appliesto: "allElements",
          computed: "optimumValueOfAbsoluteLengthOrNormal",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
        },
        "line-break": {
          syntax: "auto | loose | normal | strict | anywhere",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Text"
          ],
          initial: "auto",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
        },
        "line-clamp": {
          syntax: "none | <integer>",
          media: "visual",
          inherited: false,
          animationType: "integer",
          percentages: "no",
          groups: [
            "CSS Overflow"
          ],
          initial: "none",
          appliesto: "blockContainersExceptMultiColumnContainers",
          computed: "asSpecified",
          order: "perGrammar",
          status: "experimental"
        },
        "line-height": {
          syntax: "normal | <number> | <length> | <percentage>",
          media: "visual",
          inherited: true,
          animationType: "numberOrLength",
          percentages: "referToElementFontSize",
          groups: [
            "CSS Fonts"
          ],
          initial: "normal",
          appliesto: "allElements",
          computed: "absoluteLengthOrAsSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
        },
        "line-height-step": {
          syntax: "<length>",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Fonts"
          ],
          initial: "0",
          appliesto: "blockContainers",
          computed: "absoluteLength",
          order: "perGrammar",
          status: "experimental",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
        },
        "list-style": {
          syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Lists and Counters"
          ],
          initial: [
            "list-style-type",
            "list-style-position",
            "list-style-image"
          ],
          appliesto: "listItems",
          computed: [
            "list-style-image",
            "list-style-position",
            "list-style-type"
          ],
          order: "orderOfAppearance",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
        },
        "list-style-image": {
          syntax: "<url> | none",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Lists and Counters"
          ],
          initial: "none",
          appliesto: "listItems",
          computed: "noneOrImageWithAbsoluteURI",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
        },
        "list-style-position": {
          syntax: "inside | outside",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Lists and Counters"
          ],
          initial: "outside",
          appliesto: "listItems",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
        },
        "list-style-type": {
          syntax: "<counter-style> | <string> | none",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Lists and Counters"
          ],
          initial: "disc",
          appliesto: "listItems",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
        },
        margin: {
          syntax: "[ <length> | <percentage> | auto ]{1,4}",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "referToWidthOfContainingBlock",
          groups: [
            "CSS Box Model"
          ],
          initial: [
            "margin-bottom",
            "margin-left",
            "margin-right",
            "margin-top"
          ],
          appliesto: "allElementsExceptTableDisplayTypes",
          computed: [
            "margin-bottom",
            "margin-left",
            "margin-right",
            "margin-top"
          ],
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
        },
        "margin-block": {
          syntax: "<'margin-left'>{1,2}",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "dependsOnLayoutModel",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "0",
          appliesto: "sameAsMargin",
          computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
        },
        "margin-block-end": {
          syntax: "<'margin-left'>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "dependsOnLayoutModel",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "0",
          appliesto: "sameAsMargin",
          computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
        },
        "margin-block-start": {
          syntax: "<'margin-left'>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "dependsOnLayoutModel",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "0",
          appliesto: "sameAsMargin",
          computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
        },
        "margin-bottom": {
          syntax: "<length> | <percentage> | auto",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "referToWidthOfContainingBlock",
          groups: [
            "CSS Box Model"
          ],
          initial: "0",
          appliesto: "allElementsExceptTableDisplayTypes",
          computed: "percentageAsSpecifiedOrAbsoluteLength",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
        },
        "margin-inline": {
          syntax: "<'margin-left'>{1,2}",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "dependsOnLayoutModel",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "0",
          appliesto: "sameAsMargin",
          computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
        },
        "margin-inline-end": {
          syntax: "<'margin-left'>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "dependsOnLayoutModel",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "0",
          appliesto: "sameAsMargin",
          computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
        },
        "margin-inline-start": {
          syntax: "<'margin-left'>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "dependsOnLayoutModel",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "0",
          appliesto: "sameAsMargin",
          computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
        },
        "margin-left": {
          syntax: "<length> | <percentage> | auto",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "referToWidthOfContainingBlock",
          groups: [
            "CSS Box Model"
          ],
          initial: "0",
          appliesto: "allElementsExceptTableDisplayTypes",
          computed: "percentageAsSpecifiedOrAbsoluteLength",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
        },
        "margin-right": {
          syntax: "<length> | <percentage> | auto",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "referToWidthOfContainingBlock",
          groups: [
            "CSS Box Model"
          ],
          initial: "0",
          appliesto: "allElementsExceptTableDisplayTypes",
          computed: "percentageAsSpecifiedOrAbsoluteLength",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
        },
        "margin-top": {
          syntax: "<length> | <percentage> | auto",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "referToWidthOfContainingBlock",
          groups: [
            "CSS Box Model"
          ],
          initial: "0",
          appliesto: "allElementsExceptTableDisplayTypes",
          computed: "percentageAsSpecifiedOrAbsoluteLength",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
        },
        "margin-trim": {
          syntax: "none | in-flow | all",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Box Model"
          ],
          initial: "none",
          appliesto: "blockContainersAndMultiColumnContainers",
          computed: "asSpecified",
          order: "perGrammar",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line"
          ],
          status: "experimental",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-trim"
        },
        mask: {
          syntax: "<mask-layer>#",
          media: "visual",
          inherited: false,
          animationType: [
            "mask-image",
            "mask-mode",
            "mask-repeat",
            "mask-position",
            "mask-clip",
            "mask-origin",
            "mask-size",
            "mask-composite"
          ],
          percentages: [
            "mask-position"
          ],
          groups: [
            "CSS Masking"
          ],
          initial: [
            "mask-image",
            "mask-mode",
            "mask-repeat",
            "mask-position",
            "mask-clip",
            "mask-origin",
            "mask-size",
            "mask-composite"
          ],
          appliesto: "allElementsSVGContainerElements",
          computed: [
            "mask-image",
            "mask-mode",
            "mask-repeat",
            "mask-position",
            "mask-clip",
            "mask-origin",
            "mask-size",
            "mask-composite"
          ],
          order: "perGrammar",
          stacking: true,
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
        },
        "mask-border": {
          syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
          media: "visual",
          inherited: false,
          animationType: [
            "mask-border-mode",
            "mask-border-outset",
            "mask-border-repeat",
            "mask-border-slice",
            "mask-border-source",
            "mask-border-width"
          ],
          percentages: [
            "mask-border-slice",
            "mask-border-width"
          ],
          groups: [
            "CSS Masking"
          ],
          initial: [
            "mask-border-mode",
            "mask-border-outset",
            "mask-border-repeat",
            "mask-border-slice",
            "mask-border-source",
            "mask-border-width"
          ],
          appliesto: "allElementsSVGContainerElements",
          computed: [
            "mask-border-mode",
            "mask-border-outset",
            "mask-border-repeat",
            "mask-border-slice",
            "mask-border-source",
            "mask-border-width"
          ],
          order: "perGrammar",
          stacking: true,
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
        },
        "mask-border-mode": {
          syntax: "luminance | alpha",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Masking"
          ],
          initial: "alpha",
          appliesto: "allElementsSVGContainerElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
        },
        "mask-border-outset": {
          syntax: "[ <length> | <number> ]{1,4}",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Masking"
          ],
          initial: "0",
          appliesto: "allElementsSVGContainerElements",
          computed: "asSpecifiedRelativeToAbsoluteLengths",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
        },
        "mask-border-repeat": {
          syntax: "[ stretch | repeat | round | space ]{1,2}",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Masking"
          ],
          initial: "stretch",
          appliesto: "allElementsSVGContainerElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
        },
        "mask-border-slice": {
          syntax: "<number-percentage>{1,4} fill?",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "referToSizeOfMaskBorderImage",
          groups: [
            "CSS Masking"
          ],
          initial: "0",
          appliesto: "allElementsSVGContainerElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
        },
        "mask-border-source": {
          syntax: "none | <image>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Masking"
          ],
          initial: "none",
          appliesto: "allElementsSVGContainerElements",
          computed: "asSpecifiedURLsAbsolute",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
        },
        "mask-border-width": {
          syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "relativeToMaskBorderImageArea",
          groups: [
            "CSS Masking"
          ],
          initial: "auto",
          appliesto: "allElementsSVGContainerElements",
          computed: "asSpecifiedRelativeToAbsoluteLengths",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
        },
        "mask-clip": {
          syntax: "[ <geometry-box> | no-clip ]#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Masking"
          ],
          initial: "border-box",
          appliesto: "allElementsSVGContainerElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
        },
        "mask-composite": {
          syntax: "<compositing-operator>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Masking"
          ],
          initial: "add",
          appliesto: "allElementsSVGContainerElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
        },
        "mask-image": {
          syntax: "<mask-reference>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Masking"
          ],
          initial: "none",
          appliesto: "allElementsSVGContainerElements",
          computed: "asSpecifiedURLsAbsolute",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
        },
        "mask-mode": {
          syntax: "<masking-mode>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Masking"
          ],
          initial: "match-source",
          appliesto: "allElementsSVGContainerElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
        },
        "mask-origin": {
          syntax: "<geometry-box>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Masking"
          ],
          initial: "border-box",
          appliesto: "allElementsSVGContainerElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
        },
        "mask-position": {
          syntax: "<position>#",
          media: "visual",
          inherited: false,
          animationType: "repeatableListOfSimpleListOfLpc",
          percentages: "referToSizeOfMaskPaintingArea",
          groups: [
            "CSS Masking"
          ],
          initial: "center",
          appliesto: "allElementsSVGContainerElements",
          computed: "consistsOfTwoKeywordsForOriginAndOffsets",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
        },
        "mask-repeat": {
          syntax: "<repeat-style>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Masking"
          ],
          initial: "no-repeat",
          appliesto: "allElementsSVGContainerElements",
          computed: "consistsOfTwoDimensionKeywords",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
        },
        "mask-size": {
          syntax: "<bg-size>#",
          media: "visual",
          inherited: false,
          animationType: "repeatableListOfSimpleListOfLpc",
          percentages: "no",
          groups: [
            "CSS Masking"
          ],
          initial: "auto",
          appliesto: "allElementsSVGContainerElements",
          computed: "asSpecifiedRelativeToAbsoluteLengths",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
        },
        "mask-type": {
          syntax: "luminance | alpha",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Masking"
          ],
          initial: "luminance",
          appliesto: "maskElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
        },
        "masonry-auto-flow": {
          syntax: "[ pack | next ] || [ definite-first | ordered ]",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Grid Layout"
          ],
          initial: "pack",
          appliesto: "gridContainersWithMasonryLayout",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "experimental",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/masonry-auto-flow"
        },
        "math-style": {
          syntax: "normal | compact",
          media: "visual",
          inherited: true,
          animationType: "notAnimatable",
          percentages: "no",
          groups: [
            "MathML"
          ],
          initial: "normal",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-style"
        },
        "max-block-size": {
          syntax: "<'max-width'>",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "blockSizeOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "0",
          appliesto: "sameAsWidthAndHeight",
          computed: "sameAsMaxWidthAndMaxHeight",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
        },
        "max-height": {
          syntax: "none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>)",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
          groups: [
            "CSS Box Model"
          ],
          initial: "none",
          appliesto: "allElementsButNonReplacedAndTableColumns",
          computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
        },
        "max-inline-size": {
          syntax: "<'max-width'>",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "inlineSizeOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "0",
          appliesto: "sameAsWidthAndHeight",
          computed: "sameAsMaxWidthAndMaxHeight",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
        },
        "max-lines": {
          syntax: "none | <integer>",
          media: "visual",
          inherited: false,
          animationType: "integer",
          percentages: "no",
          groups: [
            "CSS Overflow"
          ],
          initial: "none",
          appliesto: "blockContainersExceptMultiColumnContainers",
          computed: "asSpecified",
          order: "perGrammar",
          status: "experimental"
        },
        "max-width": {
          syntax: "none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>)",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "referToWidthOfContainingBlock",
          groups: [
            "CSS Box Model"
          ],
          initial: "none",
          appliesto: "allElementsButNonReplacedAndTableRows",
          computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
        },
        "min-block-size": {
          syntax: "<'min-width'>",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "blockSizeOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "0",
          appliesto: "sameAsWidthAndHeight",
          computed: "sameAsMinWidthAndMinHeight",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
        },
        "min-height": {
          syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
          groups: [
            "CSS Box Model"
          ],
          initial: "auto",
          appliesto: "allElementsButNonReplacedAndTableColumns",
          computed: "percentageAsSpecifiedOrAbsoluteLength",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
        },
        "min-inline-size": {
          syntax: "<'min-width'>",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "inlineSizeOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "0",
          appliesto: "sameAsWidthAndHeight",
          computed: "sameAsMinWidthAndMinHeight",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
        },
        "min-width": {
          syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "referToWidthOfContainingBlock",
          groups: [
            "CSS Box Model"
          ],
          initial: "auto",
          appliesto: "allElementsButNonReplacedAndTableRows",
          computed: "percentageAsSpecifiedOrAbsoluteLength",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
        },
        "mix-blend-mode": {
          syntax: "<blend-mode>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Compositing and Blending"
          ],
          initial: "normal",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          stacking: true,
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
        },
        "object-fit": {
          syntax: "fill | contain | cover | none | scale-down",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Images"
          ],
          initial: "fill",
          appliesto: "replacedElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
        },
        "object-position": {
          syntax: "<position>",
          media: "visual",
          inherited: true,
          animationType: "repeatableListOfSimpleListOfLpc",
          percentages: "referToWidthAndHeightOfElement",
          groups: [
            "CSS Images"
          ],
          initial: "50% 50%",
          appliesto: "replacedElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
        },
        offset: {
          syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
          media: "visual",
          inherited: false,
          animationType: [
            "offset-position",
            "offset-path",
            "offset-distance",
            "offset-anchor",
            "offset-rotate"
          ],
          percentages: [
            "offset-position",
            "offset-distance",
            "offset-anchor"
          ],
          groups: [
            "CSS Motion Path"
          ],
          initial: [
            "offset-position",
            "offset-path",
            "offset-distance",
            "offset-anchor",
            "offset-rotate"
          ],
          appliesto: "transformableElements",
          computed: [
            "offset-position",
            "offset-path",
            "offset-distance",
            "offset-anchor",
            "offset-rotate"
          ],
          order: "perGrammar",
          stacking: true,
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
        },
        "offset-anchor": {
          syntax: "auto | <position>",
          media: "visual",
          inherited: false,
          animationType: "position",
          percentages: "relativeToWidthAndHeight",
          groups: [
            "CSS Motion Path"
          ],
          initial: "auto",
          appliesto: "transformableElements",
          computed: "forLengthAbsoluteValueOtherwisePercentage",
          order: "perGrammar",
          status: "standard"
        },
        "offset-distance": {
          syntax: "<length-percentage>",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "referToTotalPathLength",
          groups: [
            "CSS Motion Path"
          ],
          initial: "0",
          appliesto: "transformableElements",
          computed: "forLengthAbsoluteValueOtherwisePercentage",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
        },
        "offset-path": {
          syntax: "none | ray( [ <angle> && <size> && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
          media: "visual",
          inherited: false,
          animationType: "angleOrBasicShapeOrPath",
          percentages: "no",
          groups: [
            "CSS Motion Path"
          ],
          initial: "none",
          appliesto: "transformableElements",
          computed: "asSpecified",
          order: "perGrammar",
          stacking: true,
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
        },
        "offset-position": {
          syntax: "auto | <position>",
          media: "visual",
          inherited: false,
          animationType: "position",
          percentages: "referToSizeOfContainingBlock",
          groups: [
            "CSS Motion Path"
          ],
          initial: "auto",
          appliesto: "transformableElements",
          computed: "forLengthAbsoluteValueOtherwisePercentage",
          order: "perGrammar",
          status: "experimental"
        },
        "offset-rotate": {
          syntax: "[ auto | reverse ] || <angle>",
          media: "visual",
          inherited: false,
          animationType: "angleOrBasicShapeOrPath",
          percentages: "no",
          groups: [
            "CSS Motion Path"
          ],
          initial: "auto",
          appliesto: "transformableElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
        },
        opacity: {
          syntax: "<alpha-value>",
          media: "visual",
          inherited: false,
          animationType: "number",
          percentages: "no",
          groups: [
            "CSS Color"
          ],
          initial: "1.0",
          appliesto: "allElements",
          computed: "specifiedValueClipped0To1",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
        },
        order: {
          syntax: "<integer>",
          media: "visual",
          inherited: false,
          animationType: "integer",
          percentages: "no",
          groups: [
            "CSS Flexible Box Layout"
          ],
          initial: "0",
          appliesto: "flexItemsGridItemsAbsolutelyPositionedContainerChildren",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
        },
        orphans: {
          syntax: "<integer>",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Fragmentation"
          ],
          initial: "2",
          appliesto: "blockContainerElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
        },
        outline: {
          syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
          media: [
            "visual",
            "interactive"
          ],
          inherited: false,
          animationType: [
            "outline-color",
            "outline-width",
            "outline-style"
          ],
          percentages: "no",
          groups: [
            "CSS Basic User Interface"
          ],
          initial: [
            "outline-color",
            "outline-style",
            "outline-width"
          ],
          appliesto: "allElements",
          computed: [
            "outline-color",
            "outline-width",
            "outline-style"
          ],
          order: "orderOfAppearance",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
        },
        "outline-color": {
          syntax: "<color> | invert",
          media: [
            "visual",
            "interactive"
          ],
          inherited: false,
          animationType: "color",
          percentages: "no",
          groups: [
            "CSS Basic User Interface"
          ],
          initial: "invertOrCurrentColor",
          appliesto: "allElements",
          computed: "invertForTranslucentColorRGBAOtherwiseRGB",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
        },
        "outline-offset": {
          syntax: "<length>",
          media: [
            "visual",
            "interactive"
          ],
          inherited: false,
          animationType: "length",
          percentages: "no",
          groups: [
            "CSS Basic User Interface"
          ],
          initial: "0",
          appliesto: "allElements",
          computed: "asSpecifiedRelativeToAbsoluteLengths",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
        },
        "outline-style": {
          syntax: "auto | <'border-style'>",
          media: [
            "visual",
            "interactive"
          ],
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Basic User Interface"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
        },
        "outline-width": {
          syntax: "<line-width>",
          media: [
            "visual",
            "interactive"
          ],
          inherited: false,
          animationType: "length",
          percentages: "no",
          groups: [
            "CSS Basic User Interface"
          ],
          initial: "medium",
          appliesto: "allElements",
          computed: "absoluteLength0ForNone",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
        },
        overflow: {
          syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Overflow"
          ],
          initial: "visible",
          appliesto: "blockContainersFlexContainersGridContainers",
          computed: [
            "overflow-x",
            "overflow-y"
          ],
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
        },
        "overflow-anchor": {
          syntax: "auto | none",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Scroll Anchoring"
          ],
          initial: "auto",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard"
        },
        "overflow-block": {
          syntax: "visible | hidden | clip | scroll | auto",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Overflow"
          ],
          initial: "auto",
          appliesto: "blockContainersFlexContainersGridContainers",
          computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
          order: "perGrammar",
          status: "standard"
        },
        "overflow-clip-box": {
          syntax: "padding-box | content-box",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Mozilla Extensions"
          ],
          initial: "padding-box",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
        },
        "overflow-inline": {
          syntax: "visible | hidden | clip | scroll | auto",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Overflow"
          ],
          initial: "auto",
          appliesto: "blockContainersFlexContainersGridContainers",
          computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
          order: "perGrammar",
          status: "standard"
        },
        "overflow-wrap": {
          syntax: "normal | break-word | anywhere",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Text"
          ],
          initial: "normal",
          appliesto: "nonReplacedInlineElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
        },
        "overflow-x": {
          syntax: "visible | hidden | clip | scroll | auto",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Overflow"
          ],
          initial: "visible",
          appliesto: "blockContainersFlexContainersGridContainers",
          computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
        },
        "overflow-y": {
          syntax: "visible | hidden | clip | scroll | auto",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Overflow"
          ],
          initial: "visible",
          appliesto: "blockContainersFlexContainersGridContainers",
          computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
        },
        "overscroll-behavior": {
          syntax: "[ contain | none | auto ]{1,2}",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Box Model"
          ],
          initial: "auto",
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
        },
        "overscroll-behavior-block": {
          syntax: "contain | none | auto",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Box Model"
          ],
          initial: "auto",
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-block"
        },
        "overscroll-behavior-inline": {
          syntax: "contain | none | auto",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Box Model"
          ],
          initial: "auto",
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-inline"
        },
        "overscroll-behavior-x": {
          syntax: "contain | none | auto",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Box Model"
          ],
          initial: "auto",
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
        },
        "overscroll-behavior-y": {
          syntax: "contain | none | auto",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Box Model"
          ],
          initial: "auto",
          appliesto: "nonReplacedBlockAndInlineBlockElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
        },
        padding: {
          syntax: "[ <length> | <percentage> ]{1,4}",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "referToWidthOfContainingBlock",
          groups: [
            "CSS Box Model"
          ],
          initial: [
            "padding-bottom",
            "padding-left",
            "padding-right",
            "padding-top"
          ],
          appliesto: "allElementsExceptInternalTableDisplayTypes",
          computed: [
            "padding-bottom",
            "padding-left",
            "padding-right",
            "padding-top"
          ],
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
        },
        "padding-block": {
          syntax: "<'padding-left'>{1,2}",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "logicalWidthOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "0",
          appliesto: "allElements",
          computed: "asLength",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
        },
        "padding-block-end": {
          syntax: "<'padding-left'>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "logicalWidthOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "0",
          appliesto: "allElements",
          computed: "asLength",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
        },
        "padding-block-start": {
          syntax: "<'padding-left'>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "logicalWidthOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "0",
          appliesto: "allElements",
          computed: "asLength",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
        },
        "padding-bottom": {
          syntax: "<length> | <percentage>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "referToWidthOfContainingBlock",
          groups: [
            "CSS Box Model"
          ],
          initial: "0",
          appliesto: "allElementsExceptInternalTableDisplayTypes",
          computed: "percentageAsSpecifiedOrAbsoluteLength",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
        },
        "padding-inline": {
          syntax: "<'padding-left'>{1,2}",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "logicalWidthOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "0",
          appliesto: "allElements",
          computed: "asLength",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
        },
        "padding-inline-end": {
          syntax: "<'padding-left'>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "logicalWidthOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "0",
          appliesto: "allElements",
          computed: "asLength",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
        },
        "padding-inline-start": {
          syntax: "<'padding-left'>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "logicalWidthOfContainingBlock",
          groups: [
            "CSS Logical Properties"
          ],
          initial: "0",
          appliesto: "allElements",
          computed: "asLength",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
        },
        "padding-left": {
          syntax: "<length> | <percentage>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "referToWidthOfContainingBlock",
          groups: [
            "CSS Box Model"
          ],
          initial: "0",
          appliesto: "allElementsExceptInternalTableDisplayTypes",
          computed: "percentageAsSpecifiedOrAbsoluteLength",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
        },
        "padding-right": {
          syntax: "<length> | <percentage>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "referToWidthOfContainingBlock",
          groups: [
            "CSS Box Model"
          ],
          initial: "0",
          appliesto: "allElementsExceptInternalTableDisplayTypes",
          computed: "percentageAsSpecifiedOrAbsoluteLength",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
        },
        "padding-top": {
          syntax: "<length> | <percentage>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "referToWidthOfContainingBlock",
          groups: [
            "CSS Box Model"
          ],
          initial: "0",
          appliesto: "allElementsExceptInternalTableDisplayTypes",
          computed: "percentageAsSpecifiedOrAbsoluteLength",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
        },
        "page-break-after": {
          syntax: "auto | always | avoid | left | right | recto | verso",
          media: [
            "visual",
            "paged"
          ],
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Pages"
          ],
          initial: "auto",
          appliesto: "blockElementsInNormalFlow",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
        },
        "page-break-before": {
          syntax: "auto | always | avoid | left | right | recto | verso",
          media: [
            "visual",
            "paged"
          ],
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Pages"
          ],
          initial: "auto",
          appliesto: "blockElementsInNormalFlow",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
        },
        "page-break-inside": {
          syntax: "auto | avoid",
          media: [
            "visual",
            "paged"
          ],
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Pages"
          ],
          initial: "auto",
          appliesto: "blockElementsInNormalFlow",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
        },
        "paint-order": {
          syntax: "normal | [ fill || stroke || markers ]",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Text"
          ],
          initial: "normal",
          appliesto: "textElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
        },
        perspective: {
          syntax: "none | <length>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "no",
          groups: [
            "CSS Transforms"
          ],
          initial: "none",
          appliesto: "transformableElements",
          computed: "absoluteLengthOrNone",
          order: "uniqueOrder",
          stacking: true,
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
        },
        "perspective-origin": {
          syntax: "<position>",
          media: "visual",
          inherited: false,
          animationType: "simpleListOfLpc",
          percentages: "referToSizeOfBoundingBox",
          groups: [
            "CSS Transforms"
          ],
          initial: "50% 50%",
          appliesto: "transformableElements",
          computed: "forLengthAbsoluteValueOtherwisePercentage",
          order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
        },
        "place-content": {
          syntax: "<'align-content'> <'justify-content'>?",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Box Alignment"
          ],
          initial: "normal",
          appliesto: "multilineFlexContainers",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
        },
        "place-items": {
          syntax: "<'align-items'> <'justify-items'>?",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Box Alignment"
          ],
          initial: [
            "align-items",
            "justify-items"
          ],
          appliesto: "allElements",
          computed: [
            "align-items",
            "justify-items"
          ],
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
        },
        "place-self": {
          syntax: "<'align-self'> <'justify-self'>?",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Box Alignment"
          ],
          initial: [
            "align-self",
            "justify-self"
          ],
          appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
          computed: [
            "align-self",
            "justify-self"
          ],
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
        },
        "pointer-events": {
          syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Pointer Events"
          ],
          initial: "auto",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
        },
        position: {
          syntax: "static | relative | absolute | sticky | fixed",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Positioning"
          ],
          initial: "static",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          stacking: true,
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
        },
        quotes: {
          syntax: "none | auto | [ <string> <string> ]+",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Generated Content"
          ],
          initial: "dependsOnUserAgent",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
        },
        resize: {
          syntax: "none | both | horizontal | vertical | block | inline",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Basic User Interface"
          ],
          initial: "none",
          appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
        },
        right: {
          syntax: "<length> | <percentage> | auto",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "referToWidthOfContainingBlock",
          groups: [
            "CSS Positioning"
          ],
          initial: "auto",
          appliesto: "positionedElements",
          computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
        },
        rotate: {
          syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
          media: "visual",
          inherited: false,
          animationType: "transform",
          percentages: "no",
          groups: [
            "CSS Transforms"
          ],
          initial: "none",
          appliesto: "transformableElements",
          computed: "asSpecified",
          order: "perGrammar",
          stacking: true,
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
        },
        "row-gap": {
          syntax: "normal | <length-percentage>",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "referToDimensionOfContentArea",
          groups: [
            "CSS Box Alignment"
          ],
          initial: "normal",
          appliesto: "multiColumnElementsFlexContainersGridContainers",
          computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
        },
        "ruby-align": {
          syntax: "start | center | space-between | space-around",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Ruby"
          ],
          initial: "space-around",
          appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "experimental",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
        },
        "ruby-merge": {
          syntax: "separate | collapse | auto",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Ruby"
          ],
          initial: "separate",
          appliesto: "rubyAnnotationsContainers",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "experimental"
        },
        "ruby-position": {
          syntax: "over | under | inter-character",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Ruby"
          ],
          initial: "over",
          appliesto: "rubyAnnotationsContainers",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "experimental",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
        },
        scale: {
          syntax: "none | <number>{1,3}",
          media: "visual",
          inherited: false,
          animationType: "transform",
          percentages: "no",
          groups: [
            "CSS Transforms"
          ],
          initial: "none",
          appliesto: "transformableElements",
          computed: "asSpecified",
          order: "perGrammar",
          stacking: true,
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
        },
        "scrollbar-color": {
          syntax: "auto | dark | light | <color>{2}",
          media: "visual",
          inherited: true,
          animationType: "color",
          percentages: "no",
          groups: [
            "CSS Scrollbars"
          ],
          initial: "auto",
          appliesto: "scrollingBoxes",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
        },
        "scrollbar-gutter": {
          syntax: "auto | [ stable | always ] && both? && force?",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Overflow"
          ],
          initial: "auto",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-gutter"
        },
        "scrollbar-width": {
          syntax: "auto | thin | none",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Scrollbars"
          ],
          initial: "auto",
          appliesto: "scrollingBoxes",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
        },
        "scroll-behavior": {
          syntax: "auto | smooth",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSSOM View"
          ],
          initial: "auto",
          appliesto: "scrollingBoxes",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
        },
        "scroll-margin": {
          syntax: "<length>{1,4}",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "no",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "0",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
        },
        "scroll-margin-block": {
          syntax: "<length>{1,2}",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "no",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "0",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
        },
        "scroll-margin-block-start": {
          syntax: "<length>",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "no",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "0",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
        },
        "scroll-margin-block-end": {
          syntax: "<length>",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "no",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "0",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
        },
        "scroll-margin-bottom": {
          syntax: "<length>",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "no",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "0",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
        },
        "scroll-margin-inline": {
          syntax: "<length>{1,2}",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "no",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "0",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
        },
        "scroll-margin-inline-start": {
          syntax: "<length>",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "no",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "0",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
        },
        "scroll-margin-inline-end": {
          syntax: "<length>",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "no",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "0",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
        },
        "scroll-margin-left": {
          syntax: "<length>",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "no",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "0",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
        },
        "scroll-margin-right": {
          syntax: "<length>",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "no",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "0",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
        },
        "scroll-margin-top": {
          syntax: "<length>",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "no",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "0",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
        },
        "scroll-padding": {
          syntax: "[ auto | <length-percentage> ]{1,4}",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "relativeToTheScrollContainersScrollport",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "auto",
          appliesto: "scrollContainers",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
        },
        "scroll-padding-block": {
          syntax: "[ auto | <length-percentage> ]{1,2}",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "relativeToTheScrollContainersScrollport",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "auto",
          appliesto: "scrollContainers",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
        },
        "scroll-padding-block-start": {
          syntax: "auto | <length-percentage>",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "relativeToTheScrollContainersScrollport",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "auto",
          appliesto: "scrollContainers",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
        },
        "scroll-padding-block-end": {
          syntax: "auto | <length-percentage>",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "relativeToTheScrollContainersScrollport",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "auto",
          appliesto: "scrollContainers",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
        },
        "scroll-padding-bottom": {
          syntax: "auto | <length-percentage>",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "relativeToTheScrollContainersScrollport",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "auto",
          appliesto: "scrollContainers",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
        },
        "scroll-padding-inline": {
          syntax: "[ auto | <length-percentage> ]{1,2}",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "relativeToTheScrollContainersScrollport",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "auto",
          appliesto: "scrollContainers",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
        },
        "scroll-padding-inline-start": {
          syntax: "auto | <length-percentage>",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "relativeToTheScrollContainersScrollport",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "auto",
          appliesto: "scrollContainers",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
        },
        "scroll-padding-inline-end": {
          syntax: "auto | <length-percentage>",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "relativeToTheScrollContainersScrollport",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "auto",
          appliesto: "scrollContainers",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
        },
        "scroll-padding-left": {
          syntax: "auto | <length-percentage>",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "relativeToTheScrollContainersScrollport",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "auto",
          appliesto: "scrollContainers",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
        },
        "scroll-padding-right": {
          syntax: "auto | <length-percentage>",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "relativeToTheScrollContainersScrollport",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "auto",
          appliesto: "scrollContainers",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
        },
        "scroll-padding-top": {
          syntax: "auto | <length-percentage>",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "relativeToTheScrollContainersScrollport",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "auto",
          appliesto: "scrollContainers",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
        },
        "scroll-snap-align": {
          syntax: "[ none | start | end | center ]{1,2}",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
        },
        "scroll-snap-coordinate": {
          syntax: "none | <position>#",
          media: "interactive",
          inherited: false,
          animationType: "position",
          percentages: "referToBorderBox",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecifiedRelativeToAbsoluteLengths",
          order: "uniqueOrder",
          status: "obsolete",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
        },
        "scroll-snap-destination": {
          syntax: "<position>",
          media: "interactive",
          inherited: false,
          animationType: "position",
          percentages: "relativeToScrollContainerPaddingBoxAxis",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "0px 0px",
          appliesto: "scrollContainers",
          computed: "asSpecifiedRelativeToAbsoluteLengths",
          order: "uniqueOrder",
          status: "obsolete",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
        },
        "scroll-snap-points-x": {
          syntax: "none | repeat( <length-percentage> )",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "relativeToScrollContainerPaddingBoxAxis",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "none",
          appliesto: "scrollContainers",
          computed: "asSpecifiedRelativeToAbsoluteLengths",
          order: "uniqueOrder",
          status: "obsolete",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
        },
        "scroll-snap-points-y": {
          syntax: "none | repeat( <length-percentage> )",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "relativeToScrollContainerPaddingBoxAxis",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "none",
          appliesto: "scrollContainers",
          computed: "asSpecifiedRelativeToAbsoluteLengths",
          order: "uniqueOrder",
          status: "obsolete",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
        },
        "scroll-snap-stop": {
          syntax: "normal | always",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "normal",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
        },
        "scroll-snap-type": {
          syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
        },
        "scroll-snap-type-x": {
          syntax: "none | mandatory | proximity",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "none",
          appliesto: "scrollContainers",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "obsolete",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
        },
        "scroll-snap-type-y": {
          syntax: "none | mandatory | proximity",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Scroll Snap"
          ],
          initial: "none",
          appliesto: "scrollContainers",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "obsolete",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
        },
        "shape-image-threshold": {
          syntax: "<alpha-value>",
          media: "visual",
          inherited: false,
          animationType: "number",
          percentages: "no",
          groups: [
            "CSS Shapes"
          ],
          initial: "0.0",
          appliesto: "floats",
          computed: "specifiedValueNumberClipped0To1",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
        },
        "shape-margin": {
          syntax: "<length-percentage>",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "referToWidthOfContainingBlock",
          groups: [
            "CSS Shapes"
          ],
          initial: "0",
          appliesto: "floats",
          computed: "asSpecifiedRelativeToAbsoluteLengths",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
        },
        "shape-outside": {
          syntax: "none | <shape-box> || <basic-shape> | <image>",
          media: "visual",
          inherited: false,
          animationType: "basicShapeOtherwiseNo",
          percentages: "no",
          groups: [
            "CSS Shapes"
          ],
          initial: "none",
          appliesto: "floats",
          computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
        },
        "tab-size": {
          syntax: "<integer> | <length>",
          media: "visual",
          inherited: true,
          animationType: "length",
          percentages: "no",
          groups: [
            "CSS Text"
          ],
          initial: "8",
          appliesto: "blockContainers",
          computed: "specifiedIntegerOrAbsoluteLength",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
        },
        "table-layout": {
          syntax: "auto | fixed",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Table"
          ],
          initial: "auto",
          appliesto: "tableElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
        },
        "text-align": {
          syntax: "start | end | left | right | center | justify | match-parent",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Text"
          ],
          initial: "startOrNamelessValueIfLTRRightIfRTL",
          appliesto: "blockContainers",
          computed: "asSpecifiedExceptMatchParent",
          order: "orderOfAppearance",
          alsoAppliesTo: [
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
        },
        "text-align-last": {
          syntax: "auto | start | end | left | right | center | justify",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Text"
          ],
          initial: "auto",
          appliesto: "blockContainers",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
        },
        "text-combine-upright": {
          syntax: "none | all | [ digits <integer>? ]",
          media: "visual",
          inherited: true,
          animationType: "notAnimatable",
          percentages: "no",
          groups: [
            "CSS Writing Modes"
          ],
          initial: "none",
          appliesto: "nonReplacedInlineElements",
          computed: "keywordPlusIntegerIfDigits",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
        },
        "text-decoration": {
          syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
          media: "visual",
          inherited: false,
          animationType: [
            "text-decoration-color",
            "text-decoration-style",
            "text-decoration-line",
            "text-decoration-thickness"
          ],
          percentages: "no",
          groups: [
            "CSS Text Decoration"
          ],
          initial: [
            "text-decoration-color",
            "text-decoration-style",
            "text-decoration-line"
          ],
          appliesto: "allElements",
          computed: [
            "text-decoration-line",
            "text-decoration-style",
            "text-decoration-color",
            "text-decoration-thickness"
          ],
          order: "orderOfAppearance",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
        },
        "text-decoration-color": {
          syntax: "<color>",
          media: "visual",
          inherited: false,
          animationType: "color",
          percentages: "no",
          groups: [
            "CSS Text Decoration"
          ],
          initial: "currentcolor",
          appliesto: "allElements",
          computed: "computedColor",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
        },
        "text-decoration-line": {
          syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Text Decoration"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "orderOfAppearance",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
        },
        "text-decoration-skip": {
          syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Text Decoration"
          ],
          initial: "objects",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "experimental",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
        },
        "text-decoration-skip-ink": {
          syntax: "auto | all | none",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Text Decoration"
          ],
          initial: "auto",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
        },
        "text-decoration-style": {
          syntax: "solid | double | dotted | dashed | wavy",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Text Decoration"
          ],
          initial: "solid",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
        },
        "text-decoration-thickness": {
          syntax: "auto | from-font | <length> | <percentage> ",
          media: "visual",
          inherited: false,
          animationType: "byComputedValueType",
          percentages: "referToElementFontSize",
          groups: [
            "CSS Text Decoration"
          ],
          initial: "auto",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
        },
        "text-emphasis": {
          syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
          media: "visual",
          inherited: false,
          animationType: [
            "text-emphasis-color",
            "text-emphasis-style"
          ],
          percentages: "no",
          groups: [
            "CSS Text Decoration"
          ],
          initial: [
            "text-emphasis-style",
            "text-emphasis-color"
          ],
          appliesto: "allElements",
          computed: [
            "text-emphasis-style",
            "text-emphasis-color"
          ],
          order: "orderOfAppearance",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
        },
        "text-emphasis-color": {
          syntax: "<color>",
          media: "visual",
          inherited: false,
          animationType: "color",
          percentages: "no",
          groups: [
            "CSS Text Decoration"
          ],
          initial: "currentcolor",
          appliesto: "allElements",
          computed: "computedColor",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
        },
        "text-emphasis-position": {
          syntax: "[ over | under ] && [ right | left ]",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Text Decoration"
          ],
          initial: "over right",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
        },
        "text-emphasis-style": {
          syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Text Decoration"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
        },
        "text-indent": {
          syntax: "<length-percentage> && hanging? && each-line?",
          media: "visual",
          inherited: true,
          animationType: "lpc",
          percentages: "referToWidthOfContainingBlock",
          groups: [
            "CSS Text"
          ],
          initial: "0",
          appliesto: "blockContainers",
          computed: "percentageOrAbsoluteLengthPlusKeywords",
          order: "lengthOrPercentageBeforeKeywords",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
        },
        "text-justify": {
          syntax: "auto | inter-character | inter-word | none",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Text"
          ],
          initial: "auto",
          appliesto: "inlineLevelAndTableCellElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
        },
        "text-orientation": {
          syntax: "mixed | upright | sideways",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Writing Modes"
          ],
          initial: "mixed",
          appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
        },
        "text-overflow": {
          syntax: "[ clip | ellipsis | <string> ]{1,2}",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Basic User Interface"
          ],
          initial: "clip",
          appliesto: "blockContainerElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
        },
        "text-rendering": {
          syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Miscellaneous"
          ],
          initial: "auto",
          appliesto: "textElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
        },
        "text-shadow": {
          syntax: "none | <shadow-t>#",
          media: "visual",
          inherited: true,
          animationType: "shadowList",
          percentages: "no",
          groups: [
            "CSS Text Decoration"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "colorPlusThreeAbsoluteLengths",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
        },
        "text-size-adjust": {
          syntax: "none | auto | <percentage>",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "referToSizeOfFont",
          groups: [
            "CSS Text"
          ],
          initial: "autoForSmartphoneBrowsersSupportingInflation",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "experimental",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
        },
        "text-transform": {
          syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Text"
          ],
          initial: "none",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
        },
        "text-underline-offset": {
          syntax: "auto | <length> | <percentage> ",
          media: "visual",
          inherited: true,
          animationType: "byComputedValueType",
          percentages: "referToElementFontSize",
          groups: [
            "CSS Text Decoration"
          ],
          initial: "auto",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
        },
        "text-underline-position": {
          syntax: "auto | from-font | [ under || [ left | right ] ]",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Text Decoration"
          ],
          initial: "auto",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
        },
        top: {
          syntax: "<length> | <percentage> | auto",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "referToContainingBlockHeight",
          groups: [
            "CSS Positioning"
          ],
          initial: "auto",
          appliesto: "positionedElements",
          computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
        },
        "touch-action": {
          syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "Pointer Events"
          ],
          initial: "auto",
          appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
        },
        transform: {
          syntax: "none | <transform-list>",
          media: "visual",
          inherited: false,
          animationType: "transform",
          percentages: "referToSizeOfBoundingBox",
          groups: [
            "CSS Transforms"
          ],
          initial: "none",
          appliesto: "transformableElements",
          computed: "asSpecifiedRelativeToAbsoluteLengths",
          order: "uniqueOrder",
          stacking: true,
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
        },
        "transform-box": {
          syntax: "content-box | border-box | fill-box | stroke-box | view-box",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Transforms"
          ],
          initial: "view-box",
          appliesto: "transformableElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
        },
        "transform-origin": {
          syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
          media: "visual",
          inherited: false,
          animationType: "simpleListOfLpc",
          percentages: "referToSizeOfBoundingBox",
          groups: [
            "CSS Transforms"
          ],
          initial: "50% 50% 0",
          appliesto: "transformableElements",
          computed: "forLengthAbsoluteValueOtherwisePercentage",
          order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
        },
        "transform-style": {
          syntax: "flat | preserve-3d",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Transforms"
          ],
          initial: "flat",
          appliesto: "transformableElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          stacking: true,
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
        },
        transition: {
          syntax: "<single-transition>#",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Transitions"
          ],
          initial: [
            "transition-delay",
            "transition-duration",
            "transition-property",
            "transition-timing-function"
          ],
          appliesto: "allElementsAndPseudos",
          computed: [
            "transition-delay",
            "transition-duration",
            "transition-property",
            "transition-timing-function"
          ],
          order: "orderOfAppearance",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
        },
        "transition-delay": {
          syntax: "<time>#",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Transitions"
          ],
          initial: "0s",
          appliesto: "allElementsAndPseudos",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
        },
        "transition-duration": {
          syntax: "<time>#",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Transitions"
          ],
          initial: "0s",
          appliesto: "allElementsAndPseudos",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
        },
        "transition-property": {
          syntax: "none | <single-transition-property>#",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Transitions"
          ],
          initial: "all",
          appliesto: "allElementsAndPseudos",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
        },
        "transition-timing-function": {
          syntax: "<timing-function>#",
          media: "interactive",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Transitions"
          ],
          initial: "ease",
          appliesto: "allElementsAndPseudos",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
        },
        translate: {
          syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
          media: "visual",
          inherited: false,
          animationType: "transform",
          percentages: "referToSizeOfBoundingBox",
          groups: [
            "CSS Transforms"
          ],
          initial: "none",
          appliesto: "transformableElements",
          computed: "asSpecifiedRelativeToAbsoluteLengths",
          order: "perGrammar",
          stacking: true,
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
        },
        "unicode-bidi": {
          syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Writing Modes"
          ],
          initial: "normal",
          appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
        },
        "user-select": {
          syntax: "auto | text | none | contain | all",
          media: "visual",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Basic User Interface"
          ],
          initial: "auto",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
        },
        "vertical-align": {
          syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
          media: "visual",
          inherited: false,
          animationType: "length",
          percentages: "referToLineHeight",
          groups: [
            "CSS Table"
          ],
          initial: "baseline",
          appliesto: "inlineLevelAndTableCellElements",
          computed: "absoluteLengthOrKeyword",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
        },
        visibility: {
          syntax: "visible | hidden | collapse",
          media: "visual",
          inherited: true,
          animationType: "visibility",
          percentages: "no",
          groups: [
            "CSS Box Model"
          ],
          initial: "visible",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
        },
        "white-space": {
          syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Text"
          ],
          initial: "normal",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
        },
        widows: {
          syntax: "<integer>",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Fragmentation"
          ],
          initial: "2",
          appliesto: "blockContainerElements",
          computed: "asSpecified",
          order: "perGrammar",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
        },
        width: {
          syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)",
          media: "visual",
          inherited: false,
          animationType: "lpc",
          percentages: "referToWidthOfContainingBlock",
          groups: [
            "CSS Box Model"
          ],
          initial: "auto",
          appliesto: "allElementsButNonReplacedAndTableRows",
          computed: "percentageAutoOrAbsoluteLength",
          order: "lengthOrPercentageBeforeKeywordIfBothPresent",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
        },
        "will-change": {
          syntax: "auto | <animateable-feature>#",
          media: "all",
          inherited: false,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Will Change"
          ],
          initial: "auto",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
        },
        "word-break": {
          syntax: "normal | break-all | keep-all | break-word",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Text"
          ],
          initial: "normal",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
        },
        "word-spacing": {
          syntax: "normal | <length-percentage>",
          media: "visual",
          inherited: true,
          animationType: "length",
          percentages: "referToWidthOfAffectedGlyph",
          groups: [
            "CSS Text"
          ],
          initial: "normal",
          appliesto: "allElements",
          computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
          order: "uniqueOrder",
          alsoAppliesTo: [
            "::first-letter",
            "::first-line",
            "::placeholder"
          ],
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
        },
        "word-wrap": {
          syntax: "normal | break-word",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Text"
          ],
          initial: "normal",
          appliesto: "nonReplacedInlineElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
        },
        "writing-mode": {
          syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
          media: "visual",
          inherited: true,
          animationType: "discrete",
          percentages: "no",
          groups: [
            "CSS Writing Modes"
          ],
          initial: "horizontal-tb",
          appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
        },
        "z-index": {
          syntax: "auto | <integer>",
          media: "visual",
          inherited: false,
          animationType: "integer",
          percentages: "no",
          groups: [
            "CSS Positioning"
          ],
          initial: "auto",
          appliesto: "positionedElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          stacking: true,
          status: "standard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
        },
        zoom: {
          syntax: "normal | reset | <number> | <percentage>",
          media: "visual",
          inherited: false,
          animationType: "integer",
          percentages: "no",
          groups: [
            "Microsoft Extensions"
          ],
          initial: "normal",
          appliesto: "allElements",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "nonstandard",
          mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
        }
      };
    }
  });

  // node_modules/.pnpm/mdn-data@2.0.14/node_modules/mdn-data/css/syntaxes.json
  var require_syntaxes = __commonJS({
    "node_modules/.pnpm/mdn-data@2.0.14/node_modules/mdn-data/css/syntaxes.json"(exports, module) {
      module.exports = {
        "absolute-size": {
          syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
        },
        "alpha-value": {
          syntax: "<number> | <percentage>"
        },
        "angle-percentage": {
          syntax: "<angle> | <percentage>"
        },
        "angular-color-hint": {
          syntax: "<angle-percentage>"
        },
        "angular-color-stop": {
          syntax: "<color> && <color-stop-angle>?"
        },
        "angular-color-stop-list": {
          syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
        },
        "animateable-feature": {
          syntax: "scroll-position | contents | <custom-ident>"
        },
        attachment: {
          syntax: "scroll | fixed | local"
        },
        "attr()": {
          syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
        },
        "attr-matcher": {
          syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
        },
        "attr-modifier": {
          syntax: "i | s"
        },
        "attribute-selector": {
          syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
        },
        "auto-repeat": {
          syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
        },
        "auto-track-list": {
          syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
        },
        "baseline-position": {
          syntax: "[ first | last ]? baseline"
        },
        "basic-shape": {
          syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()> | <path()>"
        },
        "bg-image": {
          syntax: "none | <image>"
        },
        "bg-layer": {
          syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
        },
        "bg-position": {
          syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
        },
        "bg-size": {
          syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
        },
        "blur()": {
          syntax: "blur( <length> )"
        },
        "blend-mode": {
          syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
        },
        box: {
          syntax: "border-box | padding-box | content-box"
        },
        "brightness()": {
          syntax: "brightness( <number-percentage> )"
        },
        "calc()": {
          syntax: "calc( <calc-sum> )"
        },
        "calc-sum": {
          syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
        },
        "calc-product": {
          syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
        },
        "calc-value": {
          syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
        },
        "cf-final-image": {
          syntax: "<image> | <color>"
        },
        "cf-mixing-image": {
          syntax: "<percentage>? && <image>"
        },
        "circle()": {
          syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
        },
        "clamp()": {
          syntax: "clamp( <calc-sum>#{3} )"
        },
        "class-selector": {
          syntax: "'.' <ident-token>"
        },
        "clip-source": {
          syntax: "<url>"
        },
        color: {
          syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
        },
        "color-stop": {
          syntax: "<color-stop-length> | <color-stop-angle>"
        },
        "color-stop-angle": {
          syntax: "<angle-percentage>{1,2}"
        },
        "color-stop-length": {
          syntax: "<length-percentage>{1,2}"
        },
        "color-stop-list": {
          syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
        },
        combinator: {
          syntax: "'>' | '+' | '~' | [ '||' ]"
        },
        "common-lig-values": {
          syntax: "[ common-ligatures | no-common-ligatures ]"
        },
        "compat-auto": {
          syntax: "searchfield | textarea | push-button | slider-horizontal | checkbox | radio | square-button | menulist | listbox | meter | progress-bar | button"
        },
        "composite-style": {
          syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
        },
        "compositing-operator": {
          syntax: "add | subtract | intersect | exclude"
        },
        "compound-selector": {
          syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
        },
        "compound-selector-list": {
          syntax: "<compound-selector>#"
        },
        "complex-selector": {
          syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
        },
        "complex-selector-list": {
          syntax: "<complex-selector>#"
        },
        "conic-gradient()": {
          syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
        },
        "contextual-alt-values": {
          syntax: "[ contextual | no-contextual ]"
        },
        "content-distribution": {
          syntax: "space-between | space-around | space-evenly | stretch"
        },
        "content-list": {
          syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
        },
        "content-position": {
          syntax: "center | start | end | flex-start | flex-end"
        },
        "content-replacement": {
          syntax: "<image>"
        },
        "contrast()": {
          syntax: "contrast( [ <number-percentage> ] )"
        },
        "counter()": {
          syntax: "counter( <custom-ident>, <counter-style>? )"
        },
        "counter-style": {
          syntax: "<counter-style-name> | symbols()"
        },
        "counter-style-name": {
          syntax: "<custom-ident>"
        },
        "counters()": {
          syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
        },
        "cross-fade()": {
          syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
        },
        "cubic-bezier-timing-function": {
          syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number [0,1]>, <number>, <number [0,1]>, <number>)"
        },
        "deprecated-system-color": {
          syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
        },
        "discretionary-lig-values": {
          syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
        },
        "display-box": {
          syntax: "contents | none"
        },
        "display-inside": {
          syntax: "flow | flow-root | table | flex | grid | ruby"
        },
        "display-internal": {
          syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
        },
        "display-legacy": {
          syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
        },
        "display-listitem": {
          syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
        },
        "display-outside": {
          syntax: "block | inline | run-in"
        },
        "drop-shadow()": {
          syntax: "drop-shadow( <length>{2,3} <color>? )"
        },
        "east-asian-variant-values": {
          syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
        },
        "east-asian-width-values": {
          syntax: "[ full-width | proportional-width ]"
        },
        "element()": {
          syntax: "element( <id-selector> )"
        },
        "ellipse()": {
          syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
        },
        "ending-shape": {
          syntax: "circle | ellipse"
        },
        "env()": {
          syntax: "env( <custom-ident> , <declaration-value>? )"
        },
        "explicit-track-list": {
          syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
        },
        "family-name": {
          syntax: "<string> | <custom-ident>+"
        },
        "feature-tag-value": {
          syntax: "<string> [ <integer> | on | off ]?"
        },
        "feature-type": {
          syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
        },
        "feature-value-block": {
          syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
        },
        "feature-value-block-list": {
          syntax: "<feature-value-block>+"
        },
        "feature-value-declaration": {
          syntax: "<custom-ident>: <integer>+;"
        },
        "feature-value-declaration-list": {
          syntax: "<feature-value-declaration>"
        },
        "feature-value-name": {
          syntax: "<custom-ident>"
        },
        "fill-rule": {
          syntax: "nonzero | evenodd"
        },
        "filter-function": {
          syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
        },
        "filter-function-list": {
          syntax: "[ <filter-function> | <url> ]+"
        },
        "final-bg-layer": {
          syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
        },
        "fit-content()": {
          syntax: "fit-content( [ <length> | <percentage> ] )"
        },
        "fixed-breadth": {
          syntax: "<length-percentage>"
        },
        "fixed-repeat": {
          syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
        },
        "fixed-size": {
          syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
        },
        "font-stretch-absolute": {
          syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
        },
        "font-variant-css21": {
          syntax: "[ normal | small-caps ]"
        },
        "font-weight-absolute": {
          syntax: "normal | bold | <number [1,1000]>"
        },
        "frequency-percentage": {
          syntax: "<frequency> | <percentage>"
        },
        "general-enclosed": {
          syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
        },
        "generic-family": {
          syntax: "serif | sans-serif | cursive | fantasy | monospace"
        },
        "generic-name": {
          syntax: "serif | sans-serif | cursive | fantasy | monospace"
        },
        "geometry-box": {
          syntax: "<shape-box> | fill-box | stroke-box | view-box"
        },
        gradient: {
          syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
        },
        "grayscale()": {
          syntax: "grayscale( <number-percentage> )"
        },
        "grid-line": {
          syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
        },
        "historical-lig-values": {
          syntax: "[ historical-ligatures | no-historical-ligatures ]"
        },
        "hsl()": {
          syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
        },
        "hsla()": {
          syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
        },
        hue: {
          syntax: "<number> | <angle>"
        },
        "hue-rotate()": {
          syntax: "hue-rotate( <angle> )"
        },
        "id-selector": {
          syntax: "<hash-token>"
        },
        image: {
          syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
        },
        "image()": {
          syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
        },
        "image-set()": {
          syntax: "image-set( <image-set-option># )"
        },
        "image-set-option": {
          syntax: "[ <image> | <string> ] <resolution>"
        },
        "image-src": {
          syntax: "<url> | <string>"
        },
        "image-tags": {
          syntax: "ltr | rtl"
        },
        "inflexible-breadth": {
          syntax: "<length> | <percentage> | min-content | max-content | auto"
        },
        "inset()": {
          syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
        },
        "invert()": {
          syntax: "invert( <number-percentage> )"
        },
        "keyframes-name": {
          syntax: "<custom-ident> | <string>"
        },
        "keyframe-block": {
          syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
        },
        "keyframe-block-list": {
          syntax: "<keyframe-block>+"
        },
        "keyframe-selector": {
          syntax: "from | to | <percentage>"
        },
        "leader()": {
          syntax: "leader( <leader-type> )"
        },
        "leader-type": {
          syntax: "dotted | solid | space | <string>"
        },
        "length-percentage": {
          syntax: "<length> | <percentage>"
        },
        "line-names": {
          syntax: "'[' <custom-ident>* ']'"
        },
        "line-name-list": {
          syntax: "[ <line-names> | <name-repeat> ]+"
        },
        "line-style": {
          syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
        },
        "line-width": {
          syntax: "<length> | thin | medium | thick"
        },
        "linear-color-hint": {
          syntax: "<length-percentage>"
        },
        "linear-color-stop": {
          syntax: "<color> <color-stop-length>?"
        },
        "linear-gradient()": {
          syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
        },
        "mask-layer": {
          syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
        },
        "mask-position": {
          syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
        },
        "mask-reference": {
          syntax: "none | <image> | <mask-source>"
        },
        "mask-source": {
          syntax: "<url>"
        },
        "masking-mode": {
          syntax: "alpha | luminance | match-source"
        },
        "matrix()": {
          syntax: "matrix( <number>#{6} )"
        },
        "matrix3d()": {
          syntax: "matrix3d( <number>#{16} )"
        },
        "max()": {
          syntax: "max( <calc-sum># )"
        },
        "media-and": {
          syntax: "<media-in-parens> [ and <media-in-parens> ]+"
        },
        "media-condition": {
          syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
        },
        "media-condition-without-or": {
          syntax: "<media-not> | <media-and> | <media-in-parens>"
        },
        "media-feature": {
          syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
        },
        "media-in-parens": {
          syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
        },
        "media-not": {
          syntax: "not <media-in-parens>"
        },
        "media-or": {
          syntax: "<media-in-parens> [ or <media-in-parens> ]+"
        },
        "media-query": {
          syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
        },
        "media-query-list": {
          syntax: "<media-query>#"
        },
        "media-type": {
          syntax: "<ident>"
        },
        "mf-boolean": {
          syntax: "<mf-name>"
        },
        "mf-name": {
          syntax: "<ident>"
        },
        "mf-plain": {
          syntax: "<mf-name> : <mf-value>"
        },
        "mf-range": {
          syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
        },
        "mf-value": {
          syntax: "<number> | <dimension> | <ident> | <ratio>"
        },
        "min()": {
          syntax: "min( <calc-sum># )"
        },
        "minmax()": {
          syntax: "minmax( [ <length> | <percentage> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
        },
        "named-color": {
          syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
        },
        "namespace-prefix": {
          syntax: "<ident>"
        },
        "ns-prefix": {
          syntax: "[ <ident-token> | '*' ]? '|'"
        },
        "number-percentage": {
          syntax: "<number> | <percentage>"
        },
        "numeric-figure-values": {
          syntax: "[ lining-nums | oldstyle-nums ]"
        },
        "numeric-fraction-values": {
          syntax: "[ diagonal-fractions | stacked-fractions ]"
        },
        "numeric-spacing-values": {
          syntax: "[ proportional-nums | tabular-nums ]"
        },
        nth: {
          syntax: "<an-plus-b> | even | odd"
        },
        "opacity()": {
          syntax: "opacity( [ <number-percentage> ] )"
        },
        "overflow-position": {
          syntax: "unsafe | safe"
        },
        "outline-radius": {
          syntax: "<length> | <percentage>"
        },
        "page-body": {
          syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
        },
        "page-margin-box": {
          syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
        },
        "page-margin-box-type": {
          syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
        },
        "page-selector-list": {
          syntax: "[ <page-selector># ]?"
        },
        "page-selector": {
          syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
        },
        "path()": {
          syntax: "path( [ <fill-rule>, ]? <string> )"
        },
        "paint()": {
          syntax: "paint( <ident>, <declaration-value>? )"
        },
        "perspective()": {
          syntax: "perspective( <length> )"
        },
        "polygon()": {
          syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
        },
        position: {
          syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
        },
        "pseudo-class-selector": {
          syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
        },
        "pseudo-element-selector": {
          syntax: "':' <pseudo-class-selector>"
        },
        "pseudo-page": {
          syntax: ": [ left | right | first | blank ]"
        },
        quote: {
          syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
        },
        "radial-gradient()": {
          syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
        },
        "relative-selector": {
          syntax: "<combinator>? <complex-selector>"
        },
        "relative-selector-list": {
          syntax: "<relative-selector>#"
        },
        "relative-size": {
          syntax: "larger | smaller"
        },
        "repeat-style": {
          syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
        },
        "repeating-linear-gradient()": {
          syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
        },
        "repeating-radial-gradient()": {
          syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
        },
        "rgb()": {
          syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
        },
        "rgba()": {
          syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
        },
        "rotate()": {
          syntax: "rotate( [ <angle> | <zero> ] )"
        },
        "rotate3d()": {
          syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
        },
        "rotateX()": {
          syntax: "rotateX( [ <angle> | <zero> ] )"
        },
        "rotateY()": {
          syntax: "rotateY( [ <angle> | <zero> ] )"
        },
        "rotateZ()": {
          syntax: "rotateZ( [ <angle> | <zero> ] )"
        },
        "saturate()": {
          syntax: "saturate( <number-percentage> )"
        },
        "scale()": {
          syntax: "scale( <number> , <number>? )"
        },
        "scale3d()": {
          syntax: "scale3d( <number> , <number> , <number> )"
        },
        "scaleX()": {
          syntax: "scaleX( <number> )"
        },
        "scaleY()": {
          syntax: "scaleY( <number> )"
        },
        "scaleZ()": {
          syntax: "scaleZ( <number> )"
        },
        "self-position": {
          syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
        },
        "shape-radius": {
          syntax: "<length-percentage> | closest-side | farthest-side"
        },
        "skew()": {
          syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
        },
        "skewX()": {
          syntax: "skewX( [ <angle> | <zero> ] )"
        },
        "skewY()": {
          syntax: "skewY( [ <angle> | <zero> ] )"
        },
        "sepia()": {
          syntax: "sepia( <number-percentage> )"
        },
        shadow: {
          syntax: "inset? && <length>{2,4} && <color>?"
        },
        "shadow-t": {
          syntax: "[ <length>{2,3} && <color>? ]"
        },
        shape: {
          syntax: "rect(<top>, <right>, <bottom>, <left>)"
        },
        "shape-box": {
          syntax: "<box> | margin-box"
        },
        "side-or-corner": {
          syntax: "[ left | right ] || [ top | bottom ]"
        },
        "single-animation": {
          syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
        },
        "single-animation-direction": {
          syntax: "normal | reverse | alternate | alternate-reverse"
        },
        "single-animation-fill-mode": {
          syntax: "none | forwards | backwards | both"
        },
        "single-animation-iteration-count": {
          syntax: "infinite | <number>"
        },
        "single-animation-play-state": {
          syntax: "running | paused"
        },
        "single-transition": {
          syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
        },
        "single-transition-property": {
          syntax: "all | <custom-ident>"
        },
        size: {
          syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
        },
        "step-position": {
          syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
        },
        "step-timing-function": {
          syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
        },
        "subclass-selector": {
          syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
        },
        "supports-condition": {
          syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
        },
        "supports-in-parens": {
          syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
        },
        "supports-feature": {
          syntax: "<supports-decl> | <supports-selector-fn>"
        },
        "supports-decl": {
          syntax: "( <declaration> )"
        },
        "supports-selector-fn": {
          syntax: "selector( <complex-selector> )"
        },
        symbol: {
          syntax: "<string> | <image> | <custom-ident>"
        },
        target: {
          syntax: "<target-counter()> | <target-counters()> | <target-text()>"
        },
        "target-counter()": {
          syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
        },
        "target-counters()": {
          syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
        },
        "target-text()": {
          syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
        },
        "time-percentage": {
          syntax: "<time> | <percentage>"
        },
        "timing-function": {
          syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
        },
        "track-breadth": {
          syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
        },
        "track-list": {
          syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
        },
        "track-repeat": {
          syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
        },
        "track-size": {
          syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
        },
        "transform-function": {
          syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
        },
        "transform-list": {
          syntax: "<transform-function>+"
        },
        "translate()": {
          syntax: "translate( <length-percentage> , <length-percentage>? )"
        },
        "translate3d()": {
          syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
        },
        "translateX()": {
          syntax: "translateX( <length-percentage> )"
        },
        "translateY()": {
          syntax: "translateY( <length-percentage> )"
        },
        "translateZ()": {
          syntax: "translateZ( <length> )"
        },
        "type-or-unit": {
          syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
        },
        "type-selector": {
          syntax: "<wq-name> | <ns-prefix>? '*'"
        },
        "var()": {
          syntax: "var( <custom-property-name> , <declaration-value>? )"
        },
        "viewport-length": {
          syntax: "auto | <length-percentage>"
        },
        "wq-name": {
          syntax: "<ns-prefix>? <ident-token>"
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/data/patch.json
  var require_patch = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/data/patch.json"(exports, module) {
      module.exports = {
        atrules: {
          charset: {
            prelude: "<string>"
          },
          "font-face": {
            descriptors: {
              "unicode-range": {
                comment: "replaces <unicode-range>, an old production name",
                syntax: "<urange>#"
              }
            }
          }
        },
        properties: {
          "-moz-background-clip": {
            comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
            syntax: "padding | border"
          },
          "-moz-border-radius-bottomleft": {
            comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
            syntax: "<'border-bottom-left-radius'>"
          },
          "-moz-border-radius-bottomright": {
            comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
            syntax: "<'border-bottom-right-radius'>"
          },
          "-moz-border-radius-topleft": {
            comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
            syntax: "<'border-top-left-radius'>"
          },
          "-moz-border-radius-topright": {
            comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
            syntax: "<'border-bottom-right-radius'>"
          },
          "-moz-control-character-visibility": {
            comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
            syntax: "visible | hidden"
          },
          "-moz-osx-font-smoothing": {
            comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
            syntax: "auto | grayscale"
          },
          "-moz-user-select": {
            comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
            syntax: "none | text | all | -moz-none"
          },
          "-ms-flex-align": {
            comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
            syntax: "start | end | center | baseline | stretch"
          },
          "-ms-flex-item-align": {
            comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
            syntax: "auto | start | end | center | baseline | stretch"
          },
          "-ms-flex-line-pack": {
            comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
            syntax: "start | end | center | justify | distribute | stretch"
          },
          "-ms-flex-negative": {
            comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
            syntax: "<'flex-shrink'>"
          },
          "-ms-flex-pack": {
            comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
            syntax: "start | end | center | justify | distribute"
          },
          "-ms-flex-order": {
            comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
            syntax: "<integer>"
          },
          "-ms-flex-positive": {
            comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
            syntax: "<'flex-grow'>"
          },
          "-ms-flex-preferred-size": {
            comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
            syntax: "<'flex-basis'>"
          },
          "-ms-interpolation-mode": {
            comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
            syntax: "nearest-neighbor | bicubic"
          },
          "-ms-grid-column-align": {
            comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
            syntax: "start | end | center | stretch"
          },
          "-ms-grid-row-align": {
            comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
            syntax: "start | end | center | stretch"
          },
          "-ms-hyphenate-limit-last": {
            comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
            syntax: "none | always | column | page | spread"
          },
          "-webkit-appearance": {
            comment: "webkit specific keywords",
            references: [
              "http://css-infos.net/property/-webkit-appearance"
            ],
            syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button"
          },
          "-webkit-background-clip": {
            comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
            syntax: "[ <box> | border | padding | content | text ]#"
          },
          "-webkit-column-break-after": {
            comment: "added, http://help.dottoro.com/lcrthhhv.php",
            syntax: "always | auto | avoid"
          },
          "-webkit-column-break-before": {
            comment: "added, http://help.dottoro.com/lcxquvkf.php",
            syntax: "always | auto | avoid"
          },
          "-webkit-column-break-inside": {
            comment: "added, http://help.dottoro.com/lclhnthl.php",
            syntax: "always | auto | avoid"
          },
          "-webkit-font-smoothing": {
            comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
            syntax: "auto | none | antialiased | subpixel-antialiased"
          },
          "-webkit-mask-box-image": {
            comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
            syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
          },
          "-webkit-print-color-adjust": {
            comment: "missed",
            references: [
              "https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
            ],
            syntax: "economy | exact"
          },
          "-webkit-text-security": {
            comment: "missed; http://help.dottoro.com/lcbkewgt.php",
            syntax: "none | circle | disc | square"
          },
          "-webkit-user-drag": {
            comment: "missed; http://help.dottoro.com/lcbixvwm.php",
            syntax: "none | element | auto"
          },
          "-webkit-user-select": {
            comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
            syntax: "auto | none | text | all"
          },
          "alignment-baseline": {
            comment: "added SVG property",
            references: [
              "https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
            ],
            syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
          },
          "baseline-shift": {
            comment: "added SVG property",
            references: [
              "https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
            ],
            syntax: "baseline | sub | super | <svg-length>"
          },
          behavior: {
            comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
            syntax: "<url>+"
          },
          "clip-rule": {
            comment: "added SVG property",
            references: [
              "https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
            ],
            syntax: "nonzero | evenodd"
          },
          cue: {
            comment: "https://www.w3.org/TR/css3-speech/#property-index",
            syntax: "<'cue-before'> <'cue-after'>?"
          },
          "cue-after": {
            comment: "https://www.w3.org/TR/css3-speech/#property-index",
            syntax: "<url> <decibel>? | none"
          },
          "cue-before": {
            comment: "https://www.w3.org/TR/css3-speech/#property-index",
            syntax: "<url> <decibel>? | none"
          },
          cursor: {
            comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
            references: [
              "https://www.sitepoint.com/css3-cursor-styles/"
            ],
            syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
          },
          display: {
            comment: "extended with -ms-flexbox",
            syntax: "| <-non-standard-display>"
          },
          position: {
            comment: "extended with -webkit-sticky",
            syntax: "| -webkit-sticky"
          },
          "dominant-baseline": {
            comment: "added SVG property",
            references: [
              "https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
            ],
            syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
          },
          "image-rendering": {
            comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
            references: [
              "https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
              "https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
            ],
            syntax: "| optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
          },
          fill: {
            comment: "added SVG property",
            references: [
              "https://www.w3.org/TR/SVG/painting.html#FillProperty"
            ],
            syntax: "<paint>"
          },
          "fill-opacity": {
            comment: "added SVG property",
            references: [
              "https://www.w3.org/TR/SVG/painting.html#FillProperty"
            ],
            syntax: "<number-zero-one>"
          },
          "fill-rule": {
            comment: "added SVG property",
            references: [
              "https://www.w3.org/TR/SVG/painting.html#FillProperty"
            ],
            syntax: "nonzero | evenodd"
          },
          filter: {
            comment: "extend with IE legacy syntaxes",
            syntax: "| <-ms-filter-function-list>"
          },
          "glyph-orientation-horizontal": {
            comment: "added SVG property",
            references: [
              "https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
            ],
            syntax: "<angle>"
          },
          "glyph-orientation-vertical": {
            comment: "added SVG property",
            references: [
              "https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
            ],
            syntax: "<angle>"
          },
          kerning: {
            comment: "added SVG property",
            references: [
              "https://www.w3.org/TR/SVG/text.html#KerningProperty"
            ],
            syntax: "auto | <svg-length>"
          },
          "letter-spacing": {
            comment: "fix syntax <length> -> <length-percentage>",
            references: [
              "https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
            ],
            syntax: "normal | <length-percentage>"
          },
          marker: {
            comment: "added SVG property",
            references: [
              "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
            ],
            syntax: "none | <url>"
          },
          "marker-end": {
            comment: "added SVG property",
            references: [
              "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
            ],
            syntax: "none | <url>"
          },
          "marker-mid": {
            comment: "added SVG property",
            references: [
              "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
            ],
            syntax: "none | <url>"
          },
          "marker-start": {
            comment: "added SVG property",
            references: [
              "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
            ],
            syntax: "none | <url>"
          },
          "max-width": {
            comment: "fix auto -> none (https://github.com/mdn/data/pull/431); extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
            syntax: "none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>) | <-non-standard-width>"
          },
          width: {
            comment: "per spec fit-content should be a function, however browsers are supporting it as a keyword (https://github.com/csstree/stylelint-validator/issues/29)",
            syntax: "| fit-content | -moz-fit-content | -webkit-fit-content"
          },
          "min-width": {
            comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
            syntax: "auto | <length-percentage> | min-content | max-content | fit-content(<length-percentage>) | <-non-standard-width>"
          },
          overflow: {
            comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
            syntax: "| <-non-standard-overflow>"
          },
          pause: {
            comment: "https://www.w3.org/TR/css3-speech/#property-index",
            syntax: "<'pause-before'> <'pause-after'>?"
          },
          "pause-after": {
            comment: "https://www.w3.org/TR/css3-speech/#property-index",
            syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
          },
          "pause-before": {
            comment: "https://www.w3.org/TR/css3-speech/#property-index",
            syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
          },
          rest: {
            comment: "https://www.w3.org/TR/css3-speech/#property-index",
            syntax: "<'rest-before'> <'rest-after'>?"
          },
          "rest-after": {
            comment: "https://www.w3.org/TR/css3-speech/#property-index",
            syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
          },
          "rest-before": {
            comment: "https://www.w3.org/TR/css3-speech/#property-index",
            syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
          },
          "shape-rendering": {
            comment: "added SVG property",
            references: [
              "https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
            ],
            syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
          },
          src: {
            comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
            syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
          },
          speak: {
            comment: "https://www.w3.org/TR/css3-speech/#property-index",
            syntax: "auto | none | normal"
          },
          "speak-as": {
            comment: "https://www.w3.org/TR/css3-speech/#property-index",
            syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
          },
          stroke: {
            comment: "added SVG property",
            references: [
              "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
            ],
            syntax: "<paint>"
          },
          "stroke-dasharray": {
            comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
            references: [
              "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
            ],
            syntax: "none | [ <svg-length>+ ]#"
          },
          "stroke-dashoffset": {
            comment: "added SVG property",
            references: [
              "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
            ],
            syntax: "<svg-length>"
          },
          "stroke-linecap": {
            comment: "added SVG property",
            references: [
              "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
            ],
            syntax: "butt | round | square"
          },
          "stroke-linejoin": {
            comment: "added SVG property",
            references: [
              "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
            ],
            syntax: "miter | round | bevel"
          },
          "stroke-miterlimit": {
            comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
            references: [
              "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
            ],
            syntax: "<number-one-or-greater>"
          },
          "stroke-opacity": {
            comment: "added SVG property",
            references: [
              "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
            ],
            syntax: "<number-zero-one>"
          },
          "stroke-width": {
            comment: "added SVG property",
            references: [
              "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
            ],
            syntax: "<svg-length>"
          },
          "text-anchor": {
            comment: "added SVG property",
            references: [
              "https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
            ],
            syntax: "start | middle | end"
          },
          "unicode-bidi": {
            comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
            syntax: "| -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate | -webkit-isolate-override | -webkit-plaintext"
          },
          "unicode-range": {
            comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
            syntax: "<urange>#"
          },
          "voice-balance": {
            comment: "https://www.w3.org/TR/css3-speech/#property-index",
            syntax: "<number> | left | center | right | leftwards | rightwards"
          },
          "voice-duration": {
            comment: "https://www.w3.org/TR/css3-speech/#property-index",
            syntax: "auto | <time>"
          },
          "voice-family": {
            comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
            syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
          },
          "voice-pitch": {
            comment: "https://www.w3.org/TR/css3-speech/#property-index",
            syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
          },
          "voice-range": {
            comment: "https://www.w3.org/TR/css3-speech/#property-index",
            syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
          },
          "voice-rate": {
            comment: "https://www.w3.org/TR/css3-speech/#property-index",
            syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
          },
          "voice-stress": {
            comment: "https://www.w3.org/TR/css3-speech/#property-index",
            syntax: "normal | strong | moderate | none | reduced"
          },
          "voice-volume": {
            comment: "https://www.w3.org/TR/css3-speech/#property-index",
            syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
          },
          "writing-mode": {
            comment: "extend with SVG keywords",
            syntax: "| <svg-writing-mode>"
          }
        },
        syntaxes: {
          "-legacy-gradient": {
            comment: "added collection of legacy gradient syntaxes",
            syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
          },
          "-legacy-linear-gradient": {
            comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
            syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
          },
          "-legacy-repeating-linear-gradient": {
            comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
            syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
          },
          "-legacy-linear-gradient-arguments": {
            comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
            syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
          },
          "-legacy-radial-gradient": {
            comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
            syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
          },
          "-legacy-repeating-radial-gradient": {
            comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
            syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
          },
          "-legacy-radial-gradient-arguments": {
            comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
            syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
          },
          "-legacy-radial-gradient-size": {
            comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
            syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
          },
          "-legacy-radial-gradient-shape": {
            comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
            syntax: "circle | ellipse"
          },
          "-non-standard-font": {
            comment: "non standard fonts",
            references: [
              "https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
            ],
            syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
          },
          "-non-standard-color": {
            comment: "non standard colors",
            references: [
              "http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
              "https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
            ],
            syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
          },
          "-non-standard-image-rendering": {
            comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
            syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
          },
          "-non-standard-overflow": {
            comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
            syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
          },
          "-non-standard-width": {
            comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
            syntax: "fill-available | min-intrinsic | intrinsic | -moz-available | -moz-fit-content | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
          },
          "-webkit-gradient()": {
            comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
            syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
          },
          "-webkit-gradient-color-stop": {
            comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
            syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
          },
          "-webkit-gradient-point": {
            comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
            syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
          },
          "-webkit-gradient-radius": {
            comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
            syntax: "<length> | <percentage>"
          },
          "-webkit-gradient-type": {
            comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
            syntax: "linear | radial"
          },
          "-webkit-mask-box-repeat": {
            comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
            syntax: "repeat | stretch | round"
          },
          "-webkit-mask-clip-style": {
            comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
            syntax: "border | border-box | padding | padding-box | content | content-box | text"
          },
          "-ms-filter-function-list": {
            comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
            syntax: "<-ms-filter-function>+"
          },
          "-ms-filter-function": {
            comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
            syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
          },
          "-ms-filter-function-progid": {
            comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
            syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
          },
          "-ms-filter-function-legacy": {
            comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
            syntax: "<ident-token> | <function-token> <any-value>? )"
          },
          "-ms-filter": {
            syntax: "<string>"
          },
          age: {
            comment: "https://www.w3.org/TR/css3-speech/#voice-family",
            syntax: "child | young | old"
          },
          "attr-name": {
            syntax: "<wq-name>"
          },
          "attr-fallback": {
            syntax: "<any-value>"
          },
          "border-radius": {
            comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
            syntax: "<length-percentage>{1,2}"
          },
          bottom: {
            comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
            syntax: "<length> | auto"
          },
          "content-list": {
            comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
            syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
          },
          "element()": {
            comment: "https://drafts.csswg.org/css-gcpm/#element-syntax & https://drafts.csswg.org/css-images-4/#element-notation",
            syntax: "element( <custom-ident> , [ first | start | last | first-except ]? ) | element( <id-selector> )"
          },
          "generic-voice": {
            comment: "https://www.w3.org/TR/css3-speech/#voice-family",
            syntax: "[ <age>? <gender> <integer>? ]"
          },
          gender: {
            comment: "https://www.w3.org/TR/css3-speech/#voice-family",
            syntax: "male | female | neutral"
          },
          "generic-family": {
            comment: "added -apple-system",
            references: [
              "https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
            ],
            syntax: "| -apple-system"
          },
          gradient: {
            comment: "added legacy syntaxes support",
            syntax: "| <-legacy-gradient>"
          },
          left: {
            comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
            syntax: "<length> | auto"
          },
          "mask-image": {
            comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
            syntax: "<mask-reference>#"
          },
          "name-repeat": {
            comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
            syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
          },
          "named-color": {
            comment: "added non standard color names",
            syntax: "| <-non-standard-color>"
          },
          paint: {
            comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
            syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
          },
          "page-size": {
            comment: "https://www.w3.org/TR/css-page-3/#typedef-page-size-page-size",
            syntax: "A5 | A4 | A3 | B5 | B4 | JIS-B5 | JIS-B4 | letter | legal | ledger"
          },
          ratio: {
            comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
            syntax: "<integer> / <integer>"
          },
          right: {
            comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
            syntax: "<length> | auto"
          },
          shape: {
            comment: "missed spaces in function body and add backwards compatible syntax",
            syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
          },
          "svg-length": {
            comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
            references: [
              "https://www.w3.org/TR/SVG11/coords.html#Units"
            ],
            syntax: "<percentage> | <length> | <number>"
          },
          "svg-writing-mode": {
            comment: "SVG specific keywords (deprecated for CSS)",
            references: [
              "https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
              "https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
            ],
            syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
          },
          top: {
            comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
            syntax: "<length> | auto"
          },
          "track-group": {
            comment: "used by old grid-columns and grid-rows syntax v0",
            syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
          },
          "track-list-v0": {
            comment: "used by old grid-columns and grid-rows syntax v0",
            syntax: "[ <string>* <track-group> <string>* ]+ | none"
          },
          "track-minmax": {
            comment: "used by old grid-columns and grid-rows syntax v0",
            syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
          },
          x: {
            comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
            syntax: "<number>"
          },
          y: {
            comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
            syntax: "<number>"
          },
          declaration: {
            comment: "missed, restored by https://drafts.csswg.org/css-syntax",
            syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
          },
          "declaration-list": {
            comment: "missed, restored by https://drafts.csswg.org/css-syntax",
            syntax: "[ <declaration>? ';' ]* <declaration>?"
          },
          url: {
            comment: "https://drafts.csswg.org/css-values-4/#urls",
            syntax: "url( <string> <url-modifier>* ) | <url-token>"
          },
          "url-modifier": {
            comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
            syntax: "<ident> | <function-token> <any-value> )"
          },
          "number-zero-one": {
            syntax: "<number [0,1]>"
          },
          "number-one-or-greater": {
            syntax: "<number [1,\u221E]>"
          },
          "positive-integer": {
            syntax: "<integer [0,\u221E]>"
          },
          "-non-standard-display": {
            syntax: "-ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
          }
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/data/index.js
  var require_data = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/data/index.js"(exports, module) {
      var mdnAtrules = require_at_rules();
      var mdnProperties = require_properties();
      var mdnSyntaxes = require_syntaxes();
      var patch = require_patch();
      var extendSyntax = /^\s*\|\s*/;
      function preprocessAtrules(dict) {
        const result = /* @__PURE__ */ Object.create(null);
        for (const atruleName in dict) {
          const atrule = dict[atruleName];
          let descriptors = null;
          if (atrule.descriptors) {
            descriptors = /* @__PURE__ */ Object.create(null);
            for (const descriptor in atrule.descriptors) {
              descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
            }
          }
          result[atruleName.substr(1)] = {
            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
            descriptors
          };
        }
        return result;
      }
      function patchDictionary(dict, patchDict) {
        const result = {};
        for (const key in dict) {
          result[key] = dict[key].syntax || dict[key];
        }
        for (const key in patchDict) {
          if (key in dict) {
            if (patchDict[key].syntax) {
              result[key] = extendSyntax.test(patchDict[key].syntax) ? result[key] + " " + patchDict[key].syntax.trim() : patchDict[key].syntax;
            } else {
              delete result[key];
            }
          } else {
            if (patchDict[key].syntax) {
              result[key] = patchDict[key].syntax.replace(extendSyntax, "");
            }
          }
        }
        return result;
      }
      function unpackSyntaxes(dict) {
        const result = {};
        for (const key in dict) {
          result[key] = dict[key].syntax;
        }
        return result;
      }
      function patchAtrules(dict, patchDict) {
        const result = {};
        for (const key in dict) {
          const patchDescriptors = patchDict[key] && patchDict[key].descriptors || null;
          result[key] = {
            prelude: key in patchDict && "prelude" in patchDict[key] ? patchDict[key].prelude : dict[key].prelude || null,
            descriptors: dict[key].descriptors ? patchDictionary(dict[key].descriptors, patchDescriptors || {}) : patchDescriptors && unpackSyntaxes(patchDescriptors)
          };
        }
        for (const key in patchDict) {
          if (!hasOwnProperty.call(dict, key)) {
            result[key] = {
              prelude: patchDict[key].prelude || null,
              descriptors: patchDict[key].descriptors && unpackSyntaxes(patchDict[key].descriptors)
            };
          }
        }
        return result;
      }
      module.exports = {
        types: patchDictionary(mdnSyntaxes, patch.syntaxes),
        atrules: patchAtrules(preprocessAtrules(mdnAtrules), patch.atrules),
        properties: patchDictionary(mdnProperties, patch.properties)
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/AnPlusB.js
  var require_AnPlusB = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/AnPlusB.js"(exports, module) {
      var cmpChar = require_tokenizer().cmpChar;
      var isDigit = require_tokenizer().isDigit;
      var TYPE = require_tokenizer().TYPE;
      var WHITESPACE = TYPE.WhiteSpace;
      var COMMENT = TYPE.Comment;
      var IDENT = TYPE.Ident;
      var NUMBER = TYPE.Number;
      var DIMENSION = TYPE.Dimension;
      var PLUSSIGN = 43;
      var HYPHENMINUS = 45;
      var N = 110;
      var DISALLOW_SIGN = true;
      var ALLOW_SIGN = false;
      function checkInteger(offset, disallowSign) {
        var pos = this.scanner.tokenStart + offset;
        var code = this.scanner.source.charCodeAt(pos);
        if (code === PLUSSIGN || code === HYPHENMINUS) {
          if (disallowSign) {
            this.error("Number sign is not allowed");
          }
          pos++;
        }
        for (; pos < this.scanner.tokenEnd; pos++) {
          if (!isDigit(this.scanner.source.charCodeAt(pos))) {
            this.error("Integer is expected", pos);
          }
        }
      }
      function checkTokenIsInteger(disallowSign) {
        return checkInteger.call(this, 0, disallowSign);
      }
      function expectCharCode(offset, code) {
        if (!cmpChar(this.scanner.source, this.scanner.tokenStart + offset, code)) {
          var msg = "";
          switch (code) {
            case N:
              msg = "N is expected";
              break;
            case HYPHENMINUS:
              msg = "HyphenMinus is expected";
              break;
          }
          this.error(msg, this.scanner.tokenStart + offset);
        }
      }
      function consumeB() {
        var offset = 0;
        var sign = 0;
        var type = this.scanner.tokenType;
        while (type === WHITESPACE || type === COMMENT) {
          type = this.scanner.lookupType(++offset);
        }
        if (type !== NUMBER) {
          if (this.scanner.isDelim(PLUSSIGN, offset) || this.scanner.isDelim(HYPHENMINUS, offset)) {
            sign = this.scanner.isDelim(PLUSSIGN, offset) ? PLUSSIGN : HYPHENMINUS;
            do {
              type = this.scanner.lookupType(++offset);
            } while (type === WHITESPACE || type === COMMENT);
            if (type !== NUMBER) {
              this.scanner.skip(offset);
              checkTokenIsInteger.call(this, DISALLOW_SIGN);
            }
          } else {
            return null;
          }
        }
        if (offset > 0) {
          this.scanner.skip(offset);
        }
        if (sign === 0) {
          type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
          if (type !== PLUSSIGN && type !== HYPHENMINUS) {
            this.error("Number sign is expected");
          }
        }
        checkTokenIsInteger.call(this, sign !== 0);
        return sign === HYPHENMINUS ? "-" + this.consume(NUMBER) : this.consume(NUMBER);
      }
      module.exports = {
        name: "AnPlusB",
        structure: {
          a: [String, null],
          b: [String, null]
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var a = null;
          var b = null;
          if (this.scanner.tokenType === NUMBER) {
            checkTokenIsInteger.call(this, ALLOW_SIGN);
            b = this.consume(NUMBER);
          } else if (this.scanner.tokenType === IDENT && cmpChar(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS)) {
            a = "-1";
            expectCharCode.call(this, 1, N);
            switch (this.scanner.getTokenLength()) {
              case 2:
                this.scanner.next();
                b = consumeB.call(this);
                break;
              case 3:
                expectCharCode.call(this, 2, HYPHENMINUS);
                this.scanner.next();
                this.scanner.skipSC();
                checkTokenIsInteger.call(this, DISALLOW_SIGN);
                b = "-" + this.consume(NUMBER);
                break;
              default:
                expectCharCode.call(this, 2, HYPHENMINUS);
                checkInteger.call(this, 3, DISALLOW_SIGN);
                this.scanner.next();
                b = this.scanner.substrToCursor(start + 2);
            }
          } else if (this.scanner.tokenType === IDENT || this.scanner.isDelim(PLUSSIGN) && this.scanner.lookupType(1) === IDENT) {
            var sign = 0;
            a = "1";
            if (this.scanner.isDelim(PLUSSIGN)) {
              sign = 1;
              this.scanner.next();
            }
            expectCharCode.call(this, 0, N);
            switch (this.scanner.getTokenLength()) {
              case 1:
                this.scanner.next();
                b = consumeB.call(this);
                break;
              case 2:
                expectCharCode.call(this, 1, HYPHENMINUS);
                this.scanner.next();
                this.scanner.skipSC();
                checkTokenIsInteger.call(this, DISALLOW_SIGN);
                b = "-" + this.consume(NUMBER);
                break;
              default:
                expectCharCode.call(this, 1, HYPHENMINUS);
                checkInteger.call(this, 2, DISALLOW_SIGN);
                this.scanner.next();
                b = this.scanner.substrToCursor(start + sign + 1);
            }
          } else if (this.scanner.tokenType === DIMENSION) {
            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
            var sign = code === PLUSSIGN || code === HYPHENMINUS;
            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
              if (!isDigit(this.scanner.source.charCodeAt(i))) {
                break;
              }
            }
            if (i === this.scanner.tokenStart + sign) {
              this.error("Integer is expected", this.scanner.tokenStart + sign);
            }
            expectCharCode.call(this, i - this.scanner.tokenStart, N);
            a = this.scanner.source.substring(start, i);
            if (i + 1 === this.scanner.tokenEnd) {
              this.scanner.next();
              b = consumeB.call(this);
            } else {
              expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS);
              if (i + 2 === this.scanner.tokenEnd) {
                this.scanner.next();
                this.scanner.skipSC();
                checkTokenIsInteger.call(this, DISALLOW_SIGN);
                b = "-" + this.consume(NUMBER);
              } else {
                checkInteger.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN);
                this.scanner.next();
                b = this.scanner.substrToCursor(i + 1);
              }
            }
          } else {
            this.error();
          }
          if (a !== null && a.charCodeAt(0) === PLUSSIGN) {
            a = a.substr(1);
          }
          if (b !== null && b.charCodeAt(0) === PLUSSIGN) {
            b = b.substr(1);
          }
          return {
            type: "AnPlusB",
            loc: this.getLocation(start, this.scanner.tokenStart),
            a,
            b
          };
        },
        generate: function(node) {
          var a = node.a !== null && node.a !== void 0;
          var b = node.b !== null && node.b !== void 0;
          if (a) {
            this.chunk(
              node.a === "+1" ? "+n" : (
                // eslint-disable-line operator-linebreak, indent
                node.a === "1" ? "n" : (
                  // eslint-disable-line operator-linebreak, indent
                  node.a === "-1" ? "-n" : (
                    // eslint-disable-line operator-linebreak, indent
                    node.a + "n"
                  )
                )
              )
              // eslint-disable-line operator-linebreak, indent
            );
            if (b) {
              b = String(node.b);
              if (b.charAt(0) === "-" || b.charAt(0) === "+") {
                this.chunk(b.charAt(0));
                this.chunk(b.substr(1));
              } else {
                this.chunk("+");
                this.chunk(b);
              }
            }
          } else {
            this.chunk(String(node.b));
          }
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Raw.js
  var require_Raw = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Raw.js"(exports, module) {
      var tokenizer = require_tokenizer();
      var TYPE = tokenizer.TYPE;
      var WhiteSpace = TYPE.WhiteSpace;
      var Semicolon = TYPE.Semicolon;
      var LeftCurlyBracket = TYPE.LeftCurlyBracket;
      var Delim = TYPE.Delim;
      var EXCLAMATIONMARK = 33;
      function getOffsetExcludeWS() {
        if (this.scanner.tokenIndex > 0) {
          if (this.scanner.lookupType(-1) === WhiteSpace) {
            return this.scanner.tokenIndex > 1 ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1) : this.scanner.firstCharOffset;
          }
        }
        return this.scanner.tokenStart;
      }
      function balanceEnd() {
        return 0;
      }
      function leftCurlyBracket(tokenType) {
        return tokenType === LeftCurlyBracket ? 1 : 0;
      }
      function leftCurlyBracketOrSemicolon(tokenType) {
        return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
      }
      function exclamationMarkOrSemicolon(tokenType, source, offset) {
        if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK) {
          return 1;
        }
        return tokenType === Semicolon ? 1 : 0;
      }
      function semicolonIncluded(tokenType) {
        return tokenType === Semicolon ? 2 : 0;
      }
      module.exports = {
        name: "Raw",
        structure: {
          value: String
        },
        parse: function(startToken, mode, excludeWhiteSpace) {
          var startOffset = this.scanner.getTokenStart(startToken);
          var endOffset;
          this.scanner.skip(
            this.scanner.getRawLength(startToken, mode || balanceEnd)
          );
          if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
            endOffset = getOffsetExcludeWS.call(this);
          } else {
            endOffset = this.scanner.tokenStart;
          }
          return {
            type: "Raw",
            loc: this.getLocation(startOffset, endOffset),
            value: this.scanner.source.substring(startOffset, endOffset)
          };
        },
        generate: function(node) {
          this.chunk(node.value);
        },
        mode: {
          default: balanceEnd,
          leftCurlyBracket,
          leftCurlyBracketOrSemicolon,
          exclamationMarkOrSemicolon,
          semicolonIncluded
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Atrule.js
  var require_Atrule = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Atrule.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var rawMode = require_Raw().mode;
      var ATKEYWORD = TYPE.AtKeyword;
      var SEMICOLON = TYPE.Semicolon;
      var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
      var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;
      function consumeRaw(startToken) {
        return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
      }
      function isDeclarationBlockAtrule() {
        for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
          if (type === RIGHTCURLYBRACKET) {
            return true;
          }
          if (type === LEFTCURLYBRACKET || type === ATKEYWORD) {
            return false;
          }
        }
        return false;
      }
      module.exports = {
        name: "Atrule",
        structure: {
          name: String,
          prelude: ["AtrulePrelude", "Raw", null],
          block: ["Block", null]
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var name;
          var nameLowerCase;
          var prelude = null;
          var block = null;
          this.eat(ATKEYWORD);
          name = this.scanner.substrToCursor(start + 1);
          nameLowerCase = name.toLowerCase();
          this.scanner.skipSC();
          if (this.scanner.eof === false && this.scanner.tokenType !== LEFTCURLYBRACKET && this.scanner.tokenType !== SEMICOLON) {
            if (this.parseAtrulePrelude) {
              prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);
              if (prelude.type === "AtrulePrelude" && prelude.children.head === null) {
                prelude = null;
              }
            } else {
              prelude = consumeRaw.call(this, this.scanner.tokenIndex);
            }
            this.scanner.skipSC();
          }
          switch (this.scanner.tokenType) {
            case SEMICOLON:
              this.scanner.next();
              break;
            case LEFTCURLYBRACKET:
              if (this.atrule.hasOwnProperty(nameLowerCase) && typeof this.atrule[nameLowerCase].block === "function") {
                block = this.atrule[nameLowerCase].block.call(this);
              } else {
                block = this.Block(isDeclarationBlockAtrule.call(this));
              }
              break;
          }
          return {
            type: "Atrule",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name,
            prelude,
            block
          };
        },
        generate: function(node) {
          this.chunk("@");
          this.chunk(node.name);
          if (node.prelude !== null) {
            this.chunk(" ");
            this.node(node.prelude);
          }
          if (node.block) {
            this.node(node.block);
          } else {
            this.chunk(";");
          }
        },
        walkContext: "atrule"
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/AtrulePrelude.js
  var require_AtrulePrelude = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/AtrulePrelude.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var SEMICOLON = TYPE.Semicolon;
      var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
      module.exports = {
        name: "AtrulePrelude",
        structure: {
          children: [[]]
        },
        parse: function(name) {
          var children = null;
          if (name !== null) {
            name = name.toLowerCase();
          }
          this.scanner.skipSC();
          if (this.atrule.hasOwnProperty(name) && typeof this.atrule[name].prelude === "function") {
            children = this.atrule[name].prelude.call(this);
          } else {
            children = this.readSequence(this.scope.AtrulePrelude);
          }
          this.scanner.skipSC();
          if (this.scanner.eof !== true && this.scanner.tokenType !== LEFTCURLYBRACKET && this.scanner.tokenType !== SEMICOLON) {
            this.error("Semicolon or block is expected");
          }
          if (children === null) {
            children = this.createList();
          }
          return {
            type: "AtrulePrelude",
            loc: this.getLocationFromList(children),
            children
          };
        },
        generate: function(node) {
          this.children(node);
        },
        walkContext: "atrulePrelude"
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/AttributeSelector.js
  var require_AttributeSelector = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/AttributeSelector.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var IDENT = TYPE.Ident;
      var STRING = TYPE.String;
      var COLON = TYPE.Colon;
      var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
      var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;
      var DOLLARSIGN = 36;
      var ASTERISK = 42;
      var EQUALSSIGN = 61;
      var CIRCUMFLEXACCENT = 94;
      var VERTICALLINE = 124;
      var TILDE = 126;
      function getAttributeName() {
        if (this.scanner.eof) {
          this.error("Unexpected end of input");
        }
        var start = this.scanner.tokenStart;
        var expectIdent = false;
        var checkColon = true;
        if (this.scanner.isDelim(ASTERISK)) {
          expectIdent = true;
          checkColon = false;
          this.scanner.next();
        } else if (!this.scanner.isDelim(VERTICALLINE)) {
          this.eat(IDENT);
        }
        if (this.scanner.isDelim(VERTICALLINE)) {
          if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
            this.scanner.next();
            this.eat(IDENT);
          } else if (expectIdent) {
            this.error("Identifier is expected", this.scanner.tokenEnd);
          }
        } else if (expectIdent) {
          this.error("Vertical line is expected");
        }
        if (checkColon && this.scanner.tokenType === COLON) {
          this.scanner.next();
          this.eat(IDENT);
        }
        return {
          type: "Identifier",
          loc: this.getLocation(start, this.scanner.tokenStart),
          name: this.scanner.substrToCursor(start)
        };
      }
      function getOperator() {
        var start = this.scanner.tokenStart;
        var code = this.scanner.source.charCodeAt(start);
        if (code !== EQUALSSIGN && // =
        code !== TILDE && // ~=
        code !== CIRCUMFLEXACCENT && // ^=
        code !== DOLLARSIGN && // $=
        code !== ASTERISK && // *=
        code !== VERTICALLINE) {
          this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
        }
        this.scanner.next();
        if (code !== EQUALSSIGN) {
          if (!this.scanner.isDelim(EQUALSSIGN)) {
            this.error("Equal sign is expected");
          }
          this.scanner.next();
        }
        return this.scanner.substrToCursor(start);
      }
      module.exports = {
        name: "AttributeSelector",
        structure: {
          name: "Identifier",
          matcher: [String, null],
          value: ["String", "Identifier", null],
          flags: [String, null]
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var name;
          var matcher = null;
          var value = null;
          var flags = null;
          this.eat(LEFTSQUAREBRACKET);
          this.scanner.skipSC();
          name = getAttributeName.call(this);
          this.scanner.skipSC();
          if (this.scanner.tokenType !== RIGHTSQUAREBRACKET) {
            if (this.scanner.tokenType !== IDENT) {
              matcher = getOperator.call(this);
              this.scanner.skipSC();
              value = this.scanner.tokenType === STRING ? this.String() : this.Identifier();
              this.scanner.skipSC();
            }
            if (this.scanner.tokenType === IDENT) {
              flags = this.scanner.getTokenValue();
              this.scanner.next();
              this.scanner.skipSC();
            }
          }
          this.eat(RIGHTSQUAREBRACKET);
          return {
            type: "AttributeSelector",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name,
            matcher,
            value,
            flags
          };
        },
        generate: function(node) {
          var flagsPrefix = " ";
          this.chunk("[");
          this.node(node.name);
          if (node.matcher !== null) {
            this.chunk(node.matcher);
            if (node.value !== null) {
              this.node(node.value);
              if (node.value.type === "String") {
                flagsPrefix = "";
              }
            }
          }
          if (node.flags !== null) {
            this.chunk(flagsPrefix);
            this.chunk(node.flags);
          }
          this.chunk("]");
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Block.js
  var require_Block = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Block.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var rawMode = require_Raw().mode;
      var WHITESPACE = TYPE.WhiteSpace;
      var COMMENT = TYPE.Comment;
      var SEMICOLON = TYPE.Semicolon;
      var ATKEYWORD = TYPE.AtKeyword;
      var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
      var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;
      function consumeRaw(startToken) {
        return this.Raw(startToken, null, true);
      }
      function consumeRule() {
        return this.parseWithFallback(this.Rule, consumeRaw);
      }
      function consumeRawDeclaration(startToken) {
        return this.Raw(startToken, rawMode.semicolonIncluded, true);
      }
      function consumeDeclaration() {
        if (this.scanner.tokenType === SEMICOLON) {
          return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
        }
        var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);
        if (this.scanner.tokenType === SEMICOLON) {
          this.scanner.next();
        }
        return node;
      }
      module.exports = {
        name: "Block",
        structure: {
          children: [[
            "Atrule",
            "Rule",
            "Declaration"
          ]]
        },
        parse: function(isDeclaration) {
          var consumer = isDeclaration ? consumeDeclaration : consumeRule;
          var start = this.scanner.tokenStart;
          var children = this.createList();
          this.eat(LEFTCURLYBRACKET);
          scan:
            while (!this.scanner.eof) {
              switch (this.scanner.tokenType) {
                case RIGHTCURLYBRACKET:
                  break scan;
                case WHITESPACE:
                case COMMENT:
                  this.scanner.next();
                  break;
                case ATKEYWORD:
                  children.push(this.parseWithFallback(this.Atrule, consumeRaw));
                  break;
                default:
                  children.push(consumer.call(this));
              }
            }
          if (!this.scanner.eof) {
            this.eat(RIGHTCURLYBRACKET);
          }
          return {
            type: "Block",
            loc: this.getLocation(start, this.scanner.tokenStart),
            children
          };
        },
        generate: function(node) {
          this.chunk("{");
          this.children(node, function(prev) {
            if (prev.type === "Declaration") {
              this.chunk(";");
            }
          });
          this.chunk("}");
        },
        walkContext: "block"
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Brackets.js
  var require_Brackets = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Brackets.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
      var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;
      module.exports = {
        name: "Brackets",
        structure: {
          children: [[]]
        },
        parse: function(readSequence, recognizer) {
          var start = this.scanner.tokenStart;
          var children = null;
          this.eat(LEFTSQUAREBRACKET);
          children = readSequence.call(this, recognizer);
          if (!this.scanner.eof) {
            this.eat(RIGHTSQUAREBRACKET);
          }
          return {
            type: "Brackets",
            loc: this.getLocation(start, this.scanner.tokenStart),
            children
          };
        },
        generate: function(node) {
          this.chunk("[");
          this.children(node);
          this.chunk("]");
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/CDC.js
  var require_CDC = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/CDC.js"(exports, module) {
      var CDC = require_tokenizer().TYPE.CDC;
      module.exports = {
        name: "CDC",
        structure: [],
        parse: function() {
          var start = this.scanner.tokenStart;
          this.eat(CDC);
          return {
            type: "CDC",
            loc: this.getLocation(start, this.scanner.tokenStart)
          };
        },
        generate: function() {
          this.chunk("-->");
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/CDO.js
  var require_CDO = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/CDO.js"(exports, module) {
      var CDO = require_tokenizer().TYPE.CDO;
      module.exports = {
        name: "CDO",
        structure: [],
        parse: function() {
          var start = this.scanner.tokenStart;
          this.eat(CDO);
          return {
            type: "CDO",
            loc: this.getLocation(start, this.scanner.tokenStart)
          };
        },
        generate: function() {
          this.chunk("<!--");
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/ClassSelector.js
  var require_ClassSelector = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/ClassSelector.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var IDENT = TYPE.Ident;
      var FULLSTOP = 46;
      module.exports = {
        name: "ClassSelector",
        structure: {
          name: String
        },
        parse: function() {
          if (!this.scanner.isDelim(FULLSTOP)) {
            this.error("Full stop is expected");
          }
          this.scanner.next();
          return {
            type: "ClassSelector",
            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
            name: this.consume(IDENT)
          };
        },
        generate: function(node) {
          this.chunk(".");
          this.chunk(node.name);
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Combinator.js
  var require_Combinator = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Combinator.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var IDENT = TYPE.Ident;
      var PLUSSIGN = 43;
      var SOLIDUS = 47;
      var GREATERTHANSIGN = 62;
      var TILDE = 126;
      module.exports = {
        name: "Combinator",
        structure: {
          name: String
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
          switch (code) {
            case GREATERTHANSIGN:
            case PLUSSIGN:
            case TILDE:
              this.scanner.next();
              break;
            case SOLIDUS:
              this.scanner.next();
              if (this.scanner.tokenType !== IDENT || this.scanner.lookupValue(0, "deep") === false) {
                this.error("Identifier `deep` is expected");
              }
              this.scanner.next();
              if (!this.scanner.isDelim(SOLIDUS)) {
                this.error("Solidus is expected");
              }
              this.scanner.next();
              break;
            default:
              this.error("Combinator is expected");
          }
          return {
            type: "Combinator",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start)
          };
        },
        generate: function(node) {
          this.chunk(node.name);
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Comment.js
  var require_Comment = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Comment.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var COMMENT = TYPE.Comment;
      var ASTERISK = 42;
      var SOLIDUS = 47;
      module.exports = {
        name: "Comment",
        structure: {
          value: String
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var end = this.scanner.tokenEnd;
          this.eat(COMMENT);
          if (end - start + 2 >= 2 && this.scanner.source.charCodeAt(end - 2) === ASTERISK && this.scanner.source.charCodeAt(end - 1) === SOLIDUS) {
            end -= 2;
          }
          return {
            type: "Comment",
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.source.substring(start + 2, end)
          };
        },
        generate: function(node) {
          this.chunk("/*");
          this.chunk(node.value);
          this.chunk("*/");
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Declaration.js
  var require_Declaration = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Declaration.js"(exports, module) {
      var isCustomProperty = require_names().isCustomProperty;
      var TYPE = require_tokenizer().TYPE;
      var rawMode = require_Raw().mode;
      var IDENT = TYPE.Ident;
      var HASH = TYPE.Hash;
      var COLON = TYPE.Colon;
      var SEMICOLON = TYPE.Semicolon;
      var DELIM = TYPE.Delim;
      var WHITESPACE = TYPE.WhiteSpace;
      var EXCLAMATIONMARK = 33;
      var NUMBERSIGN = 35;
      var DOLLARSIGN = 36;
      var AMPERSAND = 38;
      var ASTERISK = 42;
      var PLUSSIGN = 43;
      var SOLIDUS = 47;
      function consumeValueRaw(startToken) {
        return this.Raw(startToken, rawMode.exclamationMarkOrSemicolon, true);
      }
      function consumeCustomPropertyRaw(startToken) {
        return this.Raw(startToken, rawMode.exclamationMarkOrSemicolon, false);
      }
      function consumeValue() {
        var startValueToken = this.scanner.tokenIndex;
        var value = this.Value();
        if (value.type !== "Raw" && this.scanner.eof === false && this.scanner.tokenType !== SEMICOLON && this.scanner.isDelim(EXCLAMATIONMARK) === false && this.scanner.isBalanceEdge(startValueToken) === false) {
          this.error();
        }
        return value;
      }
      module.exports = {
        name: "Declaration",
        structure: {
          important: [Boolean, String],
          property: String,
          value: ["Value", "Raw"]
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var startToken = this.scanner.tokenIndex;
          var property = readProperty.call(this);
          var customProperty = isCustomProperty(property);
          var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
          var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
          var important = false;
          var value;
          this.scanner.skipSC();
          this.eat(COLON);
          const valueStart = this.scanner.tokenIndex;
          if (!customProperty) {
            this.scanner.skipSC();
          }
          if (parseValue) {
            value = this.parseWithFallback(consumeValue, consumeRaw);
          } else {
            value = consumeRaw.call(this, this.scanner.tokenIndex);
          }
          if (customProperty && value.type === "Value" && value.children.isEmpty()) {
            for (let offset = valueStart - this.scanner.tokenIndex; offset <= 0; offset++) {
              if (this.scanner.lookupType(offset) === WHITESPACE) {
                value.children.appendData({
                  type: "WhiteSpace",
                  loc: null,
                  value: " "
                });
                break;
              }
            }
          }
          if (this.scanner.isDelim(EXCLAMATIONMARK)) {
            important = getImportant.call(this);
            this.scanner.skipSC();
          }
          if (this.scanner.eof === false && this.scanner.tokenType !== SEMICOLON && this.scanner.isBalanceEdge(startToken) === false) {
            this.error();
          }
          return {
            type: "Declaration",
            loc: this.getLocation(start, this.scanner.tokenStart),
            important,
            property,
            value
          };
        },
        generate: function(node) {
          this.chunk(node.property);
          this.chunk(":");
          this.node(node.value);
          if (node.important) {
            this.chunk(node.important === true ? "!important" : "!" + node.important);
          }
        },
        walkContext: "declaration"
      };
      function readProperty() {
        var start = this.scanner.tokenStart;
        var prefix = 0;
        if (this.scanner.tokenType === DELIM) {
          switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
            case ASTERISK:
            case DOLLARSIGN:
            case PLUSSIGN:
            case NUMBERSIGN:
            case AMPERSAND:
              this.scanner.next();
              break;
            case SOLIDUS:
              this.scanner.next();
              if (this.scanner.isDelim(SOLIDUS)) {
                this.scanner.next();
              }
              break;
          }
        }
        if (prefix) {
          this.scanner.skip(prefix);
        }
        if (this.scanner.tokenType === HASH) {
          this.eat(HASH);
        } else {
          this.eat(IDENT);
        }
        return this.scanner.substrToCursor(start);
      }
      function getImportant() {
        this.eat(DELIM);
        this.scanner.skipSC();
        var important = this.consume(IDENT);
        return important === "important" ? true : important;
      }
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/DeclarationList.js
  var require_DeclarationList = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/DeclarationList.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var rawMode = require_Raw().mode;
      var WHITESPACE = TYPE.WhiteSpace;
      var COMMENT = TYPE.Comment;
      var SEMICOLON = TYPE.Semicolon;
      function consumeRaw(startToken) {
        return this.Raw(startToken, rawMode.semicolonIncluded, true);
      }
      module.exports = {
        name: "DeclarationList",
        structure: {
          children: [[
            "Declaration"
          ]]
        },
        parse: function() {
          var children = this.createList();
          scan:
            while (!this.scanner.eof) {
              switch (this.scanner.tokenType) {
                case WHITESPACE:
                case COMMENT:
                case SEMICOLON:
                  this.scanner.next();
                  break;
                default:
                  children.push(this.parseWithFallback(this.Declaration, consumeRaw));
              }
            }
          return {
            type: "DeclarationList",
            loc: this.getLocationFromList(children),
            children
          };
        },
        generate: function(node) {
          this.children(node, function(prev) {
            if (prev.type === "Declaration") {
              this.chunk(";");
            }
          });
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Dimension.js
  var require_Dimension = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Dimension.js"(exports, module) {
      var consumeNumber = require_utils().consumeNumber;
      var TYPE = require_tokenizer().TYPE;
      var DIMENSION = TYPE.Dimension;
      module.exports = {
        name: "Dimension",
        structure: {
          value: String,
          unit: String
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var numberEnd = consumeNumber(this.scanner.source, start);
          this.eat(DIMENSION);
          return {
            type: "Dimension",
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.source.substring(start, numberEnd),
            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
          };
        },
        generate: function(node) {
          this.chunk(node.value);
          this.chunk(node.unit);
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Function.js
  var require_Function = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Function.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var RIGHTPARENTHESIS = TYPE.RightParenthesis;
      module.exports = {
        name: "Function",
        structure: {
          name: String,
          children: [[]]
        },
        parse: function(readSequence, recognizer) {
          var start = this.scanner.tokenStart;
          var name = this.consumeFunctionName();
          var nameLowerCase = name.toLowerCase();
          var children;
          children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence.call(this, recognizer);
          if (!this.scanner.eof) {
            this.eat(RIGHTPARENTHESIS);
          }
          return {
            type: "Function",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name,
            children
          };
        },
        generate: function(node) {
          this.chunk(node.name);
          this.chunk("(");
          this.children(node);
          this.chunk(")");
        },
        walkContext: "function"
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Hash.js
  var require_Hash = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Hash.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var HASH = TYPE.Hash;
      module.exports = {
        name: "Hash",
        structure: {
          value: String
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          this.eat(HASH);
          return {
            type: "Hash",
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start + 1)
          };
        },
        generate: function(node) {
          this.chunk("#");
          this.chunk(node.value);
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Identifier.js
  var require_Identifier = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Identifier.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var IDENT = TYPE.Ident;
      module.exports = {
        name: "Identifier",
        structure: {
          name: String
        },
        parse: function() {
          return {
            type: "Identifier",
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            name: this.consume(IDENT)
          };
        },
        generate: function(node) {
          this.chunk(node.name);
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/IdSelector.js
  var require_IdSelector = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/IdSelector.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var HASH = TYPE.Hash;
      module.exports = {
        name: "IdSelector",
        structure: {
          name: String
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          this.eat(HASH);
          return {
            type: "IdSelector",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start + 1)
          };
        },
        generate: function(node) {
          this.chunk("#");
          this.chunk(node.name);
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/MediaFeature.js
  var require_MediaFeature = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/MediaFeature.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var IDENT = TYPE.Ident;
      var NUMBER = TYPE.Number;
      var DIMENSION = TYPE.Dimension;
      var LEFTPARENTHESIS = TYPE.LeftParenthesis;
      var RIGHTPARENTHESIS = TYPE.RightParenthesis;
      var COLON = TYPE.Colon;
      var DELIM = TYPE.Delim;
      module.exports = {
        name: "MediaFeature",
        structure: {
          name: String,
          value: ["Identifier", "Number", "Dimension", "Ratio", null]
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var name;
          var value = null;
          this.eat(LEFTPARENTHESIS);
          this.scanner.skipSC();
          name = this.consume(IDENT);
          this.scanner.skipSC();
          if (this.scanner.tokenType !== RIGHTPARENTHESIS) {
            this.eat(COLON);
            this.scanner.skipSC();
            switch (this.scanner.tokenType) {
              case NUMBER:
                if (this.lookupNonWSType(1) === DELIM) {
                  value = this.Ratio();
                } else {
                  value = this.Number();
                }
                break;
              case DIMENSION:
                value = this.Dimension();
                break;
              case IDENT:
                value = this.Identifier();
                break;
              default:
                this.error("Number, dimension, ratio or identifier is expected");
            }
            this.scanner.skipSC();
          }
          this.eat(RIGHTPARENTHESIS);
          return {
            type: "MediaFeature",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name,
            value
          };
        },
        generate: function(node) {
          this.chunk("(");
          this.chunk(node.name);
          if (node.value !== null) {
            this.chunk(":");
            this.node(node.value);
          }
          this.chunk(")");
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/MediaQuery.js
  var require_MediaQuery = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/MediaQuery.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var WHITESPACE = TYPE.WhiteSpace;
      var COMMENT = TYPE.Comment;
      var IDENT = TYPE.Ident;
      var LEFTPARENTHESIS = TYPE.LeftParenthesis;
      module.exports = {
        name: "MediaQuery",
        structure: {
          children: [[
            "Identifier",
            "MediaFeature",
            "WhiteSpace"
          ]]
        },
        parse: function() {
          this.scanner.skipSC();
          var children = this.createList();
          var child2 = null;
          var space = null;
          scan:
            while (!this.scanner.eof) {
              switch (this.scanner.tokenType) {
                case COMMENT:
                  this.scanner.next();
                  continue;
                case WHITESPACE:
                  space = this.WhiteSpace();
                  continue;
                case IDENT:
                  child2 = this.Identifier();
                  break;
                case LEFTPARENTHESIS:
                  child2 = this.MediaFeature();
                  break;
                default:
                  break scan;
              }
              if (space !== null) {
                children.push(space);
                space = null;
              }
              children.push(child2);
            }
          if (child2 === null) {
            this.error("Identifier or parenthesis is expected");
          }
          return {
            type: "MediaQuery",
            loc: this.getLocationFromList(children),
            children
          };
        },
        generate: function(node) {
          this.children(node);
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/MediaQueryList.js
  var require_MediaQueryList = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/MediaQueryList.js"(exports, module) {
      var COMMA = require_tokenizer().TYPE.Comma;
      module.exports = {
        name: "MediaQueryList",
        structure: {
          children: [[
            "MediaQuery"
          ]]
        },
        parse: function(relative) {
          var children = this.createList();
          this.scanner.skipSC();
          while (!this.scanner.eof) {
            children.push(this.MediaQuery(relative));
            if (this.scanner.tokenType !== COMMA) {
              break;
            }
            this.scanner.next();
          }
          return {
            type: "MediaQueryList",
            loc: this.getLocationFromList(children),
            children
          };
        },
        generate: function(node) {
          this.children(node, function() {
            this.chunk(",");
          });
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Nth.js
  var require_Nth = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Nth.js"(exports, module) {
      module.exports = {
        name: "Nth",
        structure: {
          nth: ["AnPlusB", "Identifier"],
          selector: ["SelectorList", null]
        },
        parse: function(allowOfClause) {
          this.scanner.skipSC();
          var start = this.scanner.tokenStart;
          var end = start;
          var selector = null;
          var query;
          if (this.scanner.lookupValue(0, "odd") || this.scanner.lookupValue(0, "even")) {
            query = this.Identifier();
          } else {
            query = this.AnPlusB();
          }
          this.scanner.skipSC();
          if (allowOfClause && this.scanner.lookupValue(0, "of")) {
            this.scanner.next();
            selector = this.SelectorList();
            if (this.needPositions) {
              end = this.getLastListNode(selector.children).loc.end.offset;
            }
          } else {
            if (this.needPositions) {
              end = query.loc.end.offset;
            }
          }
          return {
            type: "Nth",
            loc: this.getLocation(start, end),
            nth: query,
            selector
          };
        },
        generate: function(node) {
          this.node(node.nth);
          if (node.selector !== null) {
            this.chunk(" of ");
            this.node(node.selector);
          }
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Number.js
  var require_Number = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Number.js"(exports, module) {
      var NUMBER = require_tokenizer().TYPE.Number;
      module.exports = {
        name: "Number",
        structure: {
          value: String
        },
        parse: function() {
          return {
            type: "Number",
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            value: this.consume(NUMBER)
          };
        },
        generate: function(node) {
          this.chunk(node.value);
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Operator.js
  var require_Operator = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Operator.js"(exports, module) {
      module.exports = {
        name: "Operator",
        structure: {
          value: String
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          this.scanner.next();
          return {
            type: "Operator",
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start)
          };
        },
        generate: function(node) {
          this.chunk(node.value);
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Parentheses.js
  var require_Parentheses = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Parentheses.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var LEFTPARENTHESIS = TYPE.LeftParenthesis;
      var RIGHTPARENTHESIS = TYPE.RightParenthesis;
      module.exports = {
        name: "Parentheses",
        structure: {
          children: [[]]
        },
        parse: function(readSequence, recognizer) {
          var start = this.scanner.tokenStart;
          var children = null;
          this.eat(LEFTPARENTHESIS);
          children = readSequence.call(this, recognizer);
          if (!this.scanner.eof) {
            this.eat(RIGHTPARENTHESIS);
          }
          return {
            type: "Parentheses",
            loc: this.getLocation(start, this.scanner.tokenStart),
            children
          };
        },
        generate: function(node) {
          this.chunk("(");
          this.children(node);
          this.chunk(")");
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Percentage.js
  var require_Percentage = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Percentage.js"(exports, module) {
      var consumeNumber = require_utils().consumeNumber;
      var TYPE = require_tokenizer().TYPE;
      var PERCENTAGE = TYPE.Percentage;
      module.exports = {
        name: "Percentage",
        structure: {
          value: String
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var numberEnd = consumeNumber(this.scanner.source, start);
          this.eat(PERCENTAGE);
          return {
            type: "Percentage",
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.source.substring(start, numberEnd)
          };
        },
        generate: function(node) {
          this.chunk(node.value);
          this.chunk("%");
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/PseudoClassSelector.js
  var require_PseudoClassSelector = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/PseudoClassSelector.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var IDENT = TYPE.Ident;
      var FUNCTION = TYPE.Function;
      var COLON = TYPE.Colon;
      var RIGHTPARENTHESIS = TYPE.RightParenthesis;
      module.exports = {
        name: "PseudoClassSelector",
        structure: {
          name: String,
          children: [["Raw"], null]
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var children = null;
          var name;
          var nameLowerCase;
          this.eat(COLON);
          if (this.scanner.tokenType === FUNCTION) {
            name = this.consumeFunctionName();
            nameLowerCase = name.toLowerCase();
            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
              this.scanner.skipSC();
              children = this.pseudo[nameLowerCase].call(this);
              this.scanner.skipSC();
            } else {
              children = this.createList();
              children.push(
                this.Raw(this.scanner.tokenIndex, null, false)
              );
            }
            this.eat(RIGHTPARENTHESIS);
          } else {
            name = this.consume(IDENT);
          }
          return {
            type: "PseudoClassSelector",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name,
            children
          };
        },
        generate: function(node) {
          this.chunk(":");
          this.chunk(node.name);
          if (node.children !== null) {
            this.chunk("(");
            this.children(node);
            this.chunk(")");
          }
        },
        walkContext: "function"
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/PseudoElementSelector.js
  var require_PseudoElementSelector = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/PseudoElementSelector.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var IDENT = TYPE.Ident;
      var FUNCTION = TYPE.Function;
      var COLON = TYPE.Colon;
      var RIGHTPARENTHESIS = TYPE.RightParenthesis;
      module.exports = {
        name: "PseudoElementSelector",
        structure: {
          name: String,
          children: [["Raw"], null]
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var children = null;
          var name;
          var nameLowerCase;
          this.eat(COLON);
          this.eat(COLON);
          if (this.scanner.tokenType === FUNCTION) {
            name = this.consumeFunctionName();
            nameLowerCase = name.toLowerCase();
            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
              this.scanner.skipSC();
              children = this.pseudo[nameLowerCase].call(this);
              this.scanner.skipSC();
            } else {
              children = this.createList();
              children.push(
                this.Raw(this.scanner.tokenIndex, null, false)
              );
            }
            this.eat(RIGHTPARENTHESIS);
          } else {
            name = this.consume(IDENT);
          }
          return {
            type: "PseudoElementSelector",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name,
            children
          };
        },
        generate: function(node) {
          this.chunk("::");
          this.chunk(node.name);
          if (node.children !== null) {
            this.chunk("(");
            this.children(node);
            this.chunk(")");
          }
        },
        walkContext: "function"
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Ratio.js
  var require_Ratio = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Ratio.js"(exports, module) {
      var isDigit = require_tokenizer().isDigit;
      var TYPE = require_tokenizer().TYPE;
      var NUMBER = TYPE.Number;
      var DELIM = TYPE.Delim;
      var SOLIDUS = 47;
      var FULLSTOP = 46;
      function consumeNumber() {
        this.scanner.skipWS();
        var value = this.consume(NUMBER);
        for (var i = 0; i < value.length; i++) {
          var code = value.charCodeAt(i);
          if (!isDigit(code) && code !== FULLSTOP) {
            this.error("Unsigned number is expected", this.scanner.tokenStart - value.length + i);
          }
        }
        if (Number(value) === 0) {
          this.error("Zero number is not allowed", this.scanner.tokenStart - value.length);
        }
        return value;
      }
      module.exports = {
        name: "Ratio",
        structure: {
          left: String,
          right: String
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var left = consumeNumber.call(this);
          var right;
          this.scanner.skipWS();
          if (!this.scanner.isDelim(SOLIDUS)) {
            this.error("Solidus is expected");
          }
          this.eat(DELIM);
          right = consumeNumber.call(this);
          return {
            type: "Ratio",
            loc: this.getLocation(start, this.scanner.tokenStart),
            left,
            right
          };
        },
        generate: function(node) {
          this.chunk(node.left);
          this.chunk("/");
          this.chunk(node.right);
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Rule.js
  var require_Rule = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Rule.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var rawMode = require_Raw().mode;
      var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
      function consumeRaw(startToken) {
        return this.Raw(startToken, rawMode.leftCurlyBracket, true);
      }
      function consumePrelude() {
        var prelude = this.SelectorList();
        if (prelude.type !== "Raw" && this.scanner.eof === false && this.scanner.tokenType !== LEFTCURLYBRACKET) {
          this.error();
        }
        return prelude;
      }
      module.exports = {
        name: "Rule",
        structure: {
          prelude: ["SelectorList", "Raw"],
          block: ["Block"]
        },
        parse: function() {
          var startToken = this.scanner.tokenIndex;
          var startOffset = this.scanner.tokenStart;
          var prelude;
          var block;
          if (this.parseRulePrelude) {
            prelude = this.parseWithFallback(consumePrelude, consumeRaw);
          } else {
            prelude = consumeRaw.call(this, startToken);
          }
          block = this.Block(true);
          return {
            type: "Rule",
            loc: this.getLocation(startOffset, this.scanner.tokenStart),
            prelude,
            block
          };
        },
        generate: function(node) {
          this.node(node.prelude);
          this.node(node.block);
        },
        walkContext: "rule"
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Selector.js
  var require_Selector = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Selector.js"(exports, module) {
      module.exports = {
        name: "Selector",
        structure: {
          children: [[
            "TypeSelector",
            "IdSelector",
            "ClassSelector",
            "AttributeSelector",
            "PseudoClassSelector",
            "PseudoElementSelector",
            "Combinator",
            "WhiteSpace"
          ]]
        },
        parse: function() {
          var children = this.readSequence(this.scope.Selector);
          if (this.getFirstListNode(children) === null) {
            this.error("Selector is expected");
          }
          return {
            type: "Selector",
            loc: this.getLocationFromList(children),
            children
          };
        },
        generate: function(node) {
          this.children(node);
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/SelectorList.js
  var require_SelectorList = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/SelectorList.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var COMMA = TYPE.Comma;
      module.exports = {
        name: "SelectorList",
        structure: {
          children: [[
            "Selector",
            "Raw"
          ]]
        },
        parse: function() {
          var children = this.createList();
          while (!this.scanner.eof) {
            children.push(this.Selector());
            if (this.scanner.tokenType === COMMA) {
              this.scanner.next();
              continue;
            }
            break;
          }
          return {
            type: "SelectorList",
            loc: this.getLocationFromList(children),
            children
          };
        },
        generate: function(node) {
          this.children(node, function() {
            this.chunk(",");
          });
        },
        walkContext: "selector"
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/String.js
  var require_String = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/String.js"(exports, module) {
      var STRING = require_tokenizer().TYPE.String;
      module.exports = {
        name: "String",
        structure: {
          value: String
        },
        parse: function() {
          return {
            type: "String",
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            value: this.consume(STRING)
          };
        },
        generate: function(node) {
          this.chunk(node.value);
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/StyleSheet.js
  var require_StyleSheet = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/StyleSheet.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var WHITESPACE = TYPE.WhiteSpace;
      var COMMENT = TYPE.Comment;
      var ATKEYWORD = TYPE.AtKeyword;
      var CDO = TYPE.CDO;
      var CDC = TYPE.CDC;
      var EXCLAMATIONMARK = 33;
      function consumeRaw(startToken) {
        return this.Raw(startToken, null, false);
      }
      module.exports = {
        name: "StyleSheet",
        structure: {
          children: [[
            "Comment",
            "CDO",
            "CDC",
            "Atrule",
            "Rule",
            "Raw"
          ]]
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var children = this.createList();
          var child2;
          scan:
            while (!this.scanner.eof) {
              switch (this.scanner.tokenType) {
                case WHITESPACE:
                  this.scanner.next();
                  continue;
                case COMMENT:
                  if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK) {
                    this.scanner.next();
                    continue;
                  }
                  child2 = this.Comment();
                  break;
                case CDO:
                  child2 = this.CDO();
                  break;
                case CDC:
                  child2 = this.CDC();
                  break;
                case ATKEYWORD:
                  child2 = this.parseWithFallback(this.Atrule, consumeRaw);
                  break;
                default:
                  child2 = this.parseWithFallback(this.Rule, consumeRaw);
              }
              children.push(child2);
            }
          return {
            type: "StyleSheet",
            loc: this.getLocation(start, this.scanner.tokenStart),
            children
          };
        },
        generate: function(node) {
          this.children(node);
        },
        walkContext: "stylesheet"
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/TypeSelector.js
  var require_TypeSelector = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/TypeSelector.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var IDENT = TYPE.Ident;
      var ASTERISK = 42;
      var VERTICALLINE = 124;
      function eatIdentifierOrAsterisk() {
        if (this.scanner.tokenType !== IDENT && this.scanner.isDelim(ASTERISK) === false) {
          this.error("Identifier or asterisk is expected");
        }
        this.scanner.next();
      }
      module.exports = {
        name: "TypeSelector",
        structure: {
          name: String
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          if (this.scanner.isDelim(VERTICALLINE)) {
            this.scanner.next();
            eatIdentifierOrAsterisk.call(this);
          } else {
            eatIdentifierOrAsterisk.call(this);
            if (this.scanner.isDelim(VERTICALLINE)) {
              this.scanner.next();
              eatIdentifierOrAsterisk.call(this);
            }
          }
          return {
            type: "TypeSelector",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start)
          };
        },
        generate: function(node) {
          this.chunk(node.name);
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/UnicodeRange.js
  var require_UnicodeRange = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/UnicodeRange.js"(exports, module) {
      var isHexDigit = require_tokenizer().isHexDigit;
      var cmpChar = require_tokenizer().cmpChar;
      var TYPE = require_tokenizer().TYPE;
      var NAME = require_tokenizer().NAME;
      var IDENT = TYPE.Ident;
      var NUMBER = TYPE.Number;
      var DIMENSION = TYPE.Dimension;
      var PLUSSIGN = 43;
      var HYPHENMINUS = 45;
      var QUESTIONMARK = 63;
      var U = 117;
      function eatHexSequence(offset, allowDash) {
        for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
          var code = this.scanner.source.charCodeAt(pos);
          if (code === HYPHENMINUS && allowDash && len !== 0) {
            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
              this.error();
            }
            return -1;
          }
          if (!isHexDigit(code)) {
            this.error(
              allowDash && len !== 0 ? "HyphenMinus" + (len < 6 ? " or hex digit" : "") + " is expected" : len < 6 ? "Hex digit is expected" : "Unexpected input",
              pos
            );
          }
          if (++len > 6) {
            this.error("Too many hex digits", pos);
          }
          ;
        }
        this.scanner.next();
        return len;
      }
      function eatQuestionMarkSequence(max) {
        var count = 0;
        while (this.scanner.isDelim(QUESTIONMARK)) {
          if (++count > max) {
            this.error("Too many question marks");
          }
          this.scanner.next();
        }
      }
      function startsWith(code) {
        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
          this.error(NAME[code] + " is expected");
        }
      }
      function scanUnicodeRange() {
        var hexLength = 0;
        if (this.scanner.isDelim(PLUSSIGN)) {
          this.scanner.next();
          if (this.scanner.tokenType === IDENT) {
            hexLength = eatHexSequence.call(this, 0, true);
            if (hexLength > 0) {
              eatQuestionMarkSequence.call(this, 6 - hexLength);
            }
            return;
          }
          if (this.scanner.isDelim(QUESTIONMARK)) {
            this.scanner.next();
            eatQuestionMarkSequence.call(this, 5);
            return;
          }
          this.error("Hex digit or question mark is expected");
          return;
        }
        if (this.scanner.tokenType === NUMBER) {
          startsWith.call(this, PLUSSIGN);
          hexLength = eatHexSequence.call(this, 1, true);
          if (this.scanner.isDelim(QUESTIONMARK)) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
            return;
          }
          if (this.scanner.tokenType === DIMENSION || this.scanner.tokenType === NUMBER) {
            startsWith.call(this, HYPHENMINUS);
            eatHexSequence.call(this, 1, false);
            return;
          }
          return;
        }
        if (this.scanner.tokenType === DIMENSION) {
          startsWith.call(this, PLUSSIGN);
          hexLength = eatHexSequence.call(this, 1, true);
          if (hexLength > 0) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
          }
          return;
        }
        this.error();
      }
      module.exports = {
        name: "UnicodeRange",
        structure: {
          value: String
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          if (!cmpChar(this.scanner.source, start, U)) {
            this.error("U is expected");
          }
          if (!cmpChar(this.scanner.source, start + 1, PLUSSIGN)) {
            this.error("Plus sign is expected");
          }
          this.scanner.next();
          scanUnicodeRange.call(this);
          return {
            type: "UnicodeRange",
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start)
          };
        },
        generate: function(node) {
          this.chunk(node.value);
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Url.js
  var require_Url = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Url.js"(exports, module) {
      var isWhiteSpace = require_tokenizer().isWhiteSpace;
      var cmpStr = require_tokenizer().cmpStr;
      var TYPE = require_tokenizer().TYPE;
      var FUNCTION = TYPE.Function;
      var URL2 = TYPE.Url;
      var RIGHTPARENTHESIS = TYPE.RightParenthesis;
      module.exports = {
        name: "Url",
        structure: {
          value: ["String", "Raw"]
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var value;
          switch (this.scanner.tokenType) {
            case URL2:
              var rawStart = start + 4;
              var rawEnd = this.scanner.tokenEnd - 1;
              while (rawStart < rawEnd && isWhiteSpace(this.scanner.source.charCodeAt(rawStart))) {
                rawStart++;
              }
              while (rawStart < rawEnd && isWhiteSpace(this.scanner.source.charCodeAt(rawEnd - 1))) {
                rawEnd--;
              }
              value = {
                type: "Raw",
                loc: this.getLocation(rawStart, rawEnd),
                value: this.scanner.source.substring(rawStart, rawEnd)
              };
              this.eat(URL2);
              break;
            case FUNCTION:
              if (!cmpStr(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, "url(")) {
                this.error("Function name must be `url`");
              }
              this.eat(FUNCTION);
              this.scanner.skipSC();
              value = this.String();
              this.scanner.skipSC();
              this.eat(RIGHTPARENTHESIS);
              break;
            default:
              this.error("Url or Function is expected");
          }
          return {
            type: "Url",
            loc: this.getLocation(start, this.scanner.tokenStart),
            value
          };
        },
        generate: function(node) {
          this.chunk("url");
          this.chunk("(");
          this.node(node.value);
          this.chunk(")");
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Value.js
  var require_Value = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/Value.js"(exports, module) {
      module.exports = {
        name: "Value",
        structure: {
          children: [[]]
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var children = this.readSequence(this.scope.Value);
          return {
            type: "Value",
            loc: this.getLocation(start, this.scanner.tokenStart),
            children
          };
        },
        generate: function(node) {
          this.children(node);
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/WhiteSpace.js
  var require_WhiteSpace = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/WhiteSpace.js"(exports, module) {
      var WHITESPACE = require_tokenizer().TYPE.WhiteSpace;
      var SPACE = Object.freeze({
        type: "WhiteSpace",
        loc: null,
        value: " "
      });
      module.exports = {
        name: "WhiteSpace",
        structure: {
          value: String
        },
        parse: function() {
          this.eat(WHITESPACE);
          return SPACE;
        },
        generate: function(node) {
          this.chunk(node.value);
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/index.js
  var require_node = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/node/index.js"(exports, module) {
      module.exports = {
        AnPlusB: require_AnPlusB(),
        Atrule: require_Atrule(),
        AtrulePrelude: require_AtrulePrelude(),
        AttributeSelector: require_AttributeSelector(),
        Block: require_Block(),
        Brackets: require_Brackets(),
        CDC: require_CDC(),
        CDO: require_CDO(),
        ClassSelector: require_ClassSelector(),
        Combinator: require_Combinator(),
        Comment: require_Comment(),
        Declaration: require_Declaration(),
        DeclarationList: require_DeclarationList(),
        Dimension: require_Dimension(),
        Function: require_Function(),
        Hash: require_Hash(),
        Identifier: require_Identifier(),
        IdSelector: require_IdSelector(),
        MediaFeature: require_MediaFeature(),
        MediaQuery: require_MediaQuery(),
        MediaQueryList: require_MediaQueryList(),
        Nth: require_Nth(),
        Number: require_Number(),
        Operator: require_Operator(),
        Parentheses: require_Parentheses(),
        Percentage: require_Percentage(),
        PseudoClassSelector: require_PseudoClassSelector(),
        PseudoElementSelector: require_PseudoElementSelector(),
        Ratio: require_Ratio(),
        Raw: require_Raw(),
        Rule: require_Rule(),
        Selector: require_Selector(),
        SelectorList: require_SelectorList(),
        String: require_String(),
        StyleSheet: require_StyleSheet(),
        TypeSelector: require_TypeSelector(),
        UnicodeRange: require_UnicodeRange(),
        Url: require_Url(),
        Value: require_Value(),
        WhiteSpace: require_WhiteSpace()
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/config/lexer.js
  var require_lexer = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/config/lexer.js"(exports, module) {
      var data = require_data();
      module.exports = {
        generic: true,
        types: data.types,
        atrules: data.atrules,
        properties: data.properties,
        node: require_node()
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/scope/default.js
  var require_default = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/scope/default.js"(exports, module) {
      var cmpChar = require_tokenizer().cmpChar;
      var cmpStr = require_tokenizer().cmpStr;
      var TYPE = require_tokenizer().TYPE;
      var IDENT = TYPE.Ident;
      var STRING = TYPE.String;
      var NUMBER = TYPE.Number;
      var FUNCTION = TYPE.Function;
      var URL2 = TYPE.Url;
      var HASH = TYPE.Hash;
      var DIMENSION = TYPE.Dimension;
      var PERCENTAGE = TYPE.Percentage;
      var LEFTPARENTHESIS = TYPE.LeftParenthesis;
      var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
      var COMMA = TYPE.Comma;
      var DELIM = TYPE.Delim;
      var NUMBERSIGN = 35;
      var ASTERISK = 42;
      var PLUSSIGN = 43;
      var HYPHENMINUS = 45;
      var SOLIDUS = 47;
      var U = 117;
      module.exports = function defaultRecognizer(context) {
        switch (this.scanner.tokenType) {
          case HASH:
            return this.Hash();
          case COMMA:
            context.space = null;
            context.ignoreWSAfter = true;
            return this.Operator();
          case LEFTPARENTHESIS:
            return this.Parentheses(this.readSequence, context.recognizer);
          case LEFTSQUAREBRACKET:
            return this.Brackets(this.readSequence, context.recognizer);
          case STRING:
            return this.String();
          case DIMENSION:
            return this.Dimension();
          case PERCENTAGE:
            return this.Percentage();
          case NUMBER:
            return this.Number();
          case FUNCTION:
            return cmpStr(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, context.recognizer);
          case URL2:
            return this.Url();
          case IDENT:
            if (cmpChar(this.scanner.source, this.scanner.tokenStart, U) && cmpChar(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN)) {
              return this.UnicodeRange();
            } else {
              return this.Identifier();
            }
          case DELIM:
            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
            if (code === SOLIDUS || code === ASTERISK || code === PLUSSIGN || code === HYPHENMINUS) {
              return this.Operator();
            }
            if (code === NUMBERSIGN) {
              this.error("Hex or identifier is expected", this.scanner.tokenStart + 1);
            }
            break;
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/scope/atrulePrelude.js
  var require_atrulePrelude = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/scope/atrulePrelude.js"(exports, module) {
      module.exports = {
        getNode: require_default()
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/scope/selector.js
  var require_selector = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/scope/selector.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var DELIM = TYPE.Delim;
      var IDENT = TYPE.Ident;
      var DIMENSION = TYPE.Dimension;
      var PERCENTAGE = TYPE.Percentage;
      var NUMBER = TYPE.Number;
      var HASH = TYPE.Hash;
      var COLON = TYPE.Colon;
      var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
      var NUMBERSIGN = 35;
      var ASTERISK = 42;
      var PLUSSIGN = 43;
      var SOLIDUS = 47;
      var FULLSTOP = 46;
      var GREATERTHANSIGN = 62;
      var VERTICALLINE = 124;
      var TILDE = 126;
      function getNode(context) {
        switch (this.scanner.tokenType) {
          case LEFTSQUAREBRACKET:
            return this.AttributeSelector();
          case HASH:
            return this.IdSelector();
          case COLON:
            if (this.scanner.lookupType(1) === COLON) {
              return this.PseudoElementSelector();
            } else {
              return this.PseudoClassSelector();
            }
          case IDENT:
            return this.TypeSelector();
          case NUMBER:
          case PERCENTAGE:
            return this.Percentage();
          case DIMENSION:
            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP) {
              this.error("Identifier is expected", this.scanner.tokenStart + 1);
            }
            break;
          case DELIM:
            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
            switch (code) {
              case PLUSSIGN:
              case GREATERTHANSIGN:
              case TILDE:
                context.space = null;
                context.ignoreWSAfter = true;
                return this.Combinator();
              case SOLIDUS:
                return this.Combinator();
              case FULLSTOP:
                return this.ClassSelector();
              case ASTERISK:
              case VERTICALLINE:
                return this.TypeSelector();
              case NUMBERSIGN:
                return this.IdSelector();
            }
            break;
        }
      }
      module.exports = {
        getNode
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/function/expression.js
  var require_expression = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/function/expression.js"(exports, module) {
      module.exports = function() {
        return this.createSingleNodeList(
          this.Raw(this.scanner.tokenIndex, null, false)
        );
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/function/var.js
  var require_var = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/function/var.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var rawMode = require_Raw().mode;
      var COMMA = TYPE.Comma;
      var WHITESPACE = TYPE.WhiteSpace;
      module.exports = function() {
        var children = this.createList();
        this.scanner.skipSC();
        children.push(this.Identifier());
        this.scanner.skipSC();
        if (this.scanner.tokenType === COMMA) {
          children.push(this.Operator());
          const startIndex = this.scanner.tokenIndex;
          const value = this.parseCustomProperty ? this.Value(null) : this.Raw(this.scanner.tokenIndex, rawMode.exclamationMarkOrSemicolon, false);
          if (value.type === "Value" && value.children.isEmpty()) {
            for (let offset = startIndex - this.scanner.tokenIndex; offset <= 0; offset++) {
              if (this.scanner.lookupType(offset) === WHITESPACE) {
                value.children.appendData({
                  type: "WhiteSpace",
                  loc: null,
                  value: " "
                });
                break;
              }
            }
          }
          children.push(value);
        }
        return children;
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/scope/value.js
  var require_value = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/scope/value.js"(exports, module) {
      module.exports = {
        getNode: require_default(),
        "expression": require_expression(),
        "var": require_var()
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/scope/index.js
  var require_scope = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/scope/index.js"(exports, module) {
      module.exports = {
        AtrulePrelude: require_atrulePrelude(),
        Selector: require_selector(),
        Value: require_value()
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/atrule/font-face.js
  var require_font_face = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/atrule/font-face.js"(exports, module) {
      module.exports = {
        parse: {
          prelude: null,
          block: function() {
            return this.Block(true);
          }
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/atrule/import.js
  var require_import = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/atrule/import.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var STRING = TYPE.String;
      var IDENT = TYPE.Ident;
      var URL2 = TYPE.Url;
      var FUNCTION = TYPE.Function;
      var LEFTPARENTHESIS = TYPE.LeftParenthesis;
      module.exports = {
        parse: {
          prelude: function() {
            var children = this.createList();
            this.scanner.skipSC();
            switch (this.scanner.tokenType) {
              case STRING:
                children.push(this.String());
                break;
              case URL2:
              case FUNCTION:
                children.push(this.Url());
                break;
              default:
                this.error("String or url() is expected");
            }
            if (this.lookupNonWSType(0) === IDENT || this.lookupNonWSType(0) === LEFTPARENTHESIS) {
              children.push(this.WhiteSpace());
              children.push(this.MediaQueryList());
            }
            return children;
          },
          block: null
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/atrule/media.js
  var require_media = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/atrule/media.js"(exports, module) {
      module.exports = {
        parse: {
          prelude: function() {
            return this.createSingleNodeList(
              this.MediaQueryList()
            );
          },
          block: function() {
            return this.Block(false);
          }
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/atrule/page.js
  var require_page = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/atrule/page.js"(exports, module) {
      module.exports = {
        parse: {
          prelude: function() {
            return this.createSingleNodeList(
              this.SelectorList()
            );
          },
          block: function() {
            return this.Block(true);
          }
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/atrule/supports.js
  var require_supports = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/atrule/supports.js"(exports, module) {
      var TYPE = require_tokenizer().TYPE;
      var WHITESPACE = TYPE.WhiteSpace;
      var COMMENT = TYPE.Comment;
      var IDENT = TYPE.Ident;
      var FUNCTION = TYPE.Function;
      var COLON = TYPE.Colon;
      var LEFTPARENTHESIS = TYPE.LeftParenthesis;
      function consumeRaw() {
        return this.createSingleNodeList(
          this.Raw(this.scanner.tokenIndex, null, false)
        );
      }
      function parentheses() {
        this.scanner.skipSC();
        if (this.scanner.tokenType === IDENT && this.lookupNonWSType(1) === COLON) {
          return this.createSingleNodeList(
            this.Declaration()
          );
        }
        return readSequence.call(this);
      }
      function readSequence() {
        var children = this.createList();
        var space = null;
        var child2;
        this.scanner.skipSC();
        scan:
          while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
              case WHITESPACE:
                space = this.WhiteSpace();
                continue;
              case COMMENT:
                this.scanner.next();
                continue;
              case FUNCTION:
                child2 = this.Function(consumeRaw, this.scope.AtrulePrelude);
                break;
              case IDENT:
                child2 = this.Identifier();
                break;
              case LEFTPARENTHESIS:
                child2 = this.Parentheses(parentheses, this.scope.AtrulePrelude);
                break;
              default:
                break scan;
            }
            if (space !== null) {
              children.push(space);
              space = null;
            }
            children.push(child2);
          }
        return children;
      }
      module.exports = {
        parse: {
          prelude: function() {
            var children = readSequence.call(this);
            if (this.getFirstListNode(children) === null) {
              this.error("Condition is expected");
            }
            return children;
          },
          block: function() {
            return this.Block(false);
          }
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/atrule/index.js
  var require_atrule = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/atrule/index.js"(exports, module) {
      module.exports = {
        "font-face": require_font_face(),
        "import": require_import(),
        "media": require_media(),
        "page": require_page(),
        "supports": require_supports()
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/dir.js
  var require_dir = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/dir.js"(exports, module) {
      module.exports = {
        parse: function() {
          return this.createSingleNodeList(
            this.Identifier()
          );
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/has.js
  var require_has = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/has.js"(exports, module) {
      module.exports = {
        parse: function() {
          return this.createSingleNodeList(
            this.SelectorList()
          );
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/lang.js
  var require_lang = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/lang.js"(exports, module) {
      module.exports = {
        parse: function() {
          return this.createSingleNodeList(
            this.Identifier()
          );
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/common/selectorList.js
  var require_selectorList = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/common/selectorList.js"(exports, module) {
      module.exports = {
        parse: function selectorList() {
          return this.createSingleNodeList(
            this.SelectorList()
          );
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/matches.js
  var require_matches = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/matches.js"(exports, module) {
      module.exports = require_selectorList();
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/not.js
  var require_not = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/not.js"(exports, module) {
      module.exports = require_selectorList();
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/common/nthWithOfClause.js
  var require_nthWithOfClause = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/common/nthWithOfClause.js"(exports, module) {
      var ALLOW_OF_CLAUSE = true;
      module.exports = {
        parse: function nthWithOfClause() {
          return this.createSingleNodeList(
            this.Nth(ALLOW_OF_CLAUSE)
          );
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/nth-child.js
  var require_nth_child = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/nth-child.js"(exports, module) {
      module.exports = require_nthWithOfClause();
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/nth-last-child.js
  var require_nth_last_child = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/nth-last-child.js"(exports, module) {
      module.exports = require_nthWithOfClause();
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/common/nth.js
  var require_nth = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/common/nth.js"(exports, module) {
      var DISALLOW_OF_CLAUSE = false;
      module.exports = {
        parse: function nth() {
          return this.createSingleNodeList(
            this.Nth(DISALLOW_OF_CLAUSE)
          );
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/nth-last-of-type.js
  var require_nth_last_of_type = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/nth-last-of-type.js"(exports, module) {
      module.exports = require_nth();
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/nth-of-type.js
  var require_nth_of_type = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/nth-of-type.js"(exports, module) {
      module.exports = require_nth();
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/slotted.js
  var require_slotted = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/slotted.js"(exports, module) {
      module.exports = {
        parse: function compoundSelector() {
          return this.createSingleNodeList(
            this.Selector()
          );
        }
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/index.js
  var require_pseudo = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/pseudo/index.js"(exports, module) {
      module.exports = {
        "dir": require_dir(),
        "has": require_has(),
        "lang": require_lang(),
        "matches": require_matches(),
        "not": require_not(),
        "nth-child": require_nth_child(),
        "nth-last-child": require_nth_last_child(),
        "nth-last-of-type": require_nth_last_of_type(),
        "nth-of-type": require_nth_of_type(),
        "slotted": require_slotted()
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/config/parser.js
  var require_parser = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/config/parser.js"(exports, module) {
      module.exports = {
        parseContext: {
          default: "StyleSheet",
          stylesheet: "StyleSheet",
          atrule: "Atrule",
          atrulePrelude: function(options) {
            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
          },
          mediaQueryList: "MediaQueryList",
          mediaQuery: "MediaQuery",
          rule: "Rule",
          selectorList: "SelectorList",
          selector: "Selector",
          block: function() {
            return this.Block(true);
          },
          declarationList: "DeclarationList",
          declaration: "Declaration",
          value: "Value"
        },
        scope: require_scope(),
        atrule: require_atrule(),
        pseudo: require_pseudo(),
        node: require_node()
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/config/walker.js
  var require_walker = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/config/walker.js"(exports, module) {
      module.exports = {
        node: require_node()
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/package.json
  var require_package = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/package.json"(exports, module) {
      module.exports = {
        name: "css-tree",
        version: "1.1.3",
        description: "A tool set for CSS: fast detailed parser (CSS \u2192 AST), walker (AST traversal), generator (AST \u2192 CSS) and lexer (validation and matching) based on specs and browser implementations",
        author: "Roman Dvornov <rdvornov@gmail.com> (https://github.com/lahmatiy)",
        license: "MIT",
        repository: "csstree/csstree",
        keywords: [
          "css",
          "ast",
          "tokenizer",
          "parser",
          "walker",
          "lexer",
          "generator",
          "utils",
          "syntax",
          "validation"
        ],
        main: "lib/index.js",
        unpkg: "dist/csstree.min.js",
        jsdelivr: "dist/csstree.min.js",
        scripts: {
          build: "rollup --config",
          lint: "eslint data lib scripts test && node scripts/review-syntax-patch --lint && node scripts/update-docs --lint",
          "lint-and-test": "npm run lint && npm test",
          "update:docs": "node scripts/update-docs",
          "review:syntax-patch": "node scripts/review-syntax-patch",
          test: "mocha --reporter progress",
          coverage: "nyc npm test",
          travis: "nyc npm run lint-and-test && npm run coveralls",
          coveralls: "nyc report --reporter=text-lcov | coveralls",
          prepublishOnly: "npm run build",
          hydrogen: "node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/parse --stat -o /dev/null"
        },
        dependencies: {
          "mdn-data": "2.0.14",
          "source-map": "^0.6.1"
        },
        devDependencies: {
          "@rollup/plugin-commonjs": "^11.0.2",
          "@rollup/plugin-json": "^4.0.2",
          "@rollup/plugin-node-resolve": "^7.1.1",
          coveralls: "^3.0.9",
          eslint: "^6.8.0",
          "json-to-ast": "^2.1.0",
          mocha: "^6.2.3",
          nyc: "^14.1.1",
          rollup: "^1.32.1",
          "rollup-plugin-terser": "^5.3.0"
        },
        engines: {
          node: ">=8.0.0"
        },
        files: [
          "data",
          "dist",
          "lib"
        ]
      };
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/index.js
  var require_syntax = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/syntax/index.js"(exports, module) {
      function merge() {
        var dest = {};
        for (var i = 0; i < arguments.length; i++) {
          var src2 = arguments[i];
          for (var key in src2) {
            dest[key] = src2[key];
          }
        }
        return dest;
      }
      module.exports = require_create5().create(
        merge(
          require_lexer(),
          require_parser(),
          require_walker()
        )
      );
      module.exports.version = require_package().version;
    }
  });

  // node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/index.js
  var require_lib = __commonJS({
    "node_modules/.pnpm/css-tree@1.1.3/node_modules/css-tree/lib/index.js"(exports, module) {
      module.exports = require_syntax();
    }
  });

  // node_modules/.pnpm/clear-cut@2.0.2/node_modules/clear-cut/index.js
  var require_clear_cut = __commonJS({
    "node_modules/.pnpm/clear-cut@2.0.2/node_modules/clear-cut/index.js"(exports) {
      var attributeRegex = /(\[[^\]]+\])/g;
      var idRegex = /(#[^\s\+>~\.\[:]+)/g;
      var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
      var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
      var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
      var elementRegex = /([^\s\+>~\.\[:]+)/g;
      var notRegex = /:not\(([^\)]*)\)/g;
      var ruleRegex = /\{[^]*/gm;
      var separatorRegex = /[\*\s\+>~]/g;
      var straysRegex = /[#\.]/g;
      var findMatch = function(regex, type, types2, selector) {
        var matches = selector.match(regex);
        if (matches) {
          for (var i = 0; i < matches.length; i++) {
            types2[type]++;
            selector = selector.replace(matches[i], " ");
          }
        }
        return selector;
      };
      var calculate = function(selector) {
        var commaIndex = selector.indexOf(",");
        if (commaIndex !== -1) {
          selector = selector.substring(0, commaIndex);
        }
        var types2 = {
          a: 0,
          b: 0,
          c: 0
        };
        selector = selector.replace(notRegex, " $1 ");
        selector = selector.replace(ruleRegex, " ");
        selector = findMatch(attributeRegex, "b", types2, selector);
        selector = findMatch(idRegex, "a", types2, selector);
        selector = findMatch(classRegex, "b", types2, selector);
        selector = findMatch(pseudoElementRegex, "c", types2, selector);
        selector = findMatch(pseudoClassRegex, "b", types2, selector);
        selector = selector.replace(separatorRegex, " ");
        selector = selector.replace(straysRegex, " ");
        findMatch(elementRegex, "c", types2, selector);
        return types2.a * 100 + types2.b * 10 + types2.c * 1;
      };
      var specificityCache = {};
      exports.calculateSpecificity = function(selector) {
        var specificity = specificityCache[selector];
        if (specificity === void 0) {
          specificity = calculate(selector);
          specificityCache[selector] = specificity;
        }
        return specificity;
      };
      var validSelectorCache = {};
      var testSelectorElement = null;
      exports.isSelectorValid = function(selector) {
        var valid = validSelectorCache[selector];
        if (valid === void 0) {
          if (testSelectorElement == null) {
            testSelectorElement = document.createElement("div");
          }
          try {
            testSelectorElement.querySelector(selector);
            valid = true;
          } catch (error) {
            valid = false;
          }
          validSelectorCache[selector] = valid;
        }
        return valid;
      };
      exports.validateSelector = function(selector) {
        if (!exports.isSelectorValid(selector)) {
          var error = new SyntaxError(selector + " is not a valid selector");
          error.code = "EBADSELECTOR";
          throw error;
        }
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/from/is-implemented.js
  var require_is_implemented4 = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/from/is-implemented.js"(exports, module) {
      "use strict";
      module.exports = function() {
        var from = Array.from, arr, result;
        if (typeof from !== "function")
          return false;
        arr = ["raz", "dwa"];
        result = from(arr);
        return Boolean(result && result !== arr && result[1] === "dwa");
      };
    }
  });

  // node_modules/.pnpm/ext@1.7.0/node_modules/ext/global-this/is-implemented.js
  var require_is_implemented5 = __commonJS({
    "node_modules/.pnpm/ext@1.7.0/node_modules/ext/global-this/is-implemented.js"(exports, module) {
      "use strict";
      module.exports = function() {
        if (typeof globalThis !== "object")
          return false;
        if (!globalThis)
          return false;
        return globalThis.Array === Array;
      };
    }
  });

  // node_modules/.pnpm/ext@1.7.0/node_modules/ext/global-this/implementation.js
  var require_implementation = __commonJS({
    "node_modules/.pnpm/ext@1.7.0/node_modules/ext/global-this/implementation.js"(exports, module) {
      var naiveFallback = function() {
        if (typeof self === "object" && self)
          return self;
        if (typeof window === "object" && window)
          return window;
        throw new Error("Unable to resolve global `this`");
      };
      module.exports = function() {
        if (this)
          return this;
        try {
          Object.defineProperty(Object.prototype, "__global__", {
            get: function() {
              return this;
            },
            configurable: true
          });
        } catch (error) {
          return naiveFallback();
        }
        try {
          if (!__global__)
            return naiveFallback();
          return __global__;
        } finally {
          delete Object.prototype.__global__;
        }
      }();
    }
  });

  // node_modules/.pnpm/ext@1.7.0/node_modules/ext/global-this/index.js
  var require_global_this = __commonJS({
    "node_modules/.pnpm/ext@1.7.0/node_modules/ext/global-this/index.js"(exports, module) {
      "use strict";
      module.exports = require_is_implemented5()() ? globalThis : require_implementation();
    }
  });

  // node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/is-implemented.js
  var require_is_implemented6 = __commonJS({
    "node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/is-implemented.js"(exports, module) {
      "use strict";
      var global2 = require_global_this();
      var validTypes = { object: true, symbol: true };
      module.exports = function() {
        var Symbol2 = global2.Symbol;
        var symbol;
        if (typeof Symbol2 !== "function")
          return false;
        symbol = Symbol2("test symbol");
        try {
          String(symbol);
        } catch (e) {
          return false;
        }
        if (!validTypes[typeof Symbol2.iterator])
          return false;
        if (!validTypes[typeof Symbol2.toPrimitive])
          return false;
        if (!validTypes[typeof Symbol2.toStringTag])
          return false;
        return true;
      };
    }
  });

  // node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/is-symbol.js
  var require_is_symbol = __commonJS({
    "node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/is-symbol.js"(exports, module) {
      "use strict";
      module.exports = function(value) {
        if (!value)
          return false;
        if (typeof value === "symbol")
          return true;
        if (!value.constructor)
          return false;
        if (value.constructor.name !== "Symbol")
          return false;
        return value[value.constructor.toStringTag] === "Symbol";
      };
    }
  });

  // node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/validate-symbol.js
  var require_validate_symbol = __commonJS({
    "node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/validate-symbol.js"(exports, module) {
      "use strict";
      var isSymbol = require_is_symbol();
      module.exports = function(value) {
        if (!isSymbol(value))
          throw new TypeError(value + " is not a symbol");
        return value;
      };
    }
  });

  // node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/lib/private/generate-name.js
  var require_generate_name = __commonJS({
    "node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/lib/private/generate-name.js"(exports, module) {
      "use strict";
      var d = require_d();
      var create = Object.create;
      var defineProperty = Object.defineProperty;
      var objPrototype = Object.prototype;
      var created = create(null);
      module.exports = function(desc) {
        var postfix = 0, name, ie11BugWorkaround;
        while (created[desc + (postfix || "")])
          ++postfix;
        desc += postfix || "";
        created[desc] = true;
        name = "@@" + desc;
        defineProperty(
          objPrototype,
          name,
          d.gs(null, function(value) {
            if (ie11BugWorkaround)
              return;
            ie11BugWorkaround = true;
            defineProperty(this, name, d(value));
            ie11BugWorkaround = false;
          })
        );
        return name;
      };
    }
  });

  // node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/lib/private/setup/standard-symbols.js
  var require_standard_symbols = __commonJS({
    "node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/lib/private/setup/standard-symbols.js"(exports, module) {
      "use strict";
      var d = require_d();
      var NativeSymbol = require_global_this().Symbol;
      module.exports = function(SymbolPolyfill) {
        return Object.defineProperties(SymbolPolyfill, {
          // To ensure proper interoperability with other native functions (e.g. Array.from)
          // fallback to eventual native implementation of given symbol
          hasInstance: d(
            "",
            NativeSymbol && NativeSymbol.hasInstance || SymbolPolyfill("hasInstance")
          ),
          isConcatSpreadable: d(
            "",
            NativeSymbol && NativeSymbol.isConcatSpreadable || SymbolPolyfill("isConcatSpreadable")
          ),
          iterator: d("", NativeSymbol && NativeSymbol.iterator || SymbolPolyfill("iterator")),
          match: d("", NativeSymbol && NativeSymbol.match || SymbolPolyfill("match")),
          replace: d("", NativeSymbol && NativeSymbol.replace || SymbolPolyfill("replace")),
          search: d("", NativeSymbol && NativeSymbol.search || SymbolPolyfill("search")),
          species: d("", NativeSymbol && NativeSymbol.species || SymbolPolyfill("species")),
          split: d("", NativeSymbol && NativeSymbol.split || SymbolPolyfill("split")),
          toPrimitive: d(
            "",
            NativeSymbol && NativeSymbol.toPrimitive || SymbolPolyfill("toPrimitive")
          ),
          toStringTag: d(
            "",
            NativeSymbol && NativeSymbol.toStringTag || SymbolPolyfill("toStringTag")
          ),
          unscopables: d(
            "",
            NativeSymbol && NativeSymbol.unscopables || SymbolPolyfill("unscopables")
          )
        });
      };
    }
  });

  // node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/lib/private/setup/symbol-registry.js
  var require_symbol_registry = __commonJS({
    "node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/lib/private/setup/symbol-registry.js"(exports, module) {
      "use strict";
      var d = require_d();
      var validateSymbol = require_validate_symbol();
      var registry = /* @__PURE__ */ Object.create(null);
      module.exports = function(SymbolPolyfill) {
        return Object.defineProperties(SymbolPolyfill, {
          for: d(function(key) {
            if (registry[key])
              return registry[key];
            return registry[key] = SymbolPolyfill(String(key));
          }),
          keyFor: d(function(symbol) {
            var key;
            validateSymbol(symbol);
            for (key in registry) {
              if (registry[key] === symbol)
                return key;
            }
            return void 0;
          })
        });
      };
    }
  });

  // node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/polyfill.js
  var require_polyfill = __commonJS({
    "node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/polyfill.js"(exports, module) {
      "use strict";
      var d = require_d();
      var validateSymbol = require_validate_symbol();
      var NativeSymbol = require_global_this().Symbol;
      var generateName = require_generate_name();
      var setupStandardSymbols = require_standard_symbols();
      var setupSymbolRegistry = require_symbol_registry();
      var create = Object.create;
      var defineProperties = Object.defineProperties;
      var defineProperty = Object.defineProperty;
      var SymbolPolyfill;
      var HiddenSymbol;
      var isNativeSafe;
      if (typeof NativeSymbol === "function") {
        try {
          String(NativeSymbol());
          isNativeSafe = true;
        } catch (ignore) {
        }
      } else {
        NativeSymbol = null;
      }
      HiddenSymbol = function Symbol2(description) {
        if (this instanceof HiddenSymbol)
          throw new TypeError("Symbol is not a constructor");
        return SymbolPolyfill(description);
      };
      module.exports = SymbolPolyfill = function Symbol2(description) {
        var symbol;
        if (this instanceof Symbol2)
          throw new TypeError("Symbol is not a constructor");
        if (isNativeSafe)
          return NativeSymbol(description);
        symbol = create(HiddenSymbol.prototype);
        description = description === void 0 ? "" : String(description);
        return defineProperties(symbol, {
          __description__: d("", description),
          __name__: d("", generateName(description))
        });
      };
      setupStandardSymbols(SymbolPolyfill);
      setupSymbolRegistry(SymbolPolyfill);
      defineProperties(HiddenSymbol.prototype, {
        constructor: d(SymbolPolyfill),
        toString: d("", function() {
          return this.__name__;
        })
      });
      defineProperties(SymbolPolyfill.prototype, {
        toString: d(function() {
          return "Symbol (" + validateSymbol(this).__description__ + ")";
        }),
        valueOf: d(function() {
          return validateSymbol(this);
        })
      });
      defineProperty(
        SymbolPolyfill.prototype,
        SymbolPolyfill.toPrimitive,
        d("", function() {
          var symbol = validateSymbol(this);
          if (typeof symbol === "symbol")
            return symbol;
          return symbol.toString();
        })
      );
      defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d("c", "Symbol"));
      defineProperty(
        HiddenSymbol.prototype,
        SymbolPolyfill.toStringTag,
        d("c", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])
      );
      defineProperty(
        HiddenSymbol.prototype,
        SymbolPolyfill.toPrimitive,
        d("c", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive])
      );
    }
  });

  // node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/index.js
  var require_es6_symbol = __commonJS({
    "node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/index.js"(exports, module) {
      "use strict";
      module.exports = require_is_implemented6()() ? require_global_this().Symbol : require_polyfill();
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/function/is-arguments.js
  var require_is_arguments = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/function/is-arguments.js"(exports, module) {
      "use strict";
      var objToString = Object.prototype.toString;
      var id = objToString.call(function() {
        return arguments;
      }());
      module.exports = function(value) {
        return objToString.call(value) === id;
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/function/is-function.js
  var require_is_function = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/function/is-function.js"(exports, module) {
      "use strict";
      var objToString = Object.prototype.toString;
      var isFunctionStringTag = RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);
      module.exports = function(value) {
        return typeof value === "function" && isFunctionStringTag(objToString.call(value));
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/math/sign/is-implemented.js
  var require_is_implemented7 = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/math/sign/is-implemented.js"(exports, module) {
      "use strict";
      module.exports = function() {
        var sign = Math.sign;
        if (typeof sign !== "function")
          return false;
        return sign(10) === 1 && sign(-20) === -1;
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/math/sign/shim.js
  var require_shim4 = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/math/sign/shim.js"(exports, module) {
      "use strict";
      module.exports = function(value) {
        value = Number(value);
        if (isNaN(value) || value === 0)
          return value;
        return value > 0 ? 1 : -1;
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/math/sign/index.js
  var require_sign = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/math/sign/index.js"(exports, module) {
      "use strict";
      module.exports = require_is_implemented7()() ? Math.sign : require_shim4();
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/number/to-integer.js
  var require_to_integer = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/number/to-integer.js"(exports, module) {
      "use strict";
      var sign = require_sign();
      var abs = Math.abs;
      var floor = Math.floor;
      module.exports = function(value) {
        if (isNaN(value))
          return 0;
        value = Number(value);
        if (value === 0 || !isFinite(value))
          return value;
        return sign(value) * floor(abs(value));
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/number/to-pos-integer.js
  var require_to_pos_integer = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/number/to-pos-integer.js"(exports, module) {
      "use strict";
      var toInteger = require_to_integer();
      var max = Math.max;
      module.exports = function(value) {
        return max(0, toInteger(value));
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/string/is-string.js
  var require_is_string = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/string/is-string.js"(exports, module) {
      "use strict";
      var objToString = Object.prototype.toString;
      var id = objToString.call("");
      module.exports = function(value) {
        return typeof value === "string" || value && typeof value === "object" && (value instanceof String || objToString.call(value) === id) || false;
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/from/shim.js
  var require_shim5 = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/from/shim.js"(exports, module) {
      "use strict";
      var iteratorSymbol = require_es6_symbol().iterator;
      var isArguments2 = require_is_arguments();
      var isFunction = require_is_function();
      var toPosInt = require_to_pos_integer();
      var callable = require_valid_callable();
      var validValue = require_valid_value();
      var isValue = require_is_value();
      var isString = require_is_string();
      var isArray2 = Array.isArray;
      var call = Function.prototype.call;
      var desc = { configurable: true, enumerable: true, writable: true, value: null };
      var defineProperty = Object.defineProperty;
      module.exports = function(arrayLike) {
        var mapFn = arguments[1], thisArg = arguments[2], Context, i, j, arr, length, code, iterator, result, getIterator, value;
        arrayLike = Object(validValue(arrayLike));
        if (isValue(mapFn))
          callable(mapFn);
        if (!this || this === Array || !isFunction(this)) {
          if (!mapFn) {
            if (isArguments2(arrayLike)) {
              length = arrayLike.length;
              if (length !== 1)
                return Array.apply(null, arrayLike);
              arr = new Array(1);
              arr[0] = arrayLike[0];
              return arr;
            }
            if (isArray2(arrayLike)) {
              arr = new Array(length = arrayLike.length);
              for (i = 0; i < length; ++i)
                arr[i] = arrayLike[i];
              return arr;
            }
          }
          arr = [];
        } else {
          Context = this;
        }
        if (!isArray2(arrayLike)) {
          if ((getIterator = arrayLike[iteratorSymbol]) !== void 0) {
            iterator = callable(getIterator).call(arrayLike);
            if (Context)
              arr = new Context();
            result = iterator.next();
            i = 0;
            while (!result.done) {
              value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
              if (Context) {
                desc.value = value;
                defineProperty(arr, i, desc);
              } else {
                arr[i] = value;
              }
              result = iterator.next();
              ++i;
            }
            length = i;
          } else if (isString(arrayLike)) {
            length = arrayLike.length;
            if (Context)
              arr = new Context();
            for (i = 0, j = 0; i < length; ++i) {
              value = arrayLike[i];
              if (i + 1 < length) {
                code = value.charCodeAt(0);
                if (code >= 55296 && code <= 56319)
                  value += arrayLike[++i];
              }
              value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
              if (Context) {
                desc.value = value;
                defineProperty(arr, j, desc);
              } else {
                arr[j] = value;
              }
              ++j;
            }
            length = j;
          }
        }
        if (length === void 0) {
          length = toPosInt(arrayLike.length);
          if (Context)
            arr = new Context(length);
          for (i = 0; i < length; ++i) {
            value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
            if (Context) {
              desc.value = value;
              defineProperty(arr, i, desc);
            } else {
              arr[i] = value;
            }
          }
        }
        if (Context) {
          desc.value = null;
          arr.length = length;
        }
        return arr;
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/from/index.js
  var require_from = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/from/index.js"(exports, module) {
      "use strict";
      module.exports = require_is_implemented4()() ? Array.from : require_shim5();
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/number/is-nan/is-implemented.js
  var require_is_implemented8 = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/number/is-nan/is-implemented.js"(exports, module) {
      "use strict";
      module.exports = function() {
        var numberIsNaN = Number.isNaN;
        if (typeof numberIsNaN !== "function")
          return false;
        return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/number/is-nan/shim.js
  var require_shim6 = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/number/is-nan/shim.js"(exports, module) {
      "use strict";
      module.exports = function(value) {
        return value !== value;
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/number/is-nan/index.js
  var require_is_nan = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/number/is-nan/index.js"(exports, module) {
      "use strict";
      module.exports = require_is_implemented8()() ? Number.isNaN : require_shim6();
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/#/e-index-of.js
  var require_e_index_of = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/#/e-index-of.js"(exports, module) {
      "use strict";
      var numberIsNaN = require_is_nan();
      var toPosInt = require_to_pos_integer();
      var value = require_valid_value();
      var indexOf2 = Array.prototype.indexOf;
      var objHasOwnProperty = Object.prototype.hasOwnProperty;
      var abs = Math.abs;
      var floor = Math.floor;
      module.exports = function(searchElement) {
        var i, length, fromIndex, val;
        if (!numberIsNaN(searchElement))
          return indexOf2.apply(this, arguments);
        length = toPosInt(value(this).length);
        fromIndex = arguments[1];
        if (isNaN(fromIndex))
          fromIndex = 0;
        else if (fromIndex >= 0)
          fromIndex = floor(fromIndex);
        else
          fromIndex = toPosInt(this.length) - floor(abs(fromIndex));
        for (i = fromIndex; i < length; ++i) {
          if (objHasOwnProperty.call(this, i)) {
            val = this[i];
            if (numberIsNaN(val))
              return i;
          }
        }
        return -1;
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/#/remove.js
  var require_remove = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/#/remove.js"(exports, module) {
      "use strict";
      var indexOf2 = require_e_index_of();
      var forEach = Array.prototype.forEach;
      var splice = Array.prototype.splice;
      module.exports = function(itemToRemove) {
        forEach.call(
          arguments,
          function(item) {
            var index = indexOf2.call(this, item);
            if (index !== -1)
              splice.call(this, index, 1);
          },
          this
        );
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/is-object.js
  var require_is_object = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/is-object.js"(exports, module) {
      "use strict";
      var isValue = require_is_value();
      var map = { function: true, object: true };
      module.exports = function(value) {
        return isValue(value) && map[typeof value] || false;
      };
    }
  });

  // node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/valid-object.js
  var require_valid_object = __commonJS({
    "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/valid-object.js"(exports, module) {
      "use strict";
      var isObject = require_is_object();
      module.exports = function(value) {
        if (!isObject(value))
          throw new TypeError(value + " is not an Object");
        return value;
      };
    }
  });

  // node_modules/.pnpm/event-emitter@0.3.5/node_modules/event-emitter/pipe.js
  var require_pipe = __commonJS({
    "node_modules/.pnpm/event-emitter@0.3.5/node_modules/event-emitter/pipe.js"(exports, module) {
      "use strict";
      var aFrom = require_from();
      var remove = require_remove();
      var value = require_valid_object();
      var d = require_d();
      var emit2 = require_event_emitter().methods.emit;
      var defineProperty = Object.defineProperty;
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      module.exports = function(e1, e2) {
        var pipes, pipe2, desc, name;
        value(e1) && value(e2);
        name = arguments[2];
        if (name === void 0)
          name = "emit";
        pipe2 = {
          close: function() {
            remove.call(pipes, e2);
          }
        };
        if (hasOwnProperty2.call(e1, "__eePipes__")) {
          (pipes = e1.__eePipes__).push(e2);
          return pipe2;
        }
        defineProperty(e1, "__eePipes__", d("c", pipes = [e2]));
        desc = getOwnPropertyDescriptor(e1, name);
        if (!desc) {
          desc = d("c", void 0);
        } else {
          delete desc.get;
          delete desc.set;
        }
        desc.value = function() {
          var i, emitter, data = aFrom(pipes);
          emit2.apply(this, arguments);
          for (i = 0; emitter = data[i]; ++i)
            emit2.apply(emitter, arguments);
        };
        defineProperty(e1, name, desc);
        return pipe2;
      };
    }
  });

  // node_modules/.pnpm/@sinclair+typebox@0.31.18/node_modules/@sinclair/typebox/typebox.js
  var require_typebox = __commonJS({
    "node_modules/.pnpm/@sinclair+typebox@0.31.18/node_modules/@sinclair/typebox/typebox.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Type = exports.JsonType = exports.JavaScriptTypeBuilder = exports.JsonTypeBuilder = exports.TypeBuilder = exports.TypeBuilderError = exports.TransformEncodeBuilder = exports.TransformDecodeBuilder = exports.TemplateLiteralDslParser = exports.TemplateLiteralGenerator = exports.TemplateLiteralGeneratorError = exports.TemplateLiteralFinite = exports.TemplateLiteralFiniteError = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.TemplateLiteralPatternError = exports.UnionResolver = exports.KeyArrayResolver = exports.KeyArrayResolverError = exports.KeyResolver = exports.ObjectMap = exports.Intrinsic = exports.IndexedAccessor = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.TypeExtendsError = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.ValueGuard = exports.FormatRegistry = exports.TypeBoxError = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Optional = exports.Readonly = exports.Transform = void 0;
      exports.Transform = Symbol.for("TypeBox.Transform");
      exports.Readonly = Symbol.for("TypeBox.Readonly");
      exports.Optional = Symbol.for("TypeBox.Optional");
      exports.Hint = Symbol.for("TypeBox.Hint");
      exports.Kind = Symbol.for("TypeBox.Kind");
      exports.PatternBoolean = "(true|false)";
      exports.PatternNumber = "(0|[1-9][0-9]*)";
      exports.PatternString = "(.*)";
      exports.PatternBooleanExact = `^${exports.PatternBoolean}$`;
      exports.PatternNumberExact = `^${exports.PatternNumber}$`;
      exports.PatternStringExact = `^${exports.PatternString}$`;
      var TypeRegistry2;
      (function(TypeRegistry3) {
        const map = /* @__PURE__ */ new Map();
        function Entries() {
          return new Map(map);
        }
        TypeRegistry3.Entries = Entries;
        function Clear() {
          return map.clear();
        }
        TypeRegistry3.Clear = Clear;
        function Delete(kind) {
          return map.delete(kind);
        }
        TypeRegistry3.Delete = Delete;
        function Has(kind) {
          return map.has(kind);
        }
        TypeRegistry3.Has = Has;
        function Set2(kind, func) {
          map.set(kind, func);
        }
        TypeRegistry3.Set = Set2;
        function Get(kind) {
          return map.get(kind);
        }
        TypeRegistry3.Get = Get;
      })(TypeRegistry2 || (exports.TypeRegistry = TypeRegistry2 = {}));
      var TypeBoxError = class extends Error {
        constructor(message) {
          super(message);
        }
      };
      exports.TypeBoxError = TypeBoxError;
      var FormatRegistry;
      (function(FormatRegistry2) {
        const map = /* @__PURE__ */ new Map();
        function Entries() {
          return new Map(map);
        }
        FormatRegistry2.Entries = Entries;
        function Clear() {
          return map.clear();
        }
        FormatRegistry2.Clear = Clear;
        function Delete(format2) {
          return map.delete(format2);
        }
        FormatRegistry2.Delete = Delete;
        function Has(format2) {
          return map.has(format2);
        }
        FormatRegistry2.Has = Has;
        function Set2(format2, func) {
          map.set(format2, func);
        }
        FormatRegistry2.Set = Set2;
        function Get(format2) {
          return map.get(format2);
        }
        FormatRegistry2.Get = Get;
      })(FormatRegistry || (exports.FormatRegistry = FormatRegistry = {}));
      var ValueGuard;
      (function(ValueGuard2) {
        function IsArray(value) {
          return Array.isArray(value);
        }
        ValueGuard2.IsArray = IsArray;
        function IsBigInt(value) {
          return typeof value === "bigint";
        }
        ValueGuard2.IsBigInt = IsBigInt;
        function IsBoolean(value) {
          return typeof value === "boolean";
        }
        ValueGuard2.IsBoolean = IsBoolean;
        function IsNull(value) {
          return value === null;
        }
        ValueGuard2.IsNull = IsNull;
        function IsNumber(value) {
          return typeof value === "number";
        }
        ValueGuard2.IsNumber = IsNumber;
        function IsObject(value) {
          return typeof value === "object" && value !== null;
        }
        ValueGuard2.IsObject = IsObject;
        function IsString(value) {
          return typeof value === "string";
        }
        ValueGuard2.IsString = IsString;
        function IsUndefined(value) {
          return value === void 0;
        }
        ValueGuard2.IsUndefined = IsUndefined;
      })(ValueGuard || (exports.ValueGuard = ValueGuard = {}));
      var TypeGuardUnknownTypeError = class extends TypeBoxError {
      };
      exports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
      var TypeGuard;
      (function(TypeGuard2) {
        function IsPattern(value) {
          try {
            new RegExp(value);
            return true;
          } catch {
            return false;
          }
        }
        function IsControlCharacterFree(value) {
          if (!ValueGuard.IsString(value))
            return false;
          for (let i = 0; i < value.length; i++) {
            const code = value.charCodeAt(i);
            if (code >= 7 && code <= 13 || code === 27 || code === 127) {
              return false;
            }
          }
          return true;
        }
        function IsAdditionalProperties(value) {
          return IsOptionalBoolean(value) || TSchema(value);
        }
        function IsOptionalBigInt(value) {
          return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);
        }
        function IsOptionalNumber(value) {
          return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);
        }
        function IsOptionalBoolean(value) {
          return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);
        }
        function IsOptionalString(value) {
          return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);
        }
        function IsOptionalPattern(value) {
          return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
        }
        function IsOptionalFormat(value) {
          return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value);
        }
        function IsOptionalSchema(value) {
          return ValueGuard.IsUndefined(value) || TSchema(value);
        }
        function TAny(schema) {
          return TKindOf(schema, "Any") && IsOptionalString(schema.$id);
        }
        TypeGuard2.TAny = TAny;
        function TArray(schema) {
          return TKindOf(schema, "Array") && schema.type === "array" && IsOptionalString(schema.$id) && TSchema(schema.items) && IsOptionalNumber(schema.minItems) && IsOptionalNumber(schema.maxItems) && IsOptionalBoolean(schema.uniqueItems) && IsOptionalSchema(schema.contains) && IsOptionalNumber(schema.minContains) && IsOptionalNumber(schema.maxContains);
        }
        TypeGuard2.TArray = TArray;
        function TAsyncIterator(schema) {
          return TKindOf(schema, "AsyncIterator") && schema.type === "AsyncIterator" && IsOptionalString(schema.$id) && TSchema(schema.items);
        }
        TypeGuard2.TAsyncIterator = TAsyncIterator;
        function TBigInt(schema) {
          return TKindOf(schema, "BigInt") && schema.type === "bigint" && IsOptionalString(schema.$id) && IsOptionalBigInt(schema.exclusiveMaximum) && IsOptionalBigInt(schema.exclusiveMinimum) && IsOptionalBigInt(schema.maximum) && IsOptionalBigInt(schema.minimum) && IsOptionalBigInt(schema.multipleOf);
        }
        TypeGuard2.TBigInt = TBigInt;
        function TBoolean(schema) {
          return TKindOf(schema, "Boolean") && schema.type === "boolean" && IsOptionalString(schema.$id);
        }
        TypeGuard2.TBoolean = TBoolean;
        function TConstructor(schema) {
          return TKindOf(schema, "Constructor") && schema.type === "Constructor" && IsOptionalString(schema.$id) && ValueGuard.IsArray(schema.parameters) && schema.parameters.every((schema2) => TSchema(schema2)) && TSchema(schema.returns);
        }
        TypeGuard2.TConstructor = TConstructor;
        function TDate(schema) {
          return TKindOf(schema, "Date") && schema.type === "Date" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximumTimestamp) && IsOptionalNumber(schema.exclusiveMinimumTimestamp) && IsOptionalNumber(schema.maximumTimestamp) && IsOptionalNumber(schema.minimumTimestamp) && IsOptionalNumber(schema.multipleOfTimestamp);
        }
        TypeGuard2.TDate = TDate;
        function TFunction(schema) {
          return TKindOf(schema, "Function") && schema.type === "Function" && IsOptionalString(schema.$id) && ValueGuard.IsArray(schema.parameters) && schema.parameters.every((schema2) => TSchema(schema2)) && TSchema(schema.returns);
        }
        TypeGuard2.TFunction = TFunction;
        function TInteger(schema) {
          return TKindOf(schema, "Integer") && schema.type === "integer" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.multipleOf);
        }
        TypeGuard2.TInteger = TInteger;
        function TIntersect(schema) {
          return TKindOf(schema, "Intersect") && (ValueGuard.IsString(schema.type) && schema.type !== "object" ? false : true) && ValueGuard.IsArray(schema.allOf) && schema.allOf.every((schema2) => TSchema(schema2) && !TTransform(schema2)) && IsOptionalString(schema.type) && (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) && IsOptionalString(schema.$id);
        }
        TypeGuard2.TIntersect = TIntersect;
        function TIterator(schema) {
          return TKindOf(schema, "Iterator") && schema.type === "Iterator" && IsOptionalString(schema.$id) && TSchema(schema.items);
        }
        TypeGuard2.TIterator = TIterator;
        function TKindOf(schema, kind) {
          return TKind(schema) && schema[exports.Kind] === kind;
        }
        TypeGuard2.TKindOf = TKindOf;
        function TKind(schema) {
          return ValueGuard.IsObject(schema) && exports.Kind in schema && ValueGuard.IsString(schema[exports.Kind]);
        }
        TypeGuard2.TKind = TKind;
        function TLiteralString(schema) {
          return TLiteral(schema) && ValueGuard.IsString(schema.const);
        }
        TypeGuard2.TLiteralString = TLiteralString;
        function TLiteralNumber(schema) {
          return TLiteral(schema) && ValueGuard.IsNumber(schema.const);
        }
        TypeGuard2.TLiteralNumber = TLiteralNumber;
        function TLiteralBoolean(schema) {
          return TLiteral(schema) && ValueGuard.IsBoolean(schema.const);
        }
        TypeGuard2.TLiteralBoolean = TLiteralBoolean;
        function TLiteral(schema) {
          return TKindOf(schema, "Literal") && IsOptionalString(schema.$id) && (ValueGuard.IsBoolean(schema.const) || ValueGuard.IsNumber(schema.const) || ValueGuard.IsString(schema.const));
        }
        TypeGuard2.TLiteral = TLiteral;
        function TNever(schema) {
          return TKindOf(schema, "Never") && ValueGuard.IsObject(schema.not) && Object.getOwnPropertyNames(schema.not).length === 0;
        }
        TypeGuard2.TNever = TNever;
        function TNot(schema) {
          return TKindOf(schema, "Not") && TSchema(schema.not);
        }
        TypeGuard2.TNot = TNot;
        function TNull(schema) {
          return TKindOf(schema, "Null") && schema.type === "null" && IsOptionalString(schema.$id);
        }
        TypeGuard2.TNull = TNull;
        function TNumber(schema) {
          return TKindOf(schema, "Number") && schema.type === "number" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.multipleOf);
        }
        TypeGuard2.TNumber = TNumber;
        function TObject(schema) {
          return TKindOf(schema, "Object") && schema.type === "object" && IsOptionalString(schema.$id) && ValueGuard.IsObject(schema.properties) && IsAdditionalProperties(schema.additionalProperties) && IsOptionalNumber(schema.minProperties) && IsOptionalNumber(schema.maxProperties) && Object.entries(schema.properties).every(([key, schema2]) => IsControlCharacterFree(key) && TSchema(schema2));
        }
        TypeGuard2.TObject = TObject;
        function TPromise(schema) {
          return TKindOf(schema, "Promise") && schema.type === "Promise" && IsOptionalString(schema.$id) && TSchema(schema.item);
        }
        TypeGuard2.TPromise = TPromise;
        function TRecord(schema) {
          return TKindOf(schema, "Record") && schema.type === "object" && IsOptionalString(schema.$id) && IsAdditionalProperties(schema.additionalProperties) && ValueGuard.IsObject(schema.patternProperties) && ((schema2) => {
            const keys = Object.getOwnPropertyNames(schema2.patternProperties);
            return keys.length === 1 && IsPattern(keys[0]) && ValueGuard.IsObject(schema2.patternProperties) && TSchema(schema2.patternProperties[keys[0]]);
          })(schema);
        }
        TypeGuard2.TRecord = TRecord;
        function TRecursive(schema) {
          return ValueGuard.IsObject(schema) && exports.Hint in schema && schema[exports.Hint] === "Recursive";
        }
        TypeGuard2.TRecursive = TRecursive;
        function TRef(schema) {
          return TKindOf(schema, "Ref") && IsOptionalString(schema.$id) && ValueGuard.IsString(schema.$ref);
        }
        TypeGuard2.TRef = TRef;
        function TString(schema) {
          return TKindOf(schema, "String") && schema.type === "string" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minLength) && IsOptionalNumber(schema.maxLength) && IsOptionalPattern(schema.pattern) && IsOptionalFormat(schema.format);
        }
        TypeGuard2.TString = TString;
        function TSymbol(schema) {
          return TKindOf(schema, "Symbol") && schema.type === "symbol" && IsOptionalString(schema.$id);
        }
        TypeGuard2.TSymbol = TSymbol;
        function TTemplateLiteral(schema) {
          return TKindOf(schema, "TemplateLiteral") && schema.type === "string" && ValueGuard.IsString(schema.pattern) && schema.pattern[0] === "^" && schema.pattern[schema.pattern.length - 1] === "$";
        }
        TypeGuard2.TTemplateLiteral = TTemplateLiteral;
        function TThis(schema) {
          return TKindOf(schema, "This") && IsOptionalString(schema.$id) && ValueGuard.IsString(schema.$ref);
        }
        TypeGuard2.TThis = TThis;
        function TTransform(schema) {
          return ValueGuard.IsObject(schema) && exports.Transform in schema;
        }
        TypeGuard2.TTransform = TTransform;
        function TTuple(schema) {
          return TKindOf(schema, "Tuple") && schema.type === "array" && IsOptionalString(schema.$id) && ValueGuard.IsNumber(schema.minItems) && ValueGuard.IsNumber(schema.maxItems) && schema.minItems === schema.maxItems && // empty
          (ValueGuard.IsUndefined(schema.items) && ValueGuard.IsUndefined(schema.additionalItems) && schema.minItems === 0 || ValueGuard.IsArray(schema.items) && schema.items.every((schema2) => TSchema(schema2)));
        }
        TypeGuard2.TTuple = TTuple;
        function TUndefined(schema) {
          return TKindOf(schema, "Undefined") && schema.type === "undefined" && IsOptionalString(schema.$id);
        }
        TypeGuard2.TUndefined = TUndefined;
        function TUnionLiteral(schema) {
          return TUnion(schema) && schema.anyOf.every((schema2) => TLiteralString(schema2) || TLiteralNumber(schema2));
        }
        TypeGuard2.TUnionLiteral = TUnionLiteral;
        function TUnion(schema) {
          return TKindOf(schema, "Union") && IsOptionalString(schema.$id) && ValueGuard.IsObject(schema) && ValueGuard.IsArray(schema.anyOf) && schema.anyOf.every((schema2) => TSchema(schema2));
        }
        TypeGuard2.TUnion = TUnion;
        function TUint8Array(schema) {
          return TKindOf(schema, "Uint8Array") && schema.type === "Uint8Array" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minByteLength) && IsOptionalNumber(schema.maxByteLength);
        }
        TypeGuard2.TUint8Array = TUint8Array;
        function TUnknown(schema) {
          return TKindOf(schema, "Unknown") && IsOptionalString(schema.$id);
        }
        TypeGuard2.TUnknown = TUnknown;
        function TUnsafe(schema) {
          return TKindOf(schema, "Unsafe");
        }
        TypeGuard2.TUnsafe = TUnsafe;
        function TVoid(schema) {
          return TKindOf(schema, "Void") && schema.type === "void" && IsOptionalString(schema.$id);
        }
        TypeGuard2.TVoid = TVoid;
        function TReadonly(schema) {
          return ValueGuard.IsObject(schema) && schema[exports.Readonly] === "Readonly";
        }
        TypeGuard2.TReadonly = TReadonly;
        function TOptional(schema) {
          return ValueGuard.IsObject(schema) && schema[exports.Optional] === "Optional";
        }
        TypeGuard2.TOptional = TOptional;
        function TSchema(schema) {
          return ValueGuard.IsObject(schema) && (TAny(schema) || TArray(schema) || TBoolean(schema) || TBigInt(schema) || TAsyncIterator(schema) || TConstructor(schema) || TDate(schema) || TFunction(schema) || TInteger(schema) || TIntersect(schema) || TIterator(schema) || TLiteral(schema) || TNever(schema) || TNot(schema) || TNull(schema) || TNumber(schema) || TObject(schema) || TPromise(schema) || TRecord(schema) || TRef(schema) || TString(schema) || TSymbol(schema) || TTemplateLiteral(schema) || TThis(schema) || TTuple(schema) || TUndefined(schema) || TUnion(schema) || TUint8Array(schema) || TUnknown(schema) || TUnsafe(schema) || TVoid(schema) || TKind(schema) && TypeRegistry2.Has(schema[exports.Kind]));
        }
        TypeGuard2.TSchema = TSchema;
      })(TypeGuard || (exports.TypeGuard = TypeGuard = {}));
      var ExtendsUndefined;
      (function(ExtendsUndefined2) {
        function Check(schema) {
          return schema[exports.Kind] === "Intersect" ? schema.allOf.every((schema2) => Check(schema2)) : schema[exports.Kind] === "Union" ? schema.anyOf.some((schema2) => Check(schema2)) : schema[exports.Kind] === "Undefined" ? true : schema[exports.Kind] === "Not" ? !Check(schema.not) : false;
        }
        ExtendsUndefined2.Check = Check;
      })(ExtendsUndefined || (exports.ExtendsUndefined = ExtendsUndefined = {}));
      var TypeExtendsError = class extends TypeBoxError {
      };
      exports.TypeExtendsError = TypeExtendsError;
      var TypeExtendsResult;
      (function(TypeExtendsResult2) {
        TypeExtendsResult2[TypeExtendsResult2["Union"] = 0] = "Union";
        TypeExtendsResult2[TypeExtendsResult2["True"] = 1] = "True";
        TypeExtendsResult2[TypeExtendsResult2["False"] = 2] = "False";
      })(TypeExtendsResult || (exports.TypeExtendsResult = TypeExtendsResult = {}));
      var TypeExtends;
      (function(TypeExtends2) {
        function IntoBooleanResult(result) {
          return result === TypeExtendsResult.False ? result : TypeExtendsResult.True;
        }
        function Throw(message) {
          throw new TypeExtendsError(message);
        }
        function IsStructuralRight(right) {
          return TypeGuard.TNever(right) || TypeGuard.TIntersect(right) || TypeGuard.TUnion(right) || TypeGuard.TUnknown(right) || TypeGuard.TAny(right);
        }
        function StructuralRight(left, right) {
          return TypeGuard.TNever(right) ? TNeverRight(left, right) : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : Throw("StructuralRight");
        }
        function TAnyRight(left, right) {
          return TypeExtendsResult.True;
        }
        function TAny(left, right) {
          return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) && right.anyOf.some((schema) => TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema)) ? TypeExtendsResult.True : TypeGuard.TUnion(right) ? TypeExtendsResult.Union : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeGuard.TAny(right) ? TypeExtendsResult.True : TypeExtendsResult.Union;
        }
        function TArrayRight(left, right) {
          return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TArray(left, right) {
          return TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TArray(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
        }
        function TAsyncIterator(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TAsyncIterator(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
        }
        function TBigInt(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TBooleanRight(left, right) {
          return TypeGuard.TLiteral(left) && ValueGuard.IsBoolean(left.const) ? TypeExtendsResult.True : TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TBoolean(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TConstructor(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TConstructor(right) ? TypeExtendsResult.False : left.parameters.length > right.parameters.length ? TypeExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
        }
        function TDate(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TFunction(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TFunction(right) ? TypeExtendsResult.False : left.parameters.length > right.parameters.length ? TypeExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
        }
        function TIntegerRight(left, right) {
          return TypeGuard.TLiteral(left) && ValueGuard.IsNumber(left.const) ? TypeExtendsResult.True : TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TInteger(left, right) {
          return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeExtendsResult.False;
        }
        function TIntersectRight(left, right) {
          return right.allOf.every((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TIntersect(left, right) {
          return left.allOf.some((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TIterator(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TIterator(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
        }
        function TLiteral(left, right) {
          return TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TStringRight(left, right) : TypeGuard.TNumber(right) ? TNumberRight(left, right) : TypeGuard.TInteger(right) ? TIntegerRight(left, right) : TypeGuard.TBoolean(right) ? TBooleanRight(left, right) : TypeExtendsResult.False;
        }
        function TNeverRight(left, right) {
          return TypeExtendsResult.False;
        }
        function TNever(left, right) {
          return TypeExtendsResult.True;
        }
        function UnwrapTNot(schema) {
          let [current, depth] = [schema, 0];
          while (true) {
            if (!TypeGuard.TNot(current))
              break;
            current = current.not;
            depth += 1;
          }
          return depth % 2 === 0 ? current : exports.Type.Unknown();
        }
        function TNot(left, right) {
          return TypeGuard.TNot(left) ? Visit(UnwrapTNot(left), right) : TypeGuard.TNot(right) ? Visit(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
        }
        function TNull(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TNumberRight(left, right) {
          return TypeGuard.TLiteralNumber(left) ? TypeExtendsResult.True : TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TNumber(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function IsObjectPropertyCount(schema, count) {
          return Object.getOwnPropertyNames(schema.properties).length === count;
        }
        function IsObjectStringLike(schema) {
          return IsObjectArrayLike(schema);
        }
        function IsObjectSymbolLike(schema) {
          return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (TypeGuard.TString(schema.properties.description.anyOf[0]) && TypeGuard.TUndefined(schema.properties.description.anyOf[1]) || TypeGuard.TString(schema.properties.description.anyOf[1]) && TypeGuard.TUndefined(schema.properties.description.anyOf[0]));
        }
        function IsObjectNumberLike(schema) {
          return IsObjectPropertyCount(schema, 0);
        }
        function IsObjectBooleanLike(schema) {
          return IsObjectPropertyCount(schema, 0);
        }
        function IsObjectBigIntLike(schema) {
          return IsObjectPropertyCount(schema, 0);
        }
        function IsObjectDateLike(schema) {
          return IsObjectPropertyCount(schema, 0);
        }
        function IsObjectUint8ArrayLike(schema) {
          return IsObjectArrayLike(schema);
        }
        function IsObjectFunctionLike(schema) {
          const length = exports.Type.Number();
          return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === TypeExtendsResult.True;
        }
        function IsObjectConstructorLike(schema) {
          return IsObjectPropertyCount(schema, 0);
        }
        function IsObjectArrayLike(schema) {
          const length = exports.Type.Number();
          return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === TypeExtendsResult.True;
        }
        function IsObjectPromiseLike(schema) {
          const then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());
          return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit(schema.properties["then"], then)) === TypeExtendsResult.True;
        }
        function Property(left, right) {
          return Visit(left, right) === TypeExtendsResult.False ? TypeExtendsResult.False : TypeGuard.TOptional(left) && !TypeGuard.TOptional(right) ? TypeExtendsResult.False : TypeExtendsResult.True;
        }
        function TObjectRight(left, right) {
          return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) || TypeGuard.TLiteralString(left) && IsObjectStringLike(right) || TypeGuard.TLiteralNumber(left) && IsObjectNumberLike(right) || TypeGuard.TLiteralBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TBigInt(left) && IsObjectBigIntLike(right) || TypeGuard.TString(left) && IsObjectStringLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TNumber(left) && IsObjectNumberLike(right) || TypeGuard.TInteger(left) && IsObjectNumberLike(right) || TypeGuard.TBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right) || TypeGuard.TDate(left) && IsObjectDateLike(right) || TypeGuard.TConstructor(left) && IsObjectConstructorLike(right) || TypeGuard.TFunction(left) && IsObjectFunctionLike(right) ? TypeExtendsResult.True : TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left)) ? (() => {
            return right[exports.Hint] === "Record" ? TypeExtendsResult.True : TypeExtendsResult.False;
          })() : TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left)) ? (() => {
            return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;
          })() : TypeExtendsResult.False;
        }
        function TObject(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : !TypeGuard.TObject(right) ? TypeExtendsResult.False : (() => {
            for (const key of Object.getOwnPropertyNames(right.properties)) {
              if (!(key in left.properties))
                return TypeExtendsResult.False;
              if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {
                return TypeExtendsResult.False;
              }
            }
            return TypeExtendsResult.True;
          })();
        }
        function TPromise(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectPromiseLike(right) ? TypeExtendsResult.True : !TypeGuard.TPromise(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.item, right.item));
        }
        function RecordKey(schema) {
          return exports.PatternNumberExact in schema.patternProperties ? exports.Type.Number() : exports.PatternStringExact in schema.patternProperties ? exports.Type.String() : Throw("Unknown record key pattern");
        }
        function RecordValue(schema) {
          return exports.PatternNumberExact in schema.patternProperties ? schema.patternProperties[exports.PatternNumberExact] : exports.PatternStringExact in schema.patternProperties ? schema.patternProperties[exports.PatternStringExact] : Throw("Unable to get record value schema");
        }
        function TRecordRight(left, right) {
          const [Key, Value] = [RecordKey(right), RecordValue(right)];
          return TypeGuard.TLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True ? TypeExtendsResult.True : TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TString(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TArray(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TObject(left) ? (() => {
            for (const key of Object.getOwnPropertyNames(left.properties)) {
              if (Property(Value, left.properties[key]) === TypeExtendsResult.False) {
                return TypeExtendsResult.False;
              }
            }
            return TypeExtendsResult.True;
          })() : TypeExtendsResult.False;
        }
        function TRecord(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TRecord(right) ? TypeExtendsResult.False : Visit(RecordValue(left), RecordValue(right));
        }
        function TStringRight(left, right) {
          return TypeGuard.TLiteral(left) && ValueGuard.IsString(left.const) ? TypeExtendsResult.True : TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TString(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TSymbol(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TTemplateLiteral(left, right) {
          return TypeGuard.TTemplateLiteral(left) ? Visit(TemplateLiteralResolver.Resolve(left), right) : TypeGuard.TTemplateLiteral(right) ? Visit(left, TemplateLiteralResolver.Resolve(right)) : Throw("Invalid fallthrough for TemplateLiteral");
        }
        function IsArrayOfTuple(left, right) {
          return TypeGuard.TArray(right) && left.items !== void 0 && left.items.every((schema) => Visit(schema, right.items) === TypeExtendsResult.True);
        }
        function TTupleRight(left, right) {
          return TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeExtendsResult.False;
        }
        function TTuple(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : TypeGuard.TArray(right) && IsArrayOfTuple(left, right) ? TypeExtendsResult.True : !TypeGuard.TTuple(right) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) || !ValueGuard.IsUndefined(left.items) && ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.True : left.items.every((schema, index) => Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TUint8Array(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TUndefined(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TVoid(right) ? VoidRight(left, right) : TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TUnionRight(left, right) {
          return right.anyOf.some((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TUnion(left, right) {
          return left.anyOf.every((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TUnknownRight(left, right) {
          return TypeExtendsResult.True;
        }
        function TUnknown(left, right) {
          return TypeGuard.TNever(right) ? TNeverRight(left, right) : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : TypeGuard.TString(right) ? TStringRight(left, right) : TypeGuard.TNumber(right) ? TNumberRight(left, right) : TypeGuard.TInteger(right) ? TIntegerRight(left, right) : TypeGuard.TBoolean(right) ? TBooleanRight(left, right) : TypeGuard.TArray(right) ? TArrayRight(left, right) : TypeGuard.TTuple(right) ? TTupleRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function VoidRight(left, right) {
          return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TVoid(left, right) {
          return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function Visit(left, right) {
          return (
            // resolvable
            TypeGuard.TTemplateLiteral(left) || TypeGuard.TTemplateLiteral(right) ? TTemplateLiteral(left, right) : TypeGuard.TNot(left) || TypeGuard.TNot(right) ? TNot(left, right) : (
              // standard
              TypeGuard.TAny(left) ? TAny(left, right) : TypeGuard.TArray(left) ? TArray(left, right) : TypeGuard.TBigInt(left) ? TBigInt(left, right) : TypeGuard.TBoolean(left) ? TBoolean(left, right) : TypeGuard.TAsyncIterator(left) ? TAsyncIterator(left, right) : TypeGuard.TConstructor(left) ? TConstructor(left, right) : TypeGuard.TDate(left) ? TDate(left, right) : TypeGuard.TFunction(left) ? TFunction(left, right) : TypeGuard.TInteger(left) ? TInteger(left, right) : TypeGuard.TIntersect(left) ? TIntersect(left, right) : TypeGuard.TIterator(left) ? TIterator(left, right) : TypeGuard.TLiteral(left) ? TLiteral(left, right) : TypeGuard.TNever(left) ? TNever(left, right) : TypeGuard.TNull(left) ? TNull(left, right) : TypeGuard.TNumber(left) ? TNumber(left, right) : TypeGuard.TObject(left) ? TObject(left, right) : TypeGuard.TRecord(left) ? TRecord(left, right) : TypeGuard.TString(left) ? TString(left, right) : TypeGuard.TSymbol(left) ? TSymbol(left, right) : TypeGuard.TTuple(left) ? TTuple(left, right) : TypeGuard.TPromise(left) ? TPromise(left, right) : TypeGuard.TUint8Array(left) ? TUint8Array(left, right) : TypeGuard.TUndefined(left) ? TUndefined(left, right) : TypeGuard.TUnion(left) ? TUnion(left, right) : TypeGuard.TUnknown(left) ? TUnknown(left, right) : TypeGuard.TVoid(left) ? TVoid(left, right) : Throw(`Unknown left type operand '${left[exports.Kind]}'`)
            )
          );
        }
        function Extends(left, right) {
          return Visit(left, right);
        }
        TypeExtends2.Extends = Extends;
      })(TypeExtends || (exports.TypeExtends = TypeExtends = {}));
      var TypeClone;
      (function(TypeClone2) {
        function ObjectType(value) {
          const clonedProperties = Object.getOwnPropertyNames(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
          const clonedSymbols = Object.getOwnPropertySymbols(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
          return { ...clonedProperties, ...clonedSymbols };
        }
        function ArrayType(value) {
          return value.map((value2) => Visit(value2));
        }
        function Visit(value) {
          return ValueGuard.IsArray(value) ? ArrayType(value) : ValueGuard.IsObject(value) ? ObjectType(value) : value;
        }
        function Rest(schemas) {
          return schemas.map((schema) => Type3(schema));
        }
        TypeClone2.Rest = Rest;
        function Type3(schema, options = {}) {
          return { ...Visit(schema), ...options };
        }
        TypeClone2.Type = Type3;
      })(TypeClone || (exports.TypeClone = TypeClone = {}));
      var IndexedAccessor;
      (function(IndexedAccessor2) {
        function OptionalUnwrap(schema) {
          return schema.map((schema2) => {
            const { [exports.Optional]: _, ...clone } = TypeClone.Type(schema2);
            return clone;
          });
        }
        function IsIntersectOptional(schema) {
          return schema.every((schema2) => TypeGuard.TOptional(schema2));
        }
        function IsUnionOptional(schema) {
          return schema.some((schema2) => TypeGuard.TOptional(schema2));
        }
        function ResolveIntersect(schema) {
          return IsIntersectOptional(schema.allOf) ? exports.Type.Optional(exports.Type.Intersect(OptionalUnwrap(schema.allOf))) : schema;
        }
        function ResolveUnion(schema) {
          return IsUnionOptional(schema.anyOf) ? exports.Type.Optional(exports.Type.Union(OptionalUnwrap(schema.anyOf))) : schema;
        }
        function ResolveOptional(schema) {
          return schema[exports.Kind] === "Intersect" ? ResolveIntersect(schema) : schema[exports.Kind] === "Union" ? ResolveUnion(schema) : schema;
        }
        function TIntersect(schema, key) {
          const resolved = schema.allOf.reduce((acc, schema2) => {
            const indexed = Visit(schema2, key);
            return indexed[exports.Kind] === "Never" ? acc : [...acc, indexed];
          }, []);
          return ResolveOptional(exports.Type.Intersect(resolved));
        }
        function TUnion(schema, key) {
          const resolved = schema.anyOf.map((schema2) => Visit(schema2, key));
          return ResolveOptional(exports.Type.Union(resolved));
        }
        function TObject(schema, key) {
          const property = schema.properties[key];
          return ValueGuard.IsUndefined(property) ? exports.Type.Never() : exports.Type.Union([property]);
        }
        function TTuple(schema, key) {
          const items = schema.items;
          if (ValueGuard.IsUndefined(items))
            return exports.Type.Never();
          const element2 = items[key];
          if (ValueGuard.IsUndefined(element2))
            return exports.Type.Never();
          return element2;
        }
        function Visit(schema, key) {
          return schema[exports.Kind] === "Intersect" ? TIntersect(schema, key) : schema[exports.Kind] === "Union" ? TUnion(schema, key) : schema[exports.Kind] === "Object" ? TObject(schema, key) : schema[exports.Kind] === "Tuple" ? TTuple(schema, key) : exports.Type.Never();
        }
        function Resolve(schema, keys, options = {}) {
          const resolved = keys.map((key) => Visit(schema, key.toString()));
          return ResolveOptional(exports.Type.Union(resolved, options));
        }
        IndexedAccessor2.Resolve = Resolve;
      })(IndexedAccessor || (exports.IndexedAccessor = IndexedAccessor = {}));
      var Intrinsic;
      (function(Intrinsic2) {
        function Uncapitalize(value) {
          const [first, rest] = [value.slice(0, 1), value.slice(1)];
          return `${first.toLowerCase()}${rest}`;
        }
        function Capitalize(value) {
          const [first, rest] = [value.slice(0, 1), value.slice(1)];
          return `${first.toUpperCase()}${rest}`;
        }
        function Uppercase(value) {
          return value.toUpperCase();
        }
        function Lowercase(value) {
          return value.toLowerCase();
        }
        function IntrinsicTemplateLiteral(schema, mode) {
          const expression = TemplateLiteralParser.ParseExact(schema.pattern);
          const finite = TemplateLiteralFinite.Check(expression);
          if (!finite)
            return { ...schema, pattern: IntrinsicLiteral(schema.pattern, mode) };
          const strings = [...TemplateLiteralGenerator.Generate(expression)];
          const literals = strings.map((value) => exports.Type.Literal(value));
          const mapped = IntrinsicRest(literals, mode);
          const union = exports.Type.Union(mapped);
          return exports.Type.TemplateLiteral([union]);
        }
        function IntrinsicLiteral(value, mode) {
          return typeof value === "string" ? mode === "Uncapitalize" ? Uncapitalize(value) : mode === "Capitalize" ? Capitalize(value) : mode === "Uppercase" ? Uppercase(value) : mode === "Lowercase" ? Lowercase(value) : value : value.toString();
        }
        function IntrinsicRest(schema, mode) {
          if (schema.length === 0)
            return [];
          const [L, ...R2] = schema;
          return [Map2(L, mode), ...IntrinsicRest(R2, mode)];
        }
        function Visit(schema, mode) {
          return TypeGuard.TTemplateLiteral(schema) ? IntrinsicTemplateLiteral(schema, mode) : TypeGuard.TUnion(schema) ? exports.Type.Union(IntrinsicRest(schema.anyOf, mode)) : TypeGuard.TLiteral(schema) ? exports.Type.Literal(IntrinsicLiteral(schema.const, mode)) : schema;
        }
        function Map2(schema, mode) {
          return Visit(schema, mode);
        }
        Intrinsic2.Map = Map2;
      })(Intrinsic || (exports.Intrinsic = Intrinsic = {}));
      var ObjectMap;
      (function(ObjectMap2) {
        function TIntersect(schema, callback) {
          return exports.Type.Intersect(schema.allOf.map((inner) => Visit(inner, callback)), { ...schema });
        }
        function TUnion(schema, callback) {
          return exports.Type.Union(schema.anyOf.map((inner) => Visit(inner, callback)), { ...schema });
        }
        function TObject(schema, callback) {
          return callback(schema);
        }
        function Visit(schema, callback) {
          return schema[exports.Kind] === "Intersect" ? TIntersect(schema, callback) : schema[exports.Kind] === "Union" ? TUnion(schema, callback) : schema[exports.Kind] === "Object" ? TObject(schema, callback) : schema;
        }
        function Map2(schema, callback, options) {
          return { ...Visit(TypeClone.Type(schema), callback), ...options };
        }
        ObjectMap2.Map = Map2;
      })(ObjectMap || (exports.ObjectMap = ObjectMap = {}));
      var KeyResolver;
      (function(KeyResolver2) {
        function UnwrapPattern(key) {
          return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
        }
        function TIntersect(schema, options) {
          return schema.allOf.reduce((acc, schema2) => [...acc, ...Visit(schema2, options)], []);
        }
        function TUnion(schema, options) {
          const sets = schema.anyOf.map((inner) => Visit(inner, options));
          return [...sets.reduce((set, outer) => outer.map((key) => sets.every((inner) => inner.includes(key)) ? set.add(key) : set)[0], /* @__PURE__ */ new Set())];
        }
        function TObject(schema, options) {
          return Object.getOwnPropertyNames(schema.properties);
        }
        function TRecord(schema, options) {
          return options.includePatterns ? Object.getOwnPropertyNames(schema.patternProperties) : [];
        }
        function Visit(schema, options) {
          return TypeGuard.TIntersect(schema) ? TIntersect(schema, options) : TypeGuard.TUnion(schema) ? TUnion(schema, options) : TypeGuard.TObject(schema) ? TObject(schema, options) : TypeGuard.TRecord(schema) ? TRecord(schema, options) : [];
        }
        function ResolveKeys(schema, options) {
          return [...new Set(Visit(schema, options))];
        }
        KeyResolver2.ResolveKeys = ResolveKeys;
        function ResolvePattern(schema) {
          const keys = ResolveKeys(schema, { includePatterns: true });
          const pattern = keys.map((key) => `(${UnwrapPattern(key)})`);
          return `^(${pattern.join("|")})$`;
        }
        KeyResolver2.ResolvePattern = ResolvePattern;
      })(KeyResolver || (exports.KeyResolver = KeyResolver = {}));
      var KeyArrayResolverError = class extends TypeBoxError {
      };
      exports.KeyArrayResolverError = KeyArrayResolverError;
      var KeyArrayResolver;
      (function(KeyArrayResolver2) {
        function Resolve(schema) {
          return Array.isArray(schema) ? schema : TypeGuard.TUnionLiteral(schema) ? schema.anyOf.map((schema2) => schema2.const.toString()) : TypeGuard.TLiteral(schema) ? [schema.const] : TypeGuard.TTemplateLiteral(schema) ? (() => {
            const expression = TemplateLiteralParser.ParseExact(schema.pattern);
            if (!TemplateLiteralFinite.Check(expression))
              throw new KeyArrayResolverError("Cannot resolve keys from infinite template expression");
            return [...TemplateLiteralGenerator.Generate(expression)];
          })() : [];
        }
        KeyArrayResolver2.Resolve = Resolve;
      })(KeyArrayResolver || (exports.KeyArrayResolver = KeyArrayResolver = {}));
      var UnionResolver;
      (function(UnionResolver2) {
        function* TUnion(union) {
          for (const schema of union.anyOf) {
            if (schema[exports.Kind] === "Union") {
              yield* TUnion(schema);
            } else {
              yield schema;
            }
          }
        }
        function Resolve(union) {
          return exports.Type.Union([...TUnion(union)], { ...union });
        }
        UnionResolver2.Resolve = Resolve;
      })(UnionResolver || (exports.UnionResolver = UnionResolver = {}));
      var TemplateLiteralPatternError = class extends TypeBoxError {
      };
      exports.TemplateLiteralPatternError = TemplateLiteralPatternError;
      var TemplateLiteralPattern;
      (function(TemplateLiteralPattern2) {
        function Throw(message) {
          throw new TemplateLiteralPatternError(message);
        }
        function Escape(value) {
          return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }
        function Visit(schema, acc) {
          return TypeGuard.TTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : TypeGuard.TUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit(schema2, acc)).join("|")})` : TypeGuard.TNumber(schema) ? `${acc}${exports.PatternNumber}` : TypeGuard.TInteger(schema) ? `${acc}${exports.PatternNumber}` : TypeGuard.TBigInt(schema) ? `${acc}${exports.PatternNumber}` : TypeGuard.TString(schema) ? `${acc}${exports.PatternString}` : TypeGuard.TLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : TypeGuard.TBoolean(schema) ? `${acc}${exports.PatternBoolean}` : Throw(`Unexpected Kind '${schema[exports.Kind]}'`);
        }
        function Create(kinds) {
          return `^${kinds.map((schema) => Visit(schema, "")).join("")}$`;
        }
        TemplateLiteralPattern2.Create = Create;
      })(TemplateLiteralPattern || (exports.TemplateLiteralPattern = TemplateLiteralPattern = {}));
      var TemplateLiteralResolver;
      (function(TemplateLiteralResolver2) {
        function Resolve(template) {
          const expression = TemplateLiteralParser.ParseExact(template.pattern);
          if (!TemplateLiteralFinite.Check(expression))
            return exports.Type.String();
          const literals = [...TemplateLiteralGenerator.Generate(expression)].map((value) => exports.Type.Literal(value));
          return exports.Type.Union(literals);
        }
        TemplateLiteralResolver2.Resolve = Resolve;
      })(TemplateLiteralResolver || (exports.TemplateLiteralResolver = TemplateLiteralResolver = {}));
      var TemplateLiteralParserError = class extends TypeBoxError {
      };
      exports.TemplateLiteralParserError = TemplateLiteralParserError;
      var TemplateLiteralParser;
      (function(TemplateLiteralParser2) {
        function IsNonEscaped(pattern, index, char) {
          return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
        }
        function IsOpenParen(pattern, index) {
          return IsNonEscaped(pattern, index, "(");
        }
        function IsCloseParen(pattern, index) {
          return IsNonEscaped(pattern, index, ")");
        }
        function IsSeparator(pattern, index) {
          return IsNonEscaped(pattern, index, "|");
        }
        function IsGroup(pattern) {
          if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
            return false;
          let count = 0;
          for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index))
              count += 1;
            if (IsCloseParen(pattern, index))
              count -= 1;
            if (count === 0 && index !== pattern.length - 1)
              return false;
          }
          return true;
        }
        function InGroup(pattern) {
          return pattern.slice(1, pattern.length - 1);
        }
        function IsPrecedenceOr(pattern) {
          let count = 0;
          for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index))
              count += 1;
            if (IsCloseParen(pattern, index))
              count -= 1;
            if (IsSeparator(pattern, index) && count === 0)
              return true;
          }
          return false;
        }
        function IsPrecedenceAnd(pattern) {
          for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index))
              return true;
          }
          return false;
        }
        function Or(pattern) {
          let [count, start] = [0, 0];
          const expressions = [];
          for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index))
              count += 1;
            if (IsCloseParen(pattern, index))
              count -= 1;
            if (IsSeparator(pattern, index) && count === 0) {
              const range2 = pattern.slice(start, index);
              if (range2.length > 0)
                expressions.push(Parse(range2));
              start = index + 1;
            }
          }
          const range = pattern.slice(start);
          if (range.length > 0)
            expressions.push(Parse(range));
          if (expressions.length === 0)
            return { type: "const", const: "" };
          if (expressions.length === 1)
            return expressions[0];
          return { type: "or", expr: expressions };
        }
        function And(pattern) {
          function Group(value, index) {
            if (!IsOpenParen(value, index))
              throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
            let count = 0;
            for (let scan = index; scan < value.length; scan++) {
              if (IsOpenParen(value, scan))
                count += 1;
              if (IsCloseParen(value, scan))
                count -= 1;
              if (count === 0)
                return [index, scan];
            }
            throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
          }
          function Range2(pattern2, index) {
            for (let scan = index; scan < pattern2.length; scan++) {
              if (IsOpenParen(pattern2, scan))
                return [index, scan];
            }
            return [index, pattern2.length];
          }
          const expressions = [];
          for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index)) {
              const [start, end] = Group(pattern, index);
              const range = pattern.slice(start, end + 1);
              expressions.push(Parse(range));
              index = end;
            } else {
              const [start, end] = Range2(pattern, index);
              const range = pattern.slice(start, end);
              if (range.length > 0)
                expressions.push(Parse(range));
              index = end - 1;
            }
          }
          return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
        }
        function Parse(pattern) {
          return IsGroup(pattern) ? Parse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: pattern };
        }
        TemplateLiteralParser2.Parse = Parse;
        function ParseExact(pattern) {
          return Parse(pattern.slice(1, pattern.length - 1));
        }
        TemplateLiteralParser2.ParseExact = ParseExact;
      })(TemplateLiteralParser || (exports.TemplateLiteralParser = TemplateLiteralParser = {}));
      var TemplateLiteralFiniteError = class extends TypeBoxError {
      };
      exports.TemplateLiteralFiniteError = TemplateLiteralFiniteError;
      var TemplateLiteralFinite;
      (function(TemplateLiteralFinite2) {
        function Throw(message) {
          throw new TemplateLiteralFiniteError(message);
        }
        function IsNumber(expression) {
          return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
        }
        function IsBoolean(expression) {
          return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
        }
        function IsString(expression) {
          return expression.type === "const" && expression.const === ".*";
        }
        function Check(expression) {
          return IsBoolean(expression) ? true : IsNumber(expression) || IsString(expression) ? false : expression.type === "and" ? expression.expr.every((expr) => Check(expr)) : expression.type === "or" ? expression.expr.every((expr) => Check(expr)) : expression.type === "const" ? true : Throw(`Unknown expression type`);
        }
        TemplateLiteralFinite2.Check = Check;
      })(TemplateLiteralFinite || (exports.TemplateLiteralFinite = TemplateLiteralFinite = {}));
      var TemplateLiteralGeneratorError = class extends TypeBoxError {
      };
      exports.TemplateLiteralGeneratorError = TemplateLiteralGeneratorError;
      var TemplateLiteralGenerator;
      (function(TemplateLiteralGenerator2) {
        function* Reduce(buffer2) {
          if (buffer2.length === 1)
            return yield* buffer2[0];
          for (const left of buffer2[0]) {
            for (const right of Reduce(buffer2.slice(1))) {
              yield `${left}${right}`;
            }
          }
        }
        function* And(expression) {
          return yield* Reduce(expression.expr.map((expr) => [...Generate(expr)]));
        }
        function* Or(expression) {
          for (const expr of expression.expr)
            yield* Generate(expr);
        }
        function* Const(expression) {
          return yield expression.const;
        }
        function* Generate(expression) {
          return expression.type === "and" ? yield* And(expression) : expression.type === "or" ? yield* Or(expression) : expression.type === "const" ? yield* Const(expression) : (() => {
            throw new TemplateLiteralGeneratorError("Unknown expression");
          })();
        }
        TemplateLiteralGenerator2.Generate = Generate;
      })(TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = TemplateLiteralGenerator = {}));
      var TemplateLiteralDslParser;
      (function(TemplateLiteralDslParser2) {
        function* ParseUnion(template) {
          const trim = template.trim().replace(/"|'/g, "");
          return trim === "boolean" ? yield exports.Type.Boolean() : trim === "number" ? yield exports.Type.Number() : trim === "bigint" ? yield exports.Type.BigInt() : trim === "string" ? yield exports.Type.String() : yield (() => {
            const literals = trim.split("|").map((literal) => exports.Type.Literal(literal.trim()));
            return literals.length === 0 ? exports.Type.Never() : literals.length === 1 ? literals[0] : exports.Type.Union(literals);
          })();
        }
        function* ParseTerminal(template) {
          if (template[1] !== "{") {
            const L = exports.Type.Literal("$");
            const R2 = ParseLiteral(template.slice(1));
            return yield* [L, ...R2];
          }
          for (let i = 2; i < template.length; i++) {
            if (template[i] === "}") {
              const L = ParseUnion(template.slice(2, i));
              const R2 = ParseLiteral(template.slice(i + 1));
              return yield* [...L, ...R2];
            }
          }
          yield exports.Type.Literal(template);
        }
        function* ParseLiteral(template) {
          for (let i = 0; i < template.length; i++) {
            if (template[i] === "$") {
              const L = exports.Type.Literal(template.slice(0, i));
              const R2 = ParseTerminal(template.slice(i));
              return yield* [L, ...R2];
            }
          }
          yield exports.Type.Literal(template);
        }
        function Parse(template_dsl) {
          return [...ParseLiteral(template_dsl)];
        }
        TemplateLiteralDslParser2.Parse = Parse;
      })(TemplateLiteralDslParser || (exports.TemplateLiteralDslParser = TemplateLiteralDslParser = {}));
      var TransformDecodeBuilder = class {
        constructor(schema) {
          this.schema = schema;
        }
        Decode(decode) {
          return new TransformEncodeBuilder(this.schema, decode);
        }
      };
      exports.TransformDecodeBuilder = TransformDecodeBuilder;
      var TransformEncodeBuilder = class {
        constructor(schema, decode) {
          this.schema = schema;
          this.decode = decode;
        }
        Encode(encode) {
          const schema = TypeClone.Type(this.schema);
          return TypeGuard.TTransform(schema) ? (() => {
            const Encode = (value) => schema[exports.Transform].Encode(encode(value));
            const Decode = (value) => this.decode(schema[exports.Transform].Decode(value));
            const Codec = { Encode, Decode };
            return { ...schema, [exports.Transform]: Codec };
          })() : (() => {
            const Codec = { Decode: this.decode, Encode: encode };
            return { ...schema, [exports.Transform]: Codec };
          })();
        }
      };
      exports.TransformEncodeBuilder = TransformEncodeBuilder;
      var TypeOrdinal = 0;
      var TypeBuilderError = class extends TypeBoxError {
      };
      exports.TypeBuilderError = TypeBuilderError;
      var TypeBuilder = class {
        /** `[Internal]` Creates a schema without `static` and `params` types */
        Create(schema) {
          return schema;
        }
        /** `[Internal]` Throws a TypeBuilder error with the given message */
        Throw(message) {
          throw new TypeBuilderError(message);
        }
        /** `[Internal]` Discards property keys from the given record type */
        Discard(record, keys) {
          return keys.reduce((acc, key) => {
            const { [key]: _, ...rest } = acc;
            return rest;
          }, record);
        }
        /** `[Json]` Omits compositing symbols from this schema */
        Strict(schema) {
          return JSON.parse(JSON.stringify(schema));
        }
      };
      exports.TypeBuilder = TypeBuilder;
      var JsonTypeBuilder = class extends TypeBuilder {
        // ------------------------------------------------------------------------
        // Modifiers
        // ------------------------------------------------------------------------
        /** `[Json]` Creates a Readonly and Optional property */
        ReadonlyOptional(schema) {
          return this.Readonly(this.Optional(schema));
        }
        /** `[Json]` Creates a Readonly property */
        Readonly(schema) {
          return { ...TypeClone.Type(schema), [exports.Readonly]: "Readonly" };
        }
        /** `[Json]` Creates an Optional property */
        Optional(schema) {
          return { ...TypeClone.Type(schema), [exports.Optional]: "Optional" };
        }
        // ------------------------------------------------------------------------
        // Types
        // ------------------------------------------------------------------------
        /** `[Json]` Creates an Any type */
        Any(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Any" });
        }
        /** `[Json]` Creates an Array type */
        Array(schema, options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Array", type: "array", items: TypeClone.Type(schema) });
        }
        /** `[Json]` Creates a Boolean type */
        Boolean(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Boolean", type: "boolean" });
        }
        /** `[Json]` Intrinsic function to Capitalize LiteralString types */
        Capitalize(schema, options = {}) {
          return { ...Intrinsic.Map(TypeClone.Type(schema), "Capitalize"), ...options };
        }
        /** `[Json]` Creates a Composite object type */
        Composite(objects, options) {
          const intersect = exports.Type.Intersect(objects, {});
          const keys = KeyResolver.ResolveKeys(intersect, { includePatterns: false });
          const properties = keys.reduce((acc, key) => ({ ...acc, [key]: exports.Type.Index(intersect, [key]) }), {});
          return exports.Type.Object(properties, options);
        }
        /** `[Json]` Creates a Enum type */
        Enum(item, options = {}) {
          const values1 = Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
          const values2 = [...new Set(values1)];
          const anyOf = values2.map((value) => exports.Type.Literal(value));
          return this.Union(anyOf, { ...options, [exports.Hint]: "Enum" });
        }
        /** `[Json]` Creates a Conditional type */
        Extends(left, right, trueType, falseType, options = {}) {
          switch (TypeExtends.Extends(left, right)) {
            case TypeExtendsResult.Union:
              return this.Union([TypeClone.Type(trueType, options), TypeClone.Type(falseType, options)]);
            case TypeExtendsResult.True:
              return TypeClone.Type(trueType, options);
            case TypeExtendsResult.False:
              return TypeClone.Type(falseType, options);
          }
        }
        /** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
        Exclude(unionType, excludedMembers, options = {}) {
          return TypeGuard.TTemplateLiteral(unionType) ? this.Exclude(TemplateLiteralResolver.Resolve(unionType), excludedMembers, options) : TypeGuard.TTemplateLiteral(excludedMembers) ? this.Exclude(unionType, TemplateLiteralResolver.Resolve(excludedMembers), options) : TypeGuard.TUnion(unionType) ? (() => {
            const narrowed = unionType.anyOf.filter((inner) => TypeExtends.Extends(inner, excludedMembers) === TypeExtendsResult.False);
            return narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options);
          })() : TypeExtends.Extends(unionType, excludedMembers) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Type(unionType, options);
        }
        /** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
        Extract(type, union, options = {}) {
          return TypeGuard.TTemplateLiteral(type) ? this.Extract(TemplateLiteralResolver.Resolve(type), union, options) : TypeGuard.TTemplateLiteral(union) ? this.Extract(type, TemplateLiteralResolver.Resolve(union), options) : TypeGuard.TUnion(type) ? (() => {
            const narrowed = type.anyOf.filter((inner) => TypeExtends.Extends(inner, union) !== TypeExtendsResult.False);
            return narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options);
          })() : TypeExtends.Extends(type, union) !== TypeExtendsResult.False ? TypeClone.Type(type, options) : this.Never(options);
        }
        /** `[Json]` Returns an Indexed property type for the given keys */
        Index(schema, unresolved, options = {}) {
          return TypeGuard.TArray(schema) && TypeGuard.TNumber(unresolved) ? (() => {
            return TypeClone.Type(schema.items, options);
          })() : TypeGuard.TTuple(schema) && TypeGuard.TNumber(unresolved) ? (() => {
            const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;
            const cloned = items.map((schema2) => TypeClone.Type(schema2));
            return this.Union(cloned, options);
          })() : (() => {
            const keys = KeyArrayResolver.Resolve(unresolved);
            const clone = TypeClone.Type(schema);
            return IndexedAccessor.Resolve(clone, keys, options);
          })();
        }
        /** `[Json]` Creates an Integer type */
        Integer(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Integer", type: "integer" });
        }
        /** `[Json]` Creates an Intersect type */
        Intersect(allOf, options = {}) {
          if (allOf.length === 0)
            return exports.Type.Never();
          if (allOf.length === 1)
            return TypeClone.Type(allOf[0], options);
          if (allOf.some((schema) => TypeGuard.TTransform(schema)))
            this.Throw("Cannot intersect transform types");
          const objects = allOf.every((schema) => TypeGuard.TObject(schema));
          const cloned = TypeClone.Rest(allOf);
          const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? { unevaluatedProperties: TypeClone.Type(options.unevaluatedProperties) } : {};
          return options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects ? this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: "Intersect", type: "object", allOf: cloned }) : this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: "Intersect", allOf: cloned });
        }
        /** `[Json]` Creates a KeyOf type */
        KeyOf(schema, options = {}) {
          return TypeGuard.TRecord(schema) ? (() => {
            const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
            return pattern === exports.PatternNumberExact ? this.Number(options) : pattern === exports.PatternStringExact ? this.String(options) : this.Throw("Unable to resolve key type from Record key pattern");
          })() : TypeGuard.TTuple(schema) ? (() => {
            const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;
            const literals = items.map((_, index) => exports.Type.Literal(index.toString()));
            return this.Union(literals, options);
          })() : TypeGuard.TArray(schema) ? (() => {
            return this.Number(options);
          })() : (() => {
            const keys = KeyResolver.ResolveKeys(schema, { includePatterns: false });
            if (keys.length === 0)
              return this.Never(options);
            const literals = keys.map((key) => this.Literal(key));
            return this.Union(literals, options);
          })();
        }
        /** `[Json]` Creates a Literal type */
        Literal(value, options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Literal", const: value, type: typeof value });
        }
        /** `[Json]` Intrinsic function to Lowercase LiteralString types */
        Lowercase(schema, options = {}) {
          return { ...Intrinsic.Map(TypeClone.Type(schema), "Lowercase"), ...options };
        }
        /** `[Json]` Creates a Never type */
        Never(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Never", not: {} });
        }
        /** `[Json]` Creates a Not type */
        Not(schema, options) {
          return this.Create({ ...options, [exports.Kind]: "Not", not: TypeClone.Type(schema) });
        }
        /** `[Json]` Creates a Null type */
        Null(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Null", type: "null" });
        }
        /** `[Json]` Creates a Number type */
        Number(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Number", type: "number" });
        }
        /** `[Json]` Creates an Object type */
        Object(properties, options = {}) {
          const propertyKeys = Object.getOwnPropertyNames(properties);
          const optionalKeys = propertyKeys.filter((key) => TypeGuard.TOptional(properties[key]));
          const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
          const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? { additionalProperties: TypeClone.Type(options.additionalProperties) } : {};
          const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: TypeClone.Type(properties[key]) }), {});
          return requiredKeys.length > 0 ? this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys }) : this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: "Object", type: "object", properties: clonedProperties });
        }
        /** `[Json]` Constructs a type whose keys are omitted from the given type */
        Omit(schema, unresolved, options = {}) {
          const keys = KeyArrayResolver.Resolve(unresolved);
          return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
            if (ValueGuard.IsArray(object.required)) {
              object.required = object.required.filter((key) => !keys.includes(key));
              if (object.required.length === 0)
                delete object.required;
            }
            for (const key of Object.getOwnPropertyNames(object.properties)) {
              if (keys.includes(key))
                delete object.properties[key];
            }
            return this.Create(object);
          }, options);
        }
        /** `[Json]` Constructs a type where all properties are optional */
        Partial(schema, options = {}) {
          return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
            const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {
              return { ...acc, [key]: this.Optional(object.properties[key]) };
            }, {});
            return this.Object(
              properties,
              this.Discard(object, ["required"])
              /* object used as options to retain other constraints */
            );
          }, options);
        }
        /** `[Json]` Constructs a type whose keys are picked from the given type */
        Pick(schema, unresolved, options = {}) {
          const keys = KeyArrayResolver.Resolve(unresolved);
          return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
            if (ValueGuard.IsArray(object.required)) {
              object.required = object.required.filter((key) => keys.includes(key));
              if (object.required.length === 0)
                delete object.required;
            }
            for (const key of Object.getOwnPropertyNames(object.properties)) {
              if (!keys.includes(key))
                delete object.properties[key];
            }
            return this.Create(object);
          }, options);
        }
        /** `[Json]` Creates a Record type */
        Record(key, schema, options = {}) {
          return TypeGuard.TTemplateLiteral(key) ? (() => {
            const expression = TemplateLiteralParser.ParseExact(key.pattern);
            return TemplateLiteralFinite.Check(expression) ? this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key2) => ({ ...acc, [key2]: TypeClone.Type(schema) }), {}), options) : this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [key.pattern]: TypeClone.Type(schema) } });
          })() : TypeGuard.TUnion(key) ? (() => {
            const union = UnionResolver.Resolve(key);
            if (TypeGuard.TUnionLiteral(union)) {
              const properties = union.anyOf.reduce((acc, literal) => ({ ...acc, [literal.const]: TypeClone.Type(schema) }), {});
              return this.Object(properties, { ...options, [exports.Hint]: "Record" });
            } else
              this.Throw("Record key of type union contains non-literal types");
          })() : TypeGuard.TLiteral(key) ? (() => {
            return ValueGuard.IsString(key.const) || ValueGuard.IsNumber(key.const) ? this.Object({ [key.const]: TypeClone.Type(schema) }, options) : this.Throw("Record key of type literal is not of type string or number");
          })() : TypeGuard.TInteger(key) || TypeGuard.TNumber(key) ? (() => {
            return this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [exports.PatternNumberExact]: TypeClone.Type(schema) } });
          })() : TypeGuard.TString(key) ? (() => {
            const pattern = ValueGuard.IsUndefined(key.pattern) ? exports.PatternStringExact : key.pattern;
            return this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [pattern]: TypeClone.Type(schema) } });
          })() : this.Never();
        }
        /** `[Json]` Creates a Recursive type */
        Recursive(callback, options = {}) {
          if (ValueGuard.IsUndefined(options.$id))
            options.$id = `T${TypeOrdinal++}`;
          const thisType = callback({ [exports.Kind]: "This", $ref: `${options.$id}` });
          thisType.$id = options.$id;
          return this.Create({ ...options, [exports.Hint]: "Recursive", ...thisType });
        }
        /** `[Json]` Creates a Ref type. */
        Ref(unresolved, options = {}) {
          if (ValueGuard.IsString(unresolved))
            return this.Create({ ...options, [exports.Kind]: "Ref", $ref: unresolved });
          if (ValueGuard.IsUndefined(unresolved.$id))
            this.Throw("Reference target type must specify an $id");
          return this.Create({ ...options, [exports.Kind]: "Ref", $ref: unresolved.$id });
        }
        /** `[Json]` Constructs a type where all properties are required */
        Required(schema, options = {}) {
          return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
            const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {
              return { ...acc, [key]: this.Discard(object.properties[key], [exports.Optional]) };
            }, {});
            return this.Object(
              properties,
              object
              /* object used as options to retain other constraints  */
            );
          }, options);
        }
        /** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */
        Rest(schema) {
          return TypeGuard.TTuple(schema) && !ValueGuard.IsUndefined(schema.items) ? TypeClone.Rest(schema.items) : TypeGuard.TIntersect(schema) ? TypeClone.Rest(schema.allOf) : TypeGuard.TUnion(schema) ? TypeClone.Rest(schema.anyOf) : [];
        }
        /** `[Json]` Creates a String type */
        String(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "String", type: "string" });
        }
        /** `[Json]` Creates a TemplateLiteral type */
        TemplateLiteral(unresolved, options = {}) {
          const pattern = ValueGuard.IsString(unresolved) ? TemplateLiteralPattern.Create(TemplateLiteralDslParser.Parse(unresolved)) : TemplateLiteralPattern.Create(unresolved);
          return this.Create({ ...options, [exports.Kind]: "TemplateLiteral", type: "string", pattern });
        }
        /** `[Json]` Creates a Transform type */
        Transform(schema) {
          return new TransformDecodeBuilder(schema);
        }
        /** `[Json]` Creates a Tuple type */
        Tuple(items, options = {}) {
          const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
          const clonedItems = TypeClone.Rest(items);
          const schema = items.length > 0 ? { ...options, [exports.Kind]: "Tuple", type: "array", items: clonedItems, additionalItems, minItems, maxItems } : { ...options, [exports.Kind]: "Tuple", type: "array", minItems, maxItems };
          return this.Create(schema);
        }
        /** `[Json]` Intrinsic function to Uncapitalize LiteralString types */
        Uncapitalize(schema, options = {}) {
          return { ...Intrinsic.Map(TypeClone.Type(schema), "Uncapitalize"), ...options };
        }
        /** `[Json]` Creates a Union type */
        Union(union, options = {}) {
          return TypeGuard.TTemplateLiteral(union) ? TemplateLiteralResolver.Resolve(union) : (() => {
            const anyOf = union;
            if (anyOf.length === 0)
              return this.Never(options);
            if (anyOf.length === 1)
              return this.Create(TypeClone.Type(anyOf[0], options));
            const clonedAnyOf = TypeClone.Rest(anyOf);
            return this.Create({ ...options, [exports.Kind]: "Union", anyOf: clonedAnyOf });
          })();
        }
        /** `[Json]` Creates an Unknown type */
        Unknown(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Unknown" });
        }
        /** `[Json]` Creates a Unsafe type that will infers as the generic argument T */
        Unsafe(options = {}) {
          return this.Create({ ...options, [exports.Kind]: options[exports.Kind] || "Unsafe" });
        }
        /** `[Json]` Intrinsic function to Uppercase LiteralString types */
        Uppercase(schema, options = {}) {
          return { ...Intrinsic.Map(TypeClone.Type(schema), "Uppercase"), ...options };
        }
      };
      exports.JsonTypeBuilder = JsonTypeBuilder;
      var JavaScriptTypeBuilder = class extends JsonTypeBuilder {
        /** `[JavaScript]` Creates a AsyncIterator type */
        AsyncIterator(items, options = {}) {
          return this.Create({ ...options, [exports.Kind]: "AsyncIterator", type: "AsyncIterator", items: TypeClone.Type(items) });
        }
        /** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */
        Awaited(schema, options = {}) {
          const Unwrap = (rest) => rest.length > 0 ? (() => {
            const [L, ...R2] = rest;
            return [this.Awaited(L), ...Unwrap(R2)];
          })() : rest;
          return TypeGuard.TIntersect(schema) ? exports.Type.Intersect(Unwrap(schema.allOf)) : TypeGuard.TUnion(schema) ? exports.Type.Union(Unwrap(schema.anyOf)) : TypeGuard.TPromise(schema) ? this.Awaited(schema.item) : TypeClone.Type(schema, options);
        }
        /** `[JavaScript]` Creates a BigInt type */
        BigInt(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "BigInt", type: "bigint" });
        }
        /** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */
        ConstructorParameters(schema, options = {}) {
          return this.Tuple([...schema.parameters], { ...options });
        }
        /** `[JavaScript]` Creates a Constructor type */
        Constructor(parameters, returns, options) {
          const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];
          return this.Create({ ...options, [exports.Kind]: "Constructor", type: "Constructor", parameters: clonedParameters, returns: clonedReturns });
        }
        /** `[JavaScript]` Creates a Date type */
        Date(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Date", type: "Date" });
        }
        /** `[JavaScript]` Creates a Function type */
        Function(parameters, returns, options) {
          const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];
          return this.Create({ ...options, [exports.Kind]: "Function", type: "Function", parameters: clonedParameters, returns: clonedReturns });
        }
        /** `[JavaScript]` Extracts the InstanceType from the given Constructor type */
        InstanceType(schema, options = {}) {
          return TypeClone.Type(schema.returns, options);
        }
        /** `[JavaScript]` Creates an Iterator type */
        Iterator(items, options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Iterator", type: "Iterator", items: TypeClone.Type(items) });
        }
        /** `[JavaScript]` Extracts the Parameters from the given Function type */
        Parameters(schema, options = {}) {
          return this.Tuple(schema.parameters, { ...options });
        }
        /** `[JavaScript]` Creates a Promise type */
        Promise(item, options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Promise", type: "Promise", item: TypeClone.Type(item) });
        }
        /** `[Extended]` Creates a String type */
        RegExp(unresolved, options = {}) {
          const pattern = ValueGuard.IsString(unresolved) ? unresolved : unresolved.source;
          return this.Create({ ...options, [exports.Kind]: "String", type: "string", pattern });
        }
        /**
         * @deprecated Use `Type.RegExp`
         */
        RegEx(regex, options = {}) {
          return this.RegExp(regex, options);
        }
        /** `[JavaScript]` Extracts the ReturnType from the given Function type */
        ReturnType(schema, options = {}) {
          return TypeClone.Type(schema.returns, options);
        }
        /** `[JavaScript]` Creates a Symbol type */
        Symbol(options) {
          return this.Create({ ...options, [exports.Kind]: "Symbol", type: "symbol" });
        }
        /** `[JavaScript]` Creates a Undefined type */
        Undefined(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Undefined", type: "undefined" });
        }
        /** `[JavaScript]` Creates a Uint8Array type */
        Uint8Array(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Uint8Array", type: "Uint8Array" });
        }
        /** `[JavaScript]` Creates a Void type */
        Void(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Void", type: "void" });
        }
      };
      exports.JavaScriptTypeBuilder = JavaScriptTypeBuilder;
      exports.JsonType = new JsonTypeBuilder();
      exports.Type = new JavaScriptTypeBuilder();
    }
  });

  // src/headless.ts
  var headless_exports = {};

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/utils/utils.js
  function getBoundingClientRect(element2) {
    if (!element2) {
      return;
    }
    let rect;
    if (typeof element2.getBoundingClientRect !== "undefined") {
      rect = element2.getBoundingClientRect();
    } else {
      let range = document.createRange();
      range.selectNode(element2);
      rect = range.getBoundingClientRect();
    }
    return rect;
  }
  function getClientRects(element2) {
    if (!element2) {
      return;
    }
    let rect;
    if (typeof element2.getClientRects !== "undefined") {
      rect = element2.getClientRects();
    } else {
      let range = document.createRange();
      range.selectNode(element2);
      rect = range.getClientRects();
    }
    return rect;
  }
  function UUID() {
    var d = (/* @__PURE__ */ new Date()).getTime();
    if (typeof performance !== "undefined" && typeof performance.now === "function") {
      d += performance.now();
    }
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      var r = (d + Math.random() * 16) % 16 | 0;
      d = Math.floor(d / 16);
      return (c === "x" ? r : r & 3 | 8).toString(16);
    });
  }
  function attr(element2, attributes) {
    for (var i = 0; i < attributes.length; i++) {
      if (element2.hasAttribute(attributes[i])) {
        return element2.getAttribute(attributes[i]);
      }
    }
  }
  function querySelectorEscape(value) {
    if (arguments.length == 0) {
      throw new TypeError("`CSS.escape` requires an argument.");
    }
    var string = String(value);
    var length = string.length;
    var index = -1;
    var codeUnit;
    var result = "";
    var firstCodeUnit = string.charCodeAt(0);
    while (++index < length) {
      codeUnit = string.charCodeAt(index);
      if (codeUnit == 0) {
        result += "\uFFFD";
        continue;
      }
      if (
        // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
        // U+007F, []
        codeUnit >= 1 && codeUnit <= 31 || codeUnit == 127 || // If the character is the first character and is in the range [0-9]
        // (U+0030 to U+0039), []
        index == 0 && codeUnit >= 48 && codeUnit <= 57 || // If the character is the second character and is in the range [0-9]
        // (U+0030 to U+0039) and the first character is a `-` (U+002D), []
        index == 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit == 45
      ) {
        result += "\\" + codeUnit.toString(16) + " ";
        continue;
      }
      if (
        // If the character is the first character and is a `-` (U+002D), and
        // there is no second character, []
        index == 0 && length == 1 && codeUnit == 45
      ) {
        result += "\\" + string.charAt(index);
        continue;
      }
      if (codeUnit == 46) {
        if (string.charAt(0) == "#") {
          result += "\\.";
          continue;
        }
      }
      if (codeUnit >= 128 || codeUnit == 45 || codeUnit == 95 || codeUnit == 35 || // Allow #
      codeUnit == 46 || // Allow .
      codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {
        result += string.charAt(index);
        continue;
      }
      result += "\\" + string.charAt(index);
    }
    return result;
  }
  function defer() {
    this.resolve = null;
    this.reject = null;
    this.id = UUID();
    this.promise = new Promise((resolve2, reject) => {
      this.resolve = resolve2;
      this.reject = reject;
    });
    Object.freeze(this);
  }
  var requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);
  function CSSValueToString(obj) {
    return obj.value + (obj.unit || "");
  }

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/utils/dom.js
  function isElement(node) {
    return node && node.nodeType === 1;
  }
  function isText(node) {
    return node && node.nodeType === 3;
  }
  function* walk(start, limiter) {
    let node = start;
    while (node) {
      yield node;
      if (node.childNodes.length) {
        node = node.firstChild;
      } else if (node.nextSibling) {
        if (limiter && node === limiter) {
          node = void 0;
          break;
        }
        node = node.nextSibling;
      } else {
        while (node) {
          node = node.parentNode;
          if (limiter && node === limiter) {
            node = void 0;
            break;
          }
          if (node && node.nextSibling) {
            node = node.nextSibling;
            break;
          }
        }
      }
    }
  }
  function nodeAfter(node, limiter) {
    if (limiter && node === limiter) {
      return;
    }
    let significantNode = nextSignificantNode(node);
    if (significantNode) {
      return significantNode;
    }
    if (node.parentNode) {
      while (node = node.parentNode) {
        if (limiter && node === limiter) {
          return;
        }
        significantNode = nextSignificantNode(node);
        if (significantNode) {
          return significantNode;
        }
      }
    }
  }
  function nodeBefore(node, limiter) {
    if (limiter && node === limiter) {
      return;
    }
    let significantNode = previousSignificantNode(node);
    if (significantNode) {
      return significantNode;
    }
    if (node.parentNode) {
      while (node = node.parentNode) {
        if (limiter && node === limiter) {
          return;
        }
        significantNode = previousSignificantNode(node);
        if (significantNode) {
          return significantNode;
        }
      }
    }
  }
  function elementAfter(node, limiter) {
    let after = nodeAfter(node, limiter);
    while (after && after.nodeType !== 1) {
      after = nodeAfter(after, limiter);
    }
    return after;
  }
  function elementBefore(node, limiter) {
    let before = nodeBefore(node, limiter);
    while (before && before.nodeType !== 1) {
      before = nodeBefore(before, limiter);
    }
    return before;
  }
  function displayedElementAfter(node, limiter) {
    let after = elementAfter(node, limiter);
    while (after && after.dataset.undisplayed) {
      after = elementAfter(after, limiter);
    }
    return after;
  }
  function displayedElementBefore(node, limiter) {
    let before = elementBefore(node, limiter);
    while (before && before.dataset.undisplayed) {
      before = elementBefore(before, limiter);
    }
    return before;
  }
  function rebuildAncestors(node) {
    let parent, ancestor;
    let ancestors = [];
    let added = [];
    let fragment = document.createDocumentFragment();
    if (node.nodeName === "TR") {
      let previousRow = node.previousElementSibling;
      let previousRowDistance = 1;
      while (previousRow) {
        if (previousRow.childElementCount > node.childElementCount) {
          const initialColumns = Array.from(node.children);
          while (node.firstChild) {
            node.firstChild.remove();
          }
          let k = 0;
          for (let j = 0; j < previousRow.children.length; j++) {
            let column = previousRow.children[j];
            if (column.rowSpan && column.rowSpan > previousRowDistance) {
              const duplicatedColumn = column.cloneNode(true);
              duplicatedColumn.rowSpan = column.rowSpan - previousRowDistance;
              node.appendChild(duplicatedColumn);
            } else {
              const initialColumn = initialColumns[k++];
              if (initialColumn) {
                node.appendChild(initialColumn);
              }
            }
          }
        }
        previousRow = previousRow.previousElementSibling;
        previousRowDistance++;
      }
    }
    let element2 = node;
    while (element2.parentNode && element2.parentNode.nodeType === 1) {
      ancestors.unshift(element2.parentNode);
      element2 = element2.parentNode;
    }
    for (var i = 0; i < ancestors.length; i++) {
      ancestor = ancestors[i];
      parent = ancestor.cloneNode(false);
      parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
      if (parent.hasAttribute("id")) {
        let dataID = parent.getAttribute("id");
        parent.setAttribute("data-id", dataID);
        parent.removeAttribute("id");
      }
      if (parent.hasAttribute("data-break-before")) {
        parent.removeAttribute("data-break-before");
      }
      if (parent.hasAttribute("data-previous-break-after")) {
        parent.removeAttribute("data-previous-break-after");
      }
      if (added.length) {
        let container = added[added.length - 1];
        container.appendChild(parent);
      } else {
        fragment.appendChild(parent);
      }
      added.push(parent);
      if (parent.nodeName === "TD" && ancestor.parentElement.contains(ancestor)) {
        let td = ancestor;
        let prev = parent;
        while (td = td.previousElementSibling) {
          let sib = td.cloneNode(false);
          parent.parentElement.insertBefore(sib, prev);
          prev = sib;
        }
      }
    }
    added = void 0;
    return fragment;
  }
  function needsBreakBefore(node) {
    if (typeof node !== "undefined" && typeof node.dataset !== "undefined" && typeof node.dataset.breakBefore !== "undefined" && (node.dataset.breakBefore === "always" || node.dataset.breakBefore === "page" || node.dataset.breakBefore === "left" || node.dataset.breakBefore === "right" || node.dataset.breakBefore === "recto" || node.dataset.breakBefore === "verso")) {
      return true;
    }
    return false;
  }
  function needsPreviousBreakAfter(node) {
    if (typeof node !== "undefined" && typeof node.dataset !== "undefined" && typeof node.dataset.previousBreakAfter !== "undefined" && (node.dataset.previousBreakAfter === "always" || node.dataset.previousBreakAfter === "page" || node.dataset.previousBreakAfter === "left" || node.dataset.previousBreakAfter === "right" || node.dataset.previousBreakAfter === "recto" || node.dataset.previousBreakAfter === "verso")) {
      return true;
    }
    return false;
  }
  function needsPageBreak(node, previousSignificantNode2) {
    if (typeof node === "undefined" || !previousSignificantNode2 || isIgnorable(node)) {
      return false;
    }
    if (node.dataset && node.dataset.undisplayed) {
      return false;
    }
    let previousSignificantNodePage = previousSignificantNode2.dataset ? previousSignificantNode2.dataset.page : void 0;
    if (typeof previousSignificantNodePage === "undefined") {
      const nodeWithNamedPage = getNodeWithNamedPage(previousSignificantNode2);
      if (nodeWithNamedPage) {
        previousSignificantNodePage = nodeWithNamedPage.dataset.page;
      }
    }
    let currentNodePage = node.dataset ? node.dataset.page : void 0;
    if (typeof currentNodePage === "undefined") {
      const nodeWithNamedPage = getNodeWithNamedPage(node, previousSignificantNode2);
      if (nodeWithNamedPage) {
        currentNodePage = nodeWithNamedPage.dataset.page;
      }
    }
    return currentNodePage !== previousSignificantNodePage;
  }
  function* words(node) {
    let currentText = node.nodeValue;
    let max = currentText.length;
    let currentOffset = 0;
    let currentLetter;
    let range;
    const significantWhitespaces = node.parentElement && node.parentElement.nodeName === "PRE";
    while (currentOffset < max) {
      currentLetter = currentText[currentOffset];
      if (/^[\S\u202F\u00A0]$/.test(currentLetter) || significantWhitespaces) {
        if (!range) {
          range = document.createRange();
          range.setStart(node, currentOffset);
        }
      } else {
        if (range) {
          range.setEnd(node, currentOffset);
          yield range;
          range = void 0;
        }
      }
      currentOffset += 1;
    }
    if (range) {
      range.setEnd(node, currentOffset);
      yield range;
    }
  }
  function* letters(wordRange) {
    let currentText = wordRange.startContainer;
    let max = currentText.length;
    let currentOffset = wordRange.startOffset;
    let range;
    while (currentOffset < max) {
      range = document.createRange();
      range.setStart(currentText, currentOffset);
      range.setEnd(currentText, currentOffset + 1);
      yield range;
      currentOffset += 1;
    }
  }
  function isContainer(node) {
    let container;
    if (typeof node.tagName === "undefined") {
      return true;
    }
    if (node.style && node.style.display === "none") {
      return false;
    }
    switch (node.tagName) {
      case "A":
      case "ABBR":
      case "ACRONYM":
      case "B":
      case "BDO":
      case "BIG":
      case "BR":
      case "BUTTON":
      case "CITE":
      case "CODE":
      case "DFN":
      case "EM":
      case "I":
      case "IMG":
      case "INPUT":
      case "KBD":
      case "LABEL":
      case "MAP":
      case "OBJECT":
      case "Q":
      case "SAMP":
      case "SCRIPT":
      case "SELECT":
      case "SMALL":
      case "SPAN":
      case "STRONG":
      case "SUB":
      case "SUP":
      case "TEXTAREA":
      case "TIME":
      case "TT":
      case "VAR":
      case "P":
      case "H1":
      case "H2":
      case "H3":
      case "H4":
      case "H5":
      case "H6":
      case "FIGCAPTION":
      case "BLOCKQUOTE":
      case "PRE":
      case "LI":
      case "TD":
      case "DT":
      case "DD":
      case "VIDEO":
      case "CANVAS":
        container = false;
        break;
      default:
        container = true;
    }
    return container;
  }
  function cloneNode(n, deep = false) {
    return n.cloneNode(deep);
  }
  function findElement(node, doc, forceQuery) {
    const ref = node.getAttribute("data-ref");
    return findRef(ref, doc, forceQuery);
  }
  function findRef(ref, doc, forceQuery) {
    if (!forceQuery && doc.indexOfRefs && doc.indexOfRefs[ref]) {
      return doc.indexOfRefs[ref];
    } else {
      return doc.querySelector(`[data-ref='${ref}']`);
    }
  }
  function validNode(node) {
    if (isText(node)) {
      return true;
    }
    if (isElement(node) && node.dataset.ref) {
      return true;
    }
    return false;
  }
  function prevValidNode(node) {
    while (!validNode(node)) {
      if (node.previousSibling) {
        node = node.previousSibling;
      } else {
        node = node.parentNode;
      }
      if (!node) {
        break;
      }
    }
    return node;
  }
  function indexOf(node) {
    let parent = node.parentNode;
    if (!parent) {
      return 0;
    }
    return Array.prototype.indexOf.call(parent.childNodes, node);
  }
  function child(node, index) {
    return node.childNodes[index];
  }
  function hasContent(node) {
    if (isElement(node)) {
      return true;
    } else if (isText(node) && node.textContent.trim().length) {
      return true;
    }
    return false;
  }
  function indexOfTextNode(node, parent) {
    if (!isText(node)) {
      return -1;
    }
    let nodeTextContent = node.textContent;
    let child2;
    let index = -1;
    for (var i = 0; i < parent.childNodes.length; i++) {
      child2 = parent.childNodes[i];
      if (child2.nodeType === 3) {
        let text = parent.childNodes[i].textContent;
        if (text.includes(nodeTextContent)) {
          index = i;
          break;
        }
      }
    }
    return index;
  }
  function isIgnorable(node) {
    return node.nodeType === 8 || // A comment node
    node.nodeType === 3 && isAllWhitespace(node);
  }
  function isAllWhitespace(node) {
    return !/[^\t\n\r ]/.test(node.textContent);
  }
  function previousSignificantNode(sib) {
    while (sib = sib.previousSibling) {
      if (!isIgnorable(sib))
        return sib;
    }
    return null;
  }
  function getNodeWithNamedPage(node, limiter) {
    if (node && node.dataset && node.dataset.page) {
      return node;
    }
    if (node.parentNode) {
      while (node = node.parentNode) {
        if (limiter && node === limiter) {
          return;
        }
        if (node.dataset && node.dataset.page) {
          return node;
        }
      }
    }
    return null;
  }
  function breakInsideAvoidParentNode(node) {
    while (node = node.parentNode) {
      if (node && node.dataset && node.dataset.breakInside === "avoid") {
        return node;
      }
    }
    return null;
  }
  function parentOf(node, nodeName, limiter) {
    if (limiter && node === limiter) {
      return;
    }
    if (node.parentNode) {
      while (node = node.parentNode) {
        if (limiter && node === limiter) {
          return;
        }
        if (node.nodeName === nodeName) {
          return node;
        }
      }
    }
  }
  function nextSignificantNode(sib) {
    while (sib = sib.nextSibling) {
      if (!isIgnorable(sib))
        return sib;
    }
    return null;
  }
  function filterTree(content, func, what) {
    const treeWalker = document.createTreeWalker(
      content || this.dom,
      what || NodeFilter.SHOW_ALL,
      func ? { acceptNode: func } : null,
      false
    );
    let node;
    let current;
    node = treeWalker.nextNode();
    while (node) {
      current = node;
      node = treeWalker.nextNode();
      current.parentNode.removeChild(current);
    }
  }

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/chunker/breaktoken.js
  var BreakToken = class {
    constructor(node, offset) {
      this.node = node;
      this.offset = offset;
    }
    equals(otherBreakToken) {
      if (!otherBreakToken) {
        return false;
      }
      if (this["node"] && otherBreakToken["node"] && this["node"] !== otherBreakToken["node"]) {
        return false;
      }
      if (this["offset"] && otherBreakToken["offset"] && this["offset"] !== otherBreakToken["offset"]) {
        return false;
      }
      return true;
    }
    toJSON(hash) {
      let node;
      let index = 0;
      if (!this.node) {
        return {};
      }
      if (isElement(this.node) && this.node.dataset.ref) {
        node = this.node.dataset.ref;
      } else if (hash) {
        node = this.node.parentElement.dataset.ref;
      }
      if (this.node.parentElement) {
        const children = Array.from(this.node.parentElement.childNodes);
        index = children.indexOf(this.node);
      }
      return JSON.stringify({
        "node": node,
        "index": index,
        "offset": this.offset
      });
    }
  };
  var breaktoken_default = BreakToken;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/chunker/renderresult.js
  var RenderResult = class {
    constructor(breakToken, error) {
      this.breakToken = breakToken;
      this.error = error;
    }
  };
  var OverflowContentError = class extends Error {
    constructor(message, items) {
      super(message);
      this.items = items;
    }
  };
  var renderresult_default = RenderResult;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/chunker/layout.js
  var import_event_emitter = __toESM(require_event_emitter(), 1);

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/utils/hook.js
  var Hook = class {
    constructor(context) {
      this.context = context || this;
      this.hooks = [];
    }
    /**
     * Adds a function to be run before a hook completes
     * @example this.content.register(function(){...});
     * @return {undefined} void
     */
    register() {
      for (var i = 0; i < arguments.length; ++i) {
        if (typeof arguments[i] === "function") {
          this.hooks.push(arguments[i]);
        } else {
          for (var j = 0; j < arguments[i].length; ++j) {
            this.hooks.push(arguments[i][j]);
          }
        }
      }
    }
    /**
     * Triggers a hook to run all functions
     * @example this.content.trigger(args).then(function(){...});
     * @return {Promise} results
     */
    trigger() {
      var args = arguments;
      var context = this.context;
      var promises = [];
      this.hooks.forEach(function(task) {
        var executing = task.apply(context, args);
        if (executing && typeof executing["then"] === "function") {
          promises.push(executing);
        } else {
          promises.push(new Promise((resolve2, reject) => {
            resolve2(executing);
          }));
        }
      });
      return Promise.all(promises);
    }
    /**
      * Triggers a hook to run all functions synchronously
      * @example this.content.trigger(args).then(function(){...});
      * @return {Array} results
      */
    triggerSync() {
      var args = arguments;
      var context = this.context;
      var results = [];
      this.hooks.forEach(function(task) {
        var executing = task.apply(context, args);
        results.push(executing);
      });
      return results;
    }
    // Adds a function to be run before a hook completes
    list() {
      return this.hooks;
    }
    clear() {
      return this.hooks = [];
    }
  };
  var hook_default = Hook;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/chunker/layout.js
  var MAX_CHARS_PER_BREAK = 1500;
  var Layout = class {
    constructor(element2, hooks, options) {
      this.element = element2;
      this.bounds = this.element.getBoundingClientRect();
      this.parentBounds = this.element.offsetParent.getBoundingClientRect();
      let gap = parseFloat(window.getComputedStyle(this.element).columnGap);
      if (gap) {
        let leftMargin = this.bounds.left - this.parentBounds.left;
        this.gap = gap - leftMargin;
      } else {
        this.gap = 0;
      }
      if (hooks) {
        this.hooks = hooks;
      } else {
        this.hooks = {};
        this.hooks.onPageLayout = new hook_default();
        this.hooks.layout = new hook_default();
        this.hooks.renderNode = new hook_default();
        this.hooks.layoutNode = new hook_default();
        this.hooks.beforeOverflow = new hook_default();
        this.hooks.onOverflow = new hook_default();
        this.hooks.afterOverflowRemoved = new hook_default();
        this.hooks.onBreakToken = new hook_default();
        this.hooks.beforeRenderResult = new hook_default();
      }
      this.settings = options || {};
      this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
      this.forceRenderBreak = false;
    }
    async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
      let start = this.getStart(source, breakToken);
      let walker = walk(start, source);
      let node;
      let prevNode;
      let done;
      let next;
      let hasRenderedContent = false;
      let newBreakToken;
      let length = 0;
      let prevBreakToken = breakToken || new breaktoken_default(start);
      this.hooks && this.hooks.onPageLayout.trigger(wrapper, prevBreakToken, this);
      while (!done && !newBreakToken) {
        next = walker.next();
        prevNode = node;
        node = next.value;
        done = next.done;
        if (!node) {
          this.hooks && this.hooks.layout.trigger(wrapper, this);
          let imgs = wrapper.querySelectorAll("img");
          if (imgs.length) {
            await this.waitForImages(imgs);
          }
          newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);
          if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
            console.warn("Unable to layout item: ", prevNode);
            this.hooks && this.hooks.beforeRenderResult.trigger(void 0, wrapper, this);
            return new renderresult_default(void 0, new OverflowContentError("Unable to layout item", [prevNode]));
          }
          this.rebuildTableFromBreakToken(newBreakToken, wrapper);
          this.hooks && this.hooks.beforeRenderResult.trigger(newBreakToken, wrapper, this);
          return new renderresult_default(newBreakToken);
        }
        this.hooks && this.hooks.layoutNode.trigger(node);
        if (hasRenderedContent && this.shouldBreak(node, start)) {
          this.hooks && this.hooks.layout.trigger(wrapper, this);
          let imgs = wrapper.querySelectorAll("img");
          if (imgs.length) {
            await this.waitForImages(imgs);
          }
          newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);
          if (!newBreakToken) {
            newBreakToken = this.breakAt(node);
          } else {
            this.rebuildTableFromBreakToken(newBreakToken, wrapper);
          }
          if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
            console.warn("Unable to layout item: ", node);
            let after = newBreakToken.node && nodeAfter(newBreakToken.node);
            if (after) {
              newBreakToken = new breaktoken_default(after);
            } else {
              return new renderresult_default(void 0, new OverflowContentError("Unable to layout item", [node]));
            }
          }
          length = 0;
          break;
        }
        if (node.dataset && node.dataset.page) {
          let named = node.dataset.page;
          let page = this.element.closest(".pagedjs_page");
          page.classList.add("pagedjs_named_page");
          page.classList.add("pagedjs_" + named + "_page");
          if (!node.dataset.splitFrom) {
            page.classList.add("pagedjs_" + named + "_first_page");
          }
        }
        let shallow = isContainer(node);
        let rendered = this.append(node, wrapper, breakToken, shallow);
        length += rendered.textContent.length;
        if (!hasRenderedContent) {
          hasRenderedContent = hasContent(node);
        }
        if (!shallow) {
          walker = walk(nodeAfter(node, source), source);
        }
        if (this.forceRenderBreak) {
          this.hooks && this.hooks.layout.trigger(wrapper, this);
          newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);
          if (!newBreakToken) {
            newBreakToken = this.breakAt(node);
          } else {
            this.rebuildTableFromBreakToken(newBreakToken, wrapper);
          }
          length = 0;
          this.forceRenderBreak = false;
          break;
        }
        if (length >= this.maxChars) {
          this.hooks && this.hooks.layout.trigger(wrapper, this);
          let imgs = wrapper.querySelectorAll("img");
          if (imgs.length) {
            await this.waitForImages(imgs);
          }
          newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);
          if (newBreakToken) {
            length = 0;
            this.rebuildTableFromBreakToken(newBreakToken, wrapper);
          }
          if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
            console.warn("Unable to layout item: ", node);
            let after = newBreakToken.node && nodeAfter(newBreakToken.node);
            if (after) {
              newBreakToken = new breaktoken_default(after);
            } else {
              this.hooks && this.hooks.beforeRenderResult.trigger(void 0, wrapper, this);
              return new renderresult_default(void 0, new OverflowContentError("Unable to layout item", [node]));
            }
          }
        }
      }
      this.hooks && this.hooks.beforeRenderResult.trigger(newBreakToken, wrapper, this);
      return new renderresult_default(newBreakToken);
    }
    breakAt(node, offset = 0) {
      let newBreakToken = new breaktoken_default(
        node,
        offset
      );
      let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, void 0, node, this);
      breakHooks.forEach((newToken) => {
        if (typeof newToken != "undefined") {
          newBreakToken = newToken;
        }
      });
      return newBreakToken;
    }
    shouldBreak(node, limiter) {
      let previousNode = nodeBefore(node, limiter);
      let parentNode = node.parentNode;
      let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousNode && needsBreakBefore(parentNode);
      let doubleBreakBefore;
      if (parentBreakBefore) {
        doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
      }
      return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousNode);
    }
    forceBreak() {
      this.forceRenderBreak = true;
    }
    getStart(source, breakToken) {
      let start;
      let node = breakToken && breakToken.node;
      if (node) {
        start = node;
      } else {
        start = source.firstChild;
      }
      return start;
    }
    append(node, dest, breakToken, shallow = true, rebuild = true) {
      let clone = cloneNode(node, !shallow);
      if (node.parentNode && isElement(node.parentNode)) {
        let parent = findElement(node.parentNode, dest);
        if (parent) {
          parent.appendChild(clone);
        } else if (rebuild) {
          let fragment = rebuildAncestors(node);
          parent = findElement(node.parentNode, fragment);
          if (!parent) {
            dest.appendChild(clone);
          } else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
            clone.textContent = clone.textContent.substring(breakToken.offset);
            parent.appendChild(clone);
          } else {
            parent.appendChild(clone);
          }
          dest.appendChild(fragment);
        } else {
          dest.appendChild(clone);
        }
      } else {
        dest.appendChild(clone);
      }
      if (clone.dataset && clone.dataset.ref) {
        if (!dest.indexOfRefs) {
          dest.indexOfRefs = {};
        }
        dest.indexOfRefs[clone.dataset.ref] = clone;
      }
      let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
      nodeHooks.forEach((newNode) => {
        if (typeof newNode != "undefined") {
          clone = newNode;
        }
      });
      return clone;
    }
    rebuildTableFromBreakToken(breakToken, dest) {
      if (!breakToken || !breakToken.node) {
        return;
      }
      let node = breakToken.node;
      let td = isElement(node) ? node.closest("td") : node.parentElement.closest("td");
      if (td) {
        let rendered = findElement(td, dest, true);
        if (!rendered) {
          return;
        }
        while (td = td.nextElementSibling) {
          this.append(td, dest, null, true);
        }
      }
    }
    async waitForImages(imgs) {
      let results = Array.from(imgs).map(async (img) => {
        return this.awaitImageLoaded(img);
      });
      await Promise.all(results);
    }
    async awaitImageLoaded(image) {
      return new Promise((resolve2) => {
        if (image.complete !== true) {
          image.onload = function() {
            let { width, height } = window.getComputedStyle(image);
            resolve2(width, height);
          };
          image.onerror = function(e) {
            let { width, height } = window.getComputedStyle(image);
            resolve2(width, height, e);
          };
        } else {
          let { width, height } = window.getComputedStyle(image);
          resolve2(width, height);
        }
      });
    }
    avoidBreakInside(node, limiter) {
      let breakNode;
      if (node === limiter) {
        return;
      }
      while (node.parentNode) {
        node = node.parentNode;
        if (node === limiter) {
          break;
        }
        if (window.getComputedStyle(node)["break-inside"] === "avoid") {
          breakNode = node;
          break;
        }
      }
      return breakNode;
    }
    createBreakToken(overflow, rendered, source) {
      let container = overflow.startContainer;
      let offset = overflow.startOffset;
      let node, renderedNode, parent, index, temp;
      if (isElement(container)) {
        temp = child(container, offset);
        if (isElement(temp)) {
          renderedNode = findElement(temp, rendered);
          if (!renderedNode) {
            let prevNode = prevValidNode(temp);
            if (!isElement(prevNode)) {
              prevNode = prevNode.parentElement;
            }
            renderedNode = findElement(prevNode, rendered);
            if (!temp.nextSibling) {
              const renderedNodeFromSource = findElement(renderedNode, source);
              const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
              const lastChildOfRenderedNodeFromSource = walker.lastChild();
              const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
              if (!lastChildOfRenderedNodeMatchingFromRendered) {
                return;
              }
            }
            node = findElement(renderedNode, source).nextSibling;
            offset = 0;
          } else {
            node = findElement(renderedNode, source);
            offset = 0;
          }
        } else {
          renderedNode = findElement(container, rendered);
          if (!renderedNode) {
            renderedNode = findElement(prevValidNode(container), rendered);
          }
          parent = findElement(renderedNode, source);
          index = indexOfTextNode(temp, parent);
          if (index === 0) {
            node = parent;
            offset = 0;
          } else {
            node = child(parent, index);
            offset = 0;
          }
        }
      } else {
        renderedNode = findElement(container.parentNode, rendered);
        if (!renderedNode) {
          renderedNode = findElement(prevValidNode(container.parentNode), rendered);
        }
        parent = findElement(renderedNode, source);
        index = indexOfTextNode(container, parent);
        if (index === -1) {
          return;
        }
        node = child(parent, index);
        offset += node.textContent.indexOf(container.textContent);
      }
      if (!node) {
        return;
      }
      return new breaktoken_default(
        node,
        offset
      );
    }
    findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
      let overflow = this.findOverflow(rendered, bounds);
      let breakToken, breakLetter;
      let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
      overflowHooks.forEach((newOverflow) => {
        if (typeof newOverflow != "undefined") {
          overflow = newOverflow;
        }
      });
      if (overflow) {
        breakToken = this.createBreakToken(overflow, rendered, source);
        let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
        breakHooks.forEach((newToken) => {
          if (typeof newToken != "undefined") {
            breakToken = newToken;
          }
        });
        if (breakToken && breakToken.equals(prevBreakToken)) {
          return breakToken;
        }
        if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
          breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
        } else {
          breakLetter = void 0;
        }
        if (breakToken && breakToken.node && extract) {
          let removed = this.removeOverflow(overflow, breakLetter);
          this.hooks && this.hooks.afterOverflowRemoved.trigger(removed, rendered, this);
        }
      }
      return breakToken;
    }
    hasOverflow(element2, bounds = this.bounds) {
      let constrainingElement = element2 && element2.parentNode;
      let { width, height } = element2.getBoundingClientRect();
      let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
      let scrollHeight = constrainingElement ? constrainingElement.scrollHeight : 0;
      return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width) || Math.max(Math.floor(height), scrollHeight) > Math.round(bounds.height);
    }
    findOverflow(rendered, bounds = this.bounds, gap = this.gap) {
      if (!this.hasOverflow(rendered, bounds))
        return;
      let start = Math.floor(bounds.left);
      let end = Math.round(bounds.right + gap);
      let vStart = Math.round(bounds.top);
      let vEnd = Math.round(bounds.bottom);
      let range;
      let walker = walk(rendered.firstChild, rendered);
      let next, done, node, offset, skip, breakAvoid, prev, br;
      while (!done) {
        next = walker.next();
        done = next.done;
        node = next.value;
        skip = false;
        breakAvoid = false;
        prev = void 0;
        br = void 0;
        if (node) {
          let pos = getBoundingClientRect(node);
          let left = Math.round(pos.left);
          let right = Math.floor(pos.right);
          let top = Math.round(pos.top);
          let bottom = Math.floor(pos.bottom);
          if (!range && (left >= end || top >= vEnd)) {
            let isFloat = false;
            const insideTableCell = parentOf(node, "TD", rendered);
            if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
              prev = insideTableCell.parentElement;
            } else if (isElement(node)) {
              let styles = window.getComputedStyle(node);
              isFloat = styles.getPropertyValue("float") !== "none";
              skip = styles.getPropertyValue("break-inside") === "avoid";
              breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
              prev = breakAvoid && nodeBefore(node, rendered);
              br = node.tagName === "BR" || node.tagName === "WBR";
            }
            let tableRow;
            if (node.nodeName === "TR") {
              tableRow = node;
            } else {
              tableRow = parentOf(node, "TR", rendered);
            }
            if (tableRow) {
              let container = tableRow.parentElement;
              if (["TBODY", "THEAD"].includes(container.nodeName)) {
                let styles = window.getComputedStyle(container);
                if (styles.getPropertyValue("break-inside") === "avoid")
                  prev = container;
              }
              const table = parentOf(tableRow, "TABLE", rendered);
              const rowspan = table.querySelector("[colspan]");
              if (table && rowspan) {
                let columnCount = 0;
                for (const cell of Array.from(table.rows[0].cells)) {
                  columnCount += parseInt(cell.getAttribute("colspan") || "1");
                }
                if (tableRow.cells.length !== columnCount) {
                  let previousRow = tableRow.previousElementSibling;
                  let previousRowColumnCount;
                  while (previousRow !== null) {
                    previousRowColumnCount = 0;
                    for (const cell of Array.from(previousRow.cells)) {
                      previousRowColumnCount += parseInt(cell.getAttribute("colspan") || "1");
                    }
                    if (previousRowColumnCount === columnCount) {
                      break;
                    }
                    previousRow = previousRow.previousElementSibling;
                  }
                  if (previousRowColumnCount === columnCount) {
                    prev = previousRow;
                  }
                }
              }
            }
            if (prev) {
              range = document.createRange();
              range.selectNode(prev);
              break;
            }
            if (!br && !isFloat && isElement(node)) {
              range = document.createRange();
              range.selectNode(node);
              break;
            }
            if (isText(node) && node.textContent.trim().length) {
              range = document.createRange();
              range.selectNode(node);
              break;
            }
          }
          if (!range && isText(node) && node.textContent.trim().length && !breakInsideAvoidParentNode(node.parentNode)) {
            let rects = getClientRects(node);
            let rect;
            left = 0;
            top = 0;
            for (var i = 0; i != rects.length; i++) {
              rect = rects[i];
              if (rect.width > 0 && (!left || rect.left > left)) {
                left = rect.left;
              }
              if (rect.height > 0 && (!top || rect.top > top)) {
                top = rect.top;
              }
            }
            if (left >= end || top >= vEnd) {
              range = document.createRange();
              offset = this.textBreak(node, start, end, vStart, vEnd);
              if (!offset) {
                range = void 0;
              } else {
                range.setStart(node, offset);
              }
              break;
            }
          }
          if (skip || right <= end && bottom <= vEnd) {
            next = nodeAfter(node, rendered);
            if (next) {
              walker = walk(next, rendered);
            }
          }
        }
      }
      if (range) {
        range.setEndAfter(rendered.lastChild);
        return range;
      }
    }
    findEndToken(rendered, source) {
      if (rendered.childNodes.length === 0) {
        return;
      }
      let lastChild = rendered.lastChild;
      let lastNodeIndex;
      while (lastChild && lastChild.lastChild) {
        if (!validNode(lastChild)) {
          lastChild = lastChild.previousSibling;
        } else if (!validNode(lastChild.lastChild)) {
          lastChild = prevValidNode(lastChild.lastChild);
          break;
        } else {
          lastChild = lastChild.lastChild;
        }
      }
      if (isText(lastChild)) {
        if (lastChild.parentNode.dataset.ref) {
          lastNodeIndex = indexOf(lastChild);
          lastChild = lastChild.parentNode;
        } else {
          lastChild = lastChild.previousSibling;
        }
      }
      let original = findElement(lastChild, source);
      if (lastNodeIndex) {
        original = original.childNodes[lastNodeIndex];
      }
      let after = nodeAfter(original);
      return this.breakAt(after);
    }
    textBreak(node, start, end, vStart, vEnd) {
      let wordwalker = words(node);
      let left = 0;
      let right = 0;
      let top = 0;
      let bottom = 0;
      let word, next, done, pos;
      let offset;
      while (!done) {
        next = wordwalker.next();
        word = next.value;
        done = next.done;
        if (!word) {
          break;
        }
        pos = getBoundingClientRect(word);
        left = Math.floor(pos.left);
        right = Math.floor(pos.right);
        top = Math.floor(pos.top);
        bottom = Math.floor(pos.bottom);
        if (left >= end || top >= vEnd) {
          offset = word.startOffset;
          break;
        }
        if (right > end || bottom > vEnd) {
          let letterwalker = letters(word);
          let letter, nextLetter, doneLetter;
          while (!doneLetter) {
            nextLetter = letterwalker.next();
            letter = nextLetter.value;
            doneLetter = nextLetter.done;
            if (!letter) {
              break;
            }
            pos = getBoundingClientRect(letter);
            left = Math.floor(pos.left);
            top = Math.floor(pos.top);
            if (left >= end || top >= vEnd) {
              offset = letter.startOffset;
              done = true;
              break;
            }
          }
        }
      }
      return offset;
    }
    removeOverflow(overflow, breakLetter) {
      let { startContainer } = overflow;
      let extracted = overflow.extractContents();
      this.hyphenateAtBreak(startContainer, breakLetter);
      return extracted;
    }
    hyphenateAtBreak(startContainer, breakLetter) {
      if (isText(startContainer)) {
        let startText = startContainer.textContent;
        let prevLetter = startText[startText.length - 1];
        if (breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter) || !breakLetter && /^\w|\u00AD$/.test(prevLetter)) {
          startContainer.parentNode.classList.add("pagedjs_hyphen");
          startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
        }
      }
    }
    equalTokens(a, b) {
      if (!a || !b) {
        return false;
      }
      if (a["node"] && b["node"] && a["node"] !== b["node"]) {
        return false;
      }
      if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
        return false;
      }
      return true;
    }
  };
  (0, import_event_emitter.default)(Layout.prototype);
  var layout_default = Layout;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/chunker/page.js
  var import_event_emitter2 = __toESM(require_event_emitter(), 1);
  var Page = class {
    constructor(pagesArea, pageTemplate, blank, hooks, options) {
      this.pagesArea = pagesArea;
      this.pageTemplate = pageTemplate;
      this.blank = blank;
      this.width = void 0;
      this.height = void 0;
      this.hooks = hooks;
      this.settings = options || {};
    }
    create(template, after) {
      let clone = document.importNode(this.pageTemplate.content, true);
      let page, index;
      if (after) {
        this.pagesArea.insertBefore(clone, after.nextElementSibling);
        index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
        page = this.pagesArea.children[index];
      } else {
        this.pagesArea.appendChild(clone);
        page = this.pagesArea.lastChild;
      }
      let pagebox = page.querySelector(".pagedjs_pagebox");
      let area = page.querySelector(".pagedjs_page_content");
      let footnotesArea = page.querySelector(".pagedjs_footnote_area");
      let size = area.getBoundingClientRect();
      area.style.columnWidth = Math.round(size.width) + "px";
      area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left) + var(--pagedjs-bleed-right) + var(--pagedjs-bleed-left) + var(--pagedjs-column-gap-offset))";
      this.width = Math.round(size.width);
      this.height = Math.round(size.height);
      this.element = page;
      this.pagebox = pagebox;
      this.area = area;
      this.footnotesArea = footnotesArea;
      return page;
    }
    createWrapper() {
      let wrapper = document.createElement("div");
      this.area.appendChild(wrapper);
      this.wrapper = wrapper;
      return wrapper;
    }
    index(pgnum) {
      this.position = pgnum;
      let page = this.element;
      let index = pgnum + 1;
      let id = `page-${index}`;
      this.id = id;
      page.dataset.pageNumber = index;
      page.setAttribute("id", id);
      if (this.name) {
        page.classList.add("pagedjs_" + this.name + "_page");
      }
      if (this.blank) {
        page.classList.add("pagedjs_blank_page");
      }
      if (pgnum === 0) {
        page.classList.add("pagedjs_first_page");
      }
      if (pgnum % 2 !== 1) {
        page.classList.remove("pagedjs_left_page");
        page.classList.add("pagedjs_right_page");
      } else {
        page.classList.remove("pagedjs_right_page");
        page.classList.add("pagedjs_left_page");
      }
    }
    /*
    	size(width, height) {
    		if (width === this.width && height === this.height) {
    			return;
    		}
    		this.width = width;
    		this.height = height;
    
    		this.element.style.width = Math.round(width) + "px";
    		this.element.style.height = Math.round(height) + "px";
    		this.element.style.columnWidth = Math.round(width) + "px";
    	}
    	*/
    async layout(contents, breakToken, maxChars) {
      this.clear();
      this.startToken = breakToken;
      let settings = this.settings;
      if (!settings.maxChars && maxChars) {
        settings.maxChars = maxChars;
      }
      this.layoutMethod = new layout_default(this.area, this.hooks, settings);
      let renderResult = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
      let newBreakToken = renderResult.breakToken;
      this.addListeners(contents);
      this.endToken = newBreakToken;
      return newBreakToken;
    }
    async append(contents, breakToken) {
      if (!this.layoutMethod) {
        return this.layout(contents, breakToken);
      }
      let renderResult = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
      let newBreakToken = renderResult.breakToken;
      this.endToken = newBreakToken;
      return newBreakToken;
    }
    getByParent(ref, entries) {
      let e;
      for (var i = 0; i < entries.length; i++) {
        e = entries[i];
        if (e.dataset.ref === ref) {
          return e;
        }
      }
    }
    onOverflow(func) {
      this._onOverflow = func;
    }
    onUnderflow(func) {
      this._onUnderflow = func;
    }
    clear() {
      this.removeListeners();
      this.wrapper && this.wrapper.remove();
      this.createWrapper();
    }
    addListeners(contents) {
      if (typeof ResizeObserver !== "undefined") {
        this.addResizeObserver(contents);
      } else {
        this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
        this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
        this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
      }
      this._onScroll = function() {
        if (this.listening) {
          this.element.scrollLeft = 0;
        }
      }.bind(this);
      this.element.addEventListener("scroll", this._onScroll);
      this.listening = true;
      return true;
    }
    removeListeners() {
      this.listening = false;
      if (typeof ResizeObserver !== "undefined" && this.ro) {
        this.ro.disconnect();
      } else if (this.element) {
        this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
        this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
      }
      this.element && this.element.removeEventListener("scroll", this._onScroll);
    }
    addResizeObserver(contents) {
      let wrapper = this.wrapper;
      let prevHeight = wrapper.getBoundingClientRect().height;
      this.ro = new ResizeObserver((entries) => {
        if (!this.listening) {
          return;
        }
        requestAnimationFrame(() => {
          for (let entry of entries) {
            const cr = entry.contentRect;
            if (cr.height > prevHeight) {
              this.checkOverflowAfterResize(contents);
              prevHeight = wrapper.getBoundingClientRect().height;
            } else if (cr.height < prevHeight) {
              this.checkUnderflowAfterResize(contents);
              prevHeight = cr.height;
            }
          }
        });
      });
      this.ro.observe(wrapper);
    }
    checkOverflowAfterResize(contents) {
      if (!this.listening || !this.layoutMethod) {
        return;
      }
      let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);
      if (newBreakToken) {
        this.endToken = newBreakToken;
        this._onOverflow && this._onOverflow(newBreakToken);
      }
    }
    checkUnderflowAfterResize(contents) {
      if (!this.listening || !this.layoutMethod) {
        return;
      }
      let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);
      if (endToken) {
        this._onUnderflow && this._onUnderflow(endToken);
      }
    }
    destroy() {
      this.removeListeners();
      this.element.remove();
      this.element = void 0;
      this.wrapper = void 0;
    }
  };
  (0, import_event_emitter2.default)(Page.prototype);
  var page_default = Page;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/chunker/parser.js
  var ContentParser = class {
    constructor(content, cb) {
      if (content && content.nodeType) {
        this.dom = this.add(content);
      } else if (typeof content === "string") {
        this.dom = this.parse(content);
      }
      return this.dom;
    }
    parse(markup, mime) {
      let range = document.createRange();
      let fragment = range.createContextualFragment(markup);
      this.addRefs(fragment);
      return fragment;
    }
    add(contents) {
      this.addRefs(contents);
      return contents;
    }
    addRefs(content) {
      var treeWalker = document.createTreeWalker(
        content,
        NodeFilter.SHOW_ELEMENT,
        null,
        false
      );
      let node = treeWalker.nextNode();
      while (node) {
        if (!node.hasAttribute("data-ref")) {
          let uuid = UUID();
          node.setAttribute("data-ref", uuid);
        }
        if (node.id) {
          node.setAttribute("data-id", node.id);
        }
        node = treeWalker.nextNode();
      }
    }
    find(ref) {
      return this.refs[ref];
    }
    destroy() {
      this.refs = void 0;
      this.dom = void 0;
    }
  };
  var parser_default = ContentParser;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/chunker/chunker.js
  var import_event_emitter3 = __toESM(require_event_emitter(), 1);

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/utils/queue.js
  var Queue = class {
    constructor(context) {
      this._q = [];
      this.context = context;
      this.tick = requestAnimationFrame;
      this.running = false;
      this.paused = false;
    }
    /**
     * Add an item to the queue
     * @return {Promise} enqueued
     */
    enqueue() {
      var deferred, promise;
      var queued;
      var task = [].shift.call(arguments);
      var args = arguments;
      if (!task) {
        throw new Error("No Task Provided");
      }
      if (typeof task === "function") {
        deferred = new defer();
        promise = deferred.promise;
        queued = {
          "task": task,
          "args": args,
          //"context"  : context,
          "deferred": deferred,
          "promise": promise
        };
      } else {
        queued = {
          "promise": task
        };
      }
      this._q.push(queued);
      if (this.paused == false && !this.running) {
        this.run();
      }
      return queued.promise;
    }
    /**
     * Run one item
     * @return {Promise} dequeued
     */
    dequeue() {
      var inwait, task, result;
      if (this._q.length && !this.paused) {
        inwait = this._q.shift();
        task = inwait.task;
        if (task) {
          result = task.apply(this.context, inwait.args);
          if (result && typeof result["then"] === "function") {
            return result.then(function() {
              inwait.deferred.resolve.apply(this.context, arguments);
            }.bind(this), function() {
              inwait.deferred.reject.apply(this.context, arguments);
            }.bind(this));
          } else {
            inwait.deferred.resolve.apply(this.context, result);
            return inwait.promise;
          }
        } else if (inwait.promise) {
          return inwait.promise;
        }
      } else {
        inwait = new defer();
        inwait.deferred.resolve();
        return inwait.promise;
      }
    }
    // Run All Immediately
    dump() {
      while (this._q.length) {
        this.dequeue();
      }
    }
    /**
     * Run all tasks sequentially, at convince
     * @return {Promise} all run
     */
    run() {
      if (!this.running) {
        this.running = true;
        this.defered = new defer();
      }
      this.tick.call(window, () => {
        if (this._q.length) {
          this.dequeue().then(function() {
            this.run();
          }.bind(this));
        } else {
          this.defered.resolve();
          this.running = void 0;
        }
      });
      if (this.paused == true) {
        this.paused = false;
      }
      return this.defered.promise;
    }
    /**
     * Flush all, as quickly as possible
     * @return {Promise} ran
     */
    flush() {
      if (this.running) {
        return this.running;
      }
      if (this._q.length) {
        this.running = this.dequeue().then(function() {
          this.running = void 0;
          return this.flush();
        }.bind(this));
        return this.running;
      }
    }
    /**
     * Clear all items in wait
     * @return {void}
     */
    clear() {
      this._q = [];
    }
    /**
     * Get the number of tasks in the queue
     * @return {number} tasks
     */
    length() {
      return this._q.length;
    }
    /**
     * Pause a running queue
     * @return {void}
     */
    pause() {
      this.paused = true;
    }
    /**
     * End the queue
     * @return {void}
     */
    stop() {
      this._q = [];
      this.running = false;
      this.paused = true;
    }
  };
  var queue_default = Queue;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/chunker/chunker.js
  var MAX_PAGES = false;
  var MAX_LAYOUTS = false;
  var TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
				<div class="pagedjs_footnote_area">
					<div class="pagedjs_footnote_content pagedjs_footnote_empty">
						<div class="pagedjs_footnote_inner_content"></div>
					</div>
				</div>
			</div>
		</div>
	</div>
</div>`;
  var Chunker = class {
    constructor(content, renderTo, options) {
      this.settings = options || {};
      this.hooks = {};
      this.hooks.beforeParsed = new hook_default(this);
      this.hooks.filter = new hook_default(this);
      this.hooks.afterParsed = new hook_default(this);
      this.hooks.beforePageLayout = new hook_default(this);
      this.hooks.onPageLayout = new hook_default(this);
      this.hooks.layout = new hook_default(this);
      this.hooks.renderNode = new hook_default(this);
      this.hooks.layoutNode = new hook_default(this);
      this.hooks.onOverflow = new hook_default(this);
      this.hooks.afterOverflowRemoved = new hook_default(this);
      this.hooks.onBreakToken = new hook_default();
      this.hooks.beforeRenderResult = new hook_default(this);
      this.hooks.afterPageLayout = new hook_default(this);
      this.hooks.finalizePage = new hook_default(this);
      this.hooks.afterRendered = new hook_default(this);
      this.pages = [];
      this.total = 0;
      this.q = new queue_default(this);
      this.stopped = false;
      this.rendered = false;
      this.content = content;
      this.charsPerBreak = [];
      this.maxChars;
      if (content) {
        this.flow(content, renderTo);
      }
    }
    setup(renderTo) {
      this.pagesArea = document.createElement("div");
      this.pagesArea.classList.add("pagedjs_pages");
      if (renderTo) {
        renderTo.appendChild(this.pagesArea);
      } else {
        document.querySelector("body").appendChild(this.pagesArea);
      }
      this.pageTemplate = document.createElement("template");
      this.pageTemplate.innerHTML = TEMPLATE;
    }
    async flow(content, renderTo) {
      let parsed;
      await this.hooks.beforeParsed.trigger(content, this);
      parsed = new parser_default(content);
      this.hooks.filter.triggerSync(parsed);
      this.source = parsed;
      this.breakToken = void 0;
      if (this.pagesArea && this.pageTemplate) {
        this.q.clear();
        this.removePages();
      } else {
        this.setup(renderTo);
      }
      this.emit("rendering", parsed);
      await this.hooks.afterParsed.trigger(parsed, this);
      await this.loadFonts();
      let rendered = await this.render(parsed, this.breakToken);
      while (rendered.canceled) {
        this.start();
        rendered = await this.render(parsed, this.breakToken);
      }
      this.rendered = true;
      this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);
      await this.hooks.afterRendered.trigger(this.pages, this);
      this.emit("rendered", this.pages);
      return this;
    }
    // oversetPages() {
    // 	let overset = [];
    // 	for (let i = 0; i < this.pages.length; i++) {
    // 		let page = this.pages[i];
    // 		if (page.overset) {
    // 			overset.push(page);
    // 			// page.overset = false;
    // 		}
    // 	}
    // 	return overset;
    // }
    //
    // async handleOverset(parsed) {
    // 	let overset = this.oversetPages();
    // 	if (overset.length) {
    // 		console.log("overset", overset);
    // 		let index = this.pages.indexOf(overset[0]) + 1;
    // 		console.log("INDEX", index);
    //
    // 		// Remove pages
    // 		// this.removePages(index);
    //
    // 		// await this.render(parsed, overset[0].overset);
    //
    // 		// return this.handleOverset(parsed);
    // 	}
    // }
    async render(parsed, startAt) {
      let renderer = this.layout(parsed, startAt);
      let done = false;
      let result;
      let loops = 0;
      while (!done) {
        result = await this.q.enqueue(() => {
          return this.renderAsync(renderer);
        });
        done = result.done;
        if (MAX_LAYOUTS) {
          loops += 1;
          if (loops >= MAX_LAYOUTS) {
            this.stop();
            break;
          }
        }
      }
      return result;
    }
    start() {
      this.rendered = false;
      this.stopped = false;
    }
    stop() {
      this.stopped = true;
    }
    renderOnIdle(renderer) {
      return new Promise((resolve2) => {
        requestIdleCallback(async () => {
          if (this.stopped) {
            return resolve2({ done: true, canceled: true });
          }
          let result = await renderer.next();
          if (this.stopped) {
            resolve2({ done: true, canceled: true });
          } else {
            resolve2(result);
          }
        });
      });
    }
    async renderAsync(renderer) {
      if (this.stopped) {
        return { done: true, canceled: true };
      }
      let result = await renderer.next();
      if (this.stopped) {
        return { done: true, canceled: true };
      } else {
        return result;
      }
    }
    async handleBreaks(node, force) {
      let currentPage = this.total + 1;
      let currentPosition = currentPage % 2 === 0 ? "left" : "right";
      let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
      let previousBreakAfter;
      let breakBefore;
      let page;
      if (currentPage === 1) {
        return;
      }
      if (node && typeof node.dataset !== "undefined" && typeof node.dataset.previousBreakAfter !== "undefined") {
        previousBreakAfter = node.dataset.previousBreakAfter;
      }
      if (node && typeof node.dataset !== "undefined" && typeof node.dataset.breakBefore !== "undefined") {
        breakBefore = node.dataset.breakBefore;
      }
      if (force) {
        page = this.addPage(true);
      } else if (previousBreakAfter && (previousBreakAfter === "left" || previousBreakAfter === "right") && previousBreakAfter !== currentPosition) {
        page = this.addPage(true);
      } else if (previousBreakAfter && (previousBreakAfter === "verso" || previousBreakAfter === "recto") && previousBreakAfter !== currentSide) {
        page = this.addPage(true);
      } else if (breakBefore && (breakBefore === "left" || breakBefore === "right") && breakBefore !== currentPosition) {
        page = this.addPage(true);
      } else if (breakBefore && (breakBefore === "verso" || breakBefore === "recto") && breakBefore !== currentSide) {
        page = this.addPage(true);
      }
      if (page) {
        await this.hooks.beforePageLayout.trigger(page, void 0, void 0, this);
        this.emit("page", page);
        await this.hooks.afterPageLayout.trigger(page.element, page, void 0, this);
        await this.hooks.finalizePage.trigger(page.element, page, void 0, this);
        this.emit("renderedPage", page);
      }
    }
    async *layout(content, startAt) {
      let breakToken = startAt || false;
      let tokens = [];
      while (breakToken !== void 0 && (MAX_PAGES ? this.total < MAX_PAGES : true)) {
        if (breakToken && breakToken.node) {
          await this.handleBreaks(breakToken.node);
        } else {
          await this.handleBreaks(content.firstChild);
        }
        let page = this.addPage();
        await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
        this.emit("page", page);
        breakToken = await page.layout(content, breakToken, this.maxChars);
        if (breakToken) {
          let newToken = breakToken.toJSON(true);
          if (tokens.lastIndexOf(newToken) > -1) {
            let err = new OverflowContentError("Layout repeated", [breakToken.node]);
            console.error("Layout repeated at: ", breakToken.node);
            return err;
          } else {
            tokens.push(newToken);
          }
        }
        await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
        await this.hooks.finalizePage.trigger(page.element, page, void 0, this);
        this.emit("renderedPage", page);
        this.recoredCharLength(page.wrapper.textContent.length);
        yield breakToken;
      }
    }
    recoredCharLength(length) {
      if (length === 0) {
        return;
      }
      this.charsPerBreak.push(length);
      if (this.charsPerBreak.length > 4) {
        this.charsPerBreak.shift();
      }
      this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / this.charsPerBreak.length;
    }
    removePages(fromIndex = 0) {
      if (fromIndex >= this.pages.length) {
        return;
      }
      for (let i = fromIndex; i < this.pages.length; i++) {
        this.pages[i].destroy();
      }
      if (fromIndex > 0) {
        this.pages.splice(fromIndex);
      } else {
        this.pages = [];
      }
      this.total = this.pages.length;
    }
    addPage(blank) {
      let lastPage = this.pages[this.pages.length - 1];
      let page = new page_default(this.pagesArea, this.pageTemplate, blank, this.hooks, this.settings);
      this.pages.push(page);
      page.create(void 0, lastPage && lastPage.element);
      page.index(this.total);
      if (!blank) {
        page.onOverflow((overflowToken) => {
          console.warn("overflow on", page.id, overflowToken);
          if (this.rendered) {
            return;
          }
          let index = this.pages.indexOf(page) + 1;
          this.stop();
          this.breakToken = overflowToken;
          this.removePages(index);
          if (this.rendered === true) {
            this.rendered = false;
            this.q.enqueue(async () => {
              this.start();
              await this.render(this.source, this.breakToken);
              this.rendered = true;
            });
          }
        });
        page.onUnderflow((overflowToken) => {
        });
      }
      this.total = this.pages.length;
      return page;
    }
    /*
    	insertPage(index, blank) {
    		let lastPage = this.pages[index];
    		// Create a new page from the template
    		let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);
    
    		let total = this.pages.splice(index, 0, page);
    
    		// Create the pages
    		page.create(undefined, lastPage && lastPage.element);
    
    		page.index(index + 1);
    
    		for (let i = index + 2; i < this.pages.length; i++) {
    			this.pages[i].index(i);
    		}
    
    		if (!blank) {
    			// Listen for page overflow
    			page.onOverflow((overflowToken) => {
    				if (total < this.pages.length) {
    					this.pages[total].layout(this.source, overflowToken);
    				} else {
    					let newPage = this.addPage();
    					newPage.layout(this.source, overflowToken);
    				}
    			});
    
    			page.onUnderflow(() => {
    				// console.log("underflow on", page.id);
    			});
    		}
    
    		this.total += 1;
    
    		return page;
    	}
    	*/
    async clonePage(originalPage) {
      let lastPage = this.pages[this.pages.length - 1];
      let page = new page_default(this.pagesArea, this.pageTemplate, false, this.hooks);
      this.pages.push(page);
      page.create(void 0, lastPage && lastPage.element);
      page.index(this.total);
      await this.hooks.beforePageLayout.trigger(page, void 0, void 0, this);
      this.emit("page", page);
      for (const className of originalPage.element.classList) {
        if (className !== "pagedjs_left_page" && className !== "pagedjs_right_page") {
          page.element.classList.add(className);
        }
      }
      await this.hooks.afterPageLayout.trigger(page.element, page, void 0, this);
      await this.hooks.finalizePage.trigger(page.element, page, void 0, this);
      this.emit("renderedPage", page);
    }
    loadFonts() {
      let fontPromises = [];
      (document.fonts || []).forEach((fontFace) => {
        if (fontFace.status !== "loaded") {
          let fontLoaded = fontFace.load().then((r) => {
            return fontFace.family;
          }, (r) => {
            console.warn("Failed to preload font-family:", fontFace.family);
            return fontFace.family;
          });
          fontPromises.push(fontLoaded);
        }
      });
      return Promise.all(fontPromises).catch((err) => {
        console.warn(err);
      });
    }
    destroy() {
      this.pagesArea.remove();
      this.pageTemplate.remove();
    }
  };
  (0, import_event_emitter3.default)(Chunker.prototype);
  var chunker_default = Chunker;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/polisher/sheet.js
  var import_css_tree = __toESM(require_lib(), 1);
  var Sheet = class {
    constructor(url, hooks) {
      if (hooks) {
        this.hooks = hooks;
      } else {
        this.hooks = {};
        this.hooks.onUrl = new hook_default(this);
        this.hooks.onAtPage = new hook_default(this);
        this.hooks.onAtMedia = new hook_default(this);
        this.hooks.onRule = new hook_default(this);
        this.hooks.onDeclaration = new hook_default(this);
        this.hooks.onSelector = new hook_default(this);
        this.hooks.onPseudoSelector = new hook_default(this);
        this.hooks.onContent = new hook_default(this);
        this.hooks.onImport = new hook_default(this);
        this.hooks.beforeTreeParse = new hook_default(this);
        this.hooks.beforeTreeWalk = new hook_default(this);
        this.hooks.afterTreeWalk = new hook_default(this);
      }
      try {
        this.url = new URL(url, window.location.href);
      } catch (e) {
        this.url = new URL(window.location.href);
      }
    }
    // parse
    async parse(text) {
      this.text = text;
      await this.hooks.beforeTreeParse.trigger(this.text, this);
      this.ast = import_css_tree.default.parse(this._text);
      await this.hooks.beforeTreeWalk.trigger(this.ast);
      this.replaceUrls(this.ast);
      this.id = UUID();
      this.replaceIds(this.ast);
      this.imported = [];
      this.urls(this.ast);
      this.rules(this.ast);
      this.atrules(this.ast);
      await this.hooks.afterTreeWalk.trigger(this.ast, this);
      return this.ast;
    }
    insertRule(rule) {
      let inserted = this.ast.children.appendData(rule);
      this.declarations(rule);
      return inserted;
    }
    urls(ast) {
      import_css_tree.default.walk(ast, {
        visit: "Url",
        enter: (node, item, list) => {
          this.hooks.onUrl.trigger(node, item, list);
        }
      });
    }
    atrules(ast) {
      import_css_tree.default.walk(ast, {
        visit: "Atrule",
        enter: (node, item, list) => {
          const basename = import_css_tree.default.keyword(node.name).basename;
          if (basename === "page") {
            this.hooks.onAtPage.trigger(node, item, list);
            this.declarations(node, item, list);
          }
          if (basename === "media") {
            this.hooks.onAtMedia.trigger(node, item, list);
            this.declarations(node, item, list);
          }
          if (basename === "import") {
            this.hooks.onImport.trigger(node, item, list);
            this.imports(node, item, list);
          }
        }
      });
    }
    rules(ast) {
      import_css_tree.default.walk(ast, {
        visit: "Rule",
        enter: (ruleNode, ruleItem, rulelist) => {
          this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
          this.declarations(ruleNode, ruleItem, rulelist);
          this.onSelector(ruleNode, ruleItem, rulelist);
        }
      });
    }
    declarations(ruleNode, ruleItem, rulelist) {
      import_css_tree.default.walk(ruleNode, {
        visit: "Declaration",
        enter: (declarationNode, dItem, dList) => {
          this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, { ruleNode, ruleItem, rulelist });
          if (declarationNode.property === "content") {
            import_css_tree.default.walk(declarationNode, {
              visit: "Function",
              enter: (funcNode, fItem, fList) => {
                this.hooks.onContent.trigger(funcNode, fItem, fList, { declarationNode, dItem, dList }, { ruleNode, ruleItem, rulelist });
              }
            });
          }
        }
      });
    }
    // add pseudo elements to parser
    onSelector(ruleNode, ruleItem, rulelist) {
      import_css_tree.default.walk(ruleNode, {
        visit: "Selector",
        enter: (selectNode, selectItem, selectList) => {
          this.hooks.onSelector.trigger(selectNode, selectItem, selectList, { ruleNode, ruleItem, rulelist });
          if (selectNode.children.forEach((node) => {
            if (node.type === "PseudoElementSelector") {
              import_css_tree.default.walk(node, {
                visit: "PseudoElementSelector",
                enter: (pseudoNode, pItem, pList) => {
                  this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, { selectNode, selectItem, selectList }, { ruleNode, ruleItem, rulelist });
                }
              });
            }
          }))
            ;
        }
      });
    }
    replaceUrls(ast) {
      import_css_tree.default.walk(ast, {
        visit: "Url",
        enter: (node, item, list) => {
          let content = node.value.value;
          if (node.value.type === "Raw" && content.startsWith("data:") || node.value.type === "String" && (content.startsWith('"data:') || content.startsWith("'data:"))) {
          } else {
            let href = content.replace(/["']/g, "");
            let url = new URL(href, this.url);
            node.value.value = url.toString();
          }
        }
      });
    }
    addScope(ast, id) {
      import_css_tree.default.walk(ast, {
        visit: "Selector",
        enter: (node, item, list) => {
          let children = node.children;
          children.prepend(children.createItem({
            type: "WhiteSpace",
            value: " "
          }));
          children.prepend(children.createItem({
            type: "IdSelector",
            name: id,
            loc: null,
            children: null
          }));
        }
      });
    }
    getNamedPageSelectors(ast) {
      let namedPageSelectors = {};
      import_css_tree.default.walk(ast, {
        visit: "Rule",
        enter: (node, item, list) => {
          import_css_tree.default.walk(node, {
            visit: "Declaration",
            enter: (declaration, dItem, dList) => {
              if (declaration.property === "page") {
                let value = declaration.value.children.first();
                let name = value.name;
                let selector = import_css_tree.default.generate(node.prelude);
                namedPageSelectors[name] = {
                  name,
                  selector
                };
                declaration.property = "break-before";
                value.type = "Identifier";
                value.name = "always";
              }
            }
          });
        }
      });
      return namedPageSelectors;
    }
    replaceIds(ast) {
      import_css_tree.default.walk(ast, {
        visit: "Rule",
        enter: (node, item, list) => {
          import_css_tree.default.walk(node, {
            visit: "IdSelector",
            enter: (idNode, idItem, idList) => {
              let name = idNode.name;
              idNode.flags = null;
              idNode.matcher = "=";
              idNode.name = { type: "Identifier", loc: null, name: "data-id" };
              idNode.type = "AttributeSelector";
              idNode.value = { type: "String", loc: null, value: `"${name}"` };
            }
          });
        }
      });
    }
    imports(node, item, list) {
      let queries = [];
      import_css_tree.default.walk(node, {
        visit: "MediaQuery",
        enter: (mqNode, mqItem, mqList) => {
          import_css_tree.default.walk(mqNode, {
            visit: "Identifier",
            enter: (identNode, identItem, identList) => {
              queries.push(identNode.name);
            }
          });
        }
      });
      let shouldNotApply = queries.some((query, index) => {
        let q = query;
        if (q === "not") {
          q = queries[index + 1];
          return !(q === "screen" || q === "speech");
        } else {
          return q === "screen" || q === "speech";
        }
      });
      if (shouldNotApply) {
        return;
      }
      import_css_tree.default.walk(node, {
        visit: "String",
        enter: (urlNode, urlItem, urlList) => {
          let href = urlNode.value.replace(/["']/g, "");
          let url = new URL(href, this.url);
          let value = url.toString();
          this.imported.push(value);
          list.remove(item);
        }
      });
    }
    set text(t) {
      this._text = t;
    }
    get text() {
      return this._text;
    }
    // generate string
    toString(ast) {
      return import_css_tree.default.generate(ast || this.ast);
    }
  };
  var sheet_default = Sheet;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/polisher/base.js
  var base_default = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-footnotes-height: 0mm;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-shadow: white;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
	--pagedjs-footnotes-count: 0;
	--pagedjs-column-gap-offset: 1000px;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
	box-shadow: 1px 0px 0px 0px var(--pagedjs-crop-shadow);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
	box-shadow: -1px 0px 0px 0px var(--pagedjs-crop-shadow);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
	box-shadow: 0px 1px 0px 0px var(--pagedjs-crop-shadow);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
	box-shadow: 0px -1px 0px 0px var(--pagedjs-crop-shadow);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: calc(100% - var(--pagedjs-footnotes-height));
	position: relative;
	column-fill: auto;
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content > div {
	height: inherit;
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_footnote_area {
	position: relative;
	overflow: hidden;
	height: var(--pagedjs-footnotes-height);
	display: flex;
    justify-content: flex-end;
    flex-flow: column;
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_footnote_area > .pagedjs_footnote_content {
	overflow: hidden;
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_footnote_area > .pagedjs_footnote_inner_content {
	overflow: hidden;
}

.pagedjs_area [data-footnote-call] {
	all: unset;
	counter-increment: footnote;
}

.pagedjs_area [data-split-from] {
	counter-increment: unset;
	counter-reset: unset;
}

[data-footnote-call]::after {
	vertical-align: super;
	font-size: 65%;
	line-height: normal;
	content: counter(footnote);
}

@supports ( font-variant-position: super ) {
	[data-footnote-call]::after {
		vertical-align: baseline;
		font-size: 100%;
		line-height: inherit;
		font-variant-position: super;
	}
}

.pagedjs_footnote_empty {
	display: none;
}

.pagedjs_area [data-split-from] {
	counter-increment: unset;
	counter-reset: unset;
}

[data-footnote-marker] {
	text-indent: 0;
	display: list-item;
	list-style-position: inside;
}

[data-footnote-marker][data-split-from] {
	list-style: none;
}

[data-footnote-marker]:not([data-split-from]) {
	counter-increment: footnote-marker;
}

[data-footnote-marker]::marker {
	content: counter(footnote-marker) ". ";
}

[data-footnote-marker][data-split-from]::marker {
	content: unset;
}

.pagedjs_area .pagedjs_footnote_inner_content [data-note-display="inline"] {
 	display: inline;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count) footnote var(--pagedjs-footnotes-count) footnote-marker var(--pagedjs-footnotes-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:not([data-footnote-call]):after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:not([data-footnote-call])::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:not([data-footnote-call]):before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:not([data-footnote-call])::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
		-webkit-print-color-adjust: exact;
		print-color-adjust: exact;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/utils/request.js
  async function request(url, options = {}) {
    return new Promise(function(resolve2, reject) {
      let request2 = new XMLHttpRequest();
      request2.open(options.method || "get", url, true);
      for (let i in options.headers) {
        request2.setRequestHeader(i, options.headers[i]);
      }
      request2.withCredentials = options.credentials === "include";
      request2.onload = () => {
        const status = request2.status === 0 && url.startsWith("file://") ? 200 : request2.status;
        resolve2(new Response(request2.responseText, { status }));
      };
      request2.onerror = reject;
      request2.send(options.body || null);
    });
  }

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/polisher/polisher.js
  var Polisher = class {
    constructor(setup) {
      this.sheets = [];
      this.inserted = [];
      this.hooks = {};
      this.hooks.onUrl = new hook_default(this);
      this.hooks.onAtPage = new hook_default(this);
      this.hooks.onAtMedia = new hook_default(this);
      this.hooks.onRule = new hook_default(this);
      this.hooks.onDeclaration = new hook_default(this);
      this.hooks.onContent = new hook_default(this);
      this.hooks.onSelector = new hook_default(this);
      this.hooks.onPseudoSelector = new hook_default(this);
      this.hooks.onImport = new hook_default(this);
      this.hooks.beforeTreeParse = new hook_default(this);
      this.hooks.beforeTreeWalk = new hook_default(this);
      this.hooks.afterTreeWalk = new hook_default(this);
      if (setup !== false) {
        this.setup();
      }
    }
    setup() {
      this.base = this.insert(base_default);
      this.styleEl = document.createElement("style");
      document.head.appendChild(this.styleEl);
      this.styleSheet = this.styleEl.sheet;
      return this.styleSheet;
    }
    async add() {
      let fetched = [];
      let urls = [];
      for (var i = 0; i < arguments.length; i++) {
        let f;
        if (typeof arguments[i] === "object") {
          for (let url in arguments[i]) {
            let obj = arguments[i];
            f = new Promise(function(resolve2, reject) {
              urls.push(url);
              resolve2(obj[url]);
            });
          }
        } else {
          urls.push(arguments[i]);
          f = request(arguments[i]).then((response) => {
            return response.text();
          });
        }
        fetched.push(f);
      }
      return await Promise.all(fetched).then(async (originals) => {
        let text = "";
        for (let index = 0; index < originals.length; index++) {
          text = await this.convertViaSheet(originals[index], urls[index]);
          this.insert(text);
        }
        return text;
      });
    }
    async convertViaSheet(cssStr, href) {
      let sheet = new sheet_default(href, this.hooks);
      await sheet.parse(cssStr);
      for (let url of sheet.imported) {
        let str = await request(url).then((response) => {
          return response.text();
        });
        let text = await this.convertViaSheet(str, url);
        this.insert(text);
      }
      this.sheets.push(sheet);
      if (typeof sheet.width !== "undefined") {
        this.width = sheet.width;
      }
      if (typeof sheet.height !== "undefined") {
        this.height = sheet.height;
      }
      if (typeof sheet.orientation !== "undefined") {
        this.orientation = sheet.orientation;
      }
      return sheet.toString();
    }
    insert(text) {
      let head = document.querySelector("head");
      let style = document.createElement("style");
      style.setAttribute("data-pagedjs-inserted-styles", "true");
      style.appendChild(document.createTextNode(text));
      head.appendChild(style);
      this.inserted.push(style);
      return style;
    }
    destroy() {
      this.styleEl.remove();
      this.inserted.forEach((s) => {
        s.remove();
      });
      this.sheets = [];
    }
  };
  var polisher_default = Polisher;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/polyfill/previewer.js
  var import_event_emitter6 = __toESM(require_event_emitter(), 1);

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/handler.js
  var import_event_emitter4 = __toESM(require_event_emitter(), 1);
  var Handler = class {
    constructor(chunker, polisher, caller) {
      let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
      this.chunker = chunker;
      this.polisher = polisher;
      this.caller = caller;
      for (let name in hooks) {
        if (name in this) {
          let hook = hooks[name];
          hook.register(this[name].bind(this));
        }
      }
    }
  };
  (0, import_event_emitter4.default)(Handler.prototype);
  var handler_default = Handler;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/paged-media/atpage.js
  var import_css_tree2 = __toESM(require_lib(), 1);

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/polisher/sizes.js
  var sizes_default = {
    "A0": {
      width: {
        value: 841,
        unit: "mm"
      },
      height: {
        value: 1189,
        unit: "mm"
      }
    },
    "A1": {
      width: {
        value: 594,
        unit: "mm"
      },
      height: {
        value: 841,
        unit: "mm"
      }
    },
    "A2": {
      width: {
        value: 420,
        unit: "mm"
      },
      height: {
        value: 594,
        unit: "mm"
      }
    },
    "A3": {
      width: {
        value: 297,
        unit: "mm"
      },
      height: {
        value: 420,
        unit: "mm"
      }
    },
    "A4": {
      width: {
        value: 210,
        unit: "mm"
      },
      height: {
        value: 297,
        unit: "mm"
      }
    },
    "A5": {
      width: {
        value: 148,
        unit: "mm"
      },
      height: {
        value: 210,
        unit: "mm"
      }
    },
    "A6": {
      width: {
        value: 105,
        unit: "mm"
      },
      height: {
        value: 148,
        unit: "mm"
      }
    },
    "A7": {
      width: {
        value: 74,
        unit: "mm"
      },
      height: {
        value: 105,
        unit: "mm"
      }
    },
    "A8": {
      width: {
        value: 52,
        unit: "mm"
      },
      height: {
        value: 74,
        unit: "mm"
      }
    },
    "A9": {
      width: {
        value: 37,
        unit: "mm"
      },
      height: {
        value: 52,
        unit: "mm"
      }
    },
    "A10": {
      width: {
        value: 26,
        unit: "mm"
      },
      height: {
        value: 37,
        unit: "mm"
      }
    },
    "B4": {
      width: {
        value: 250,
        unit: "mm"
      },
      height: {
        value: 353,
        unit: "mm"
      }
    },
    "B5": {
      width: {
        value: 176,
        unit: "mm"
      },
      height: {
        value: 250,
        unit: "mm"
      }
    },
    "letter": {
      width: {
        value: 8.5,
        unit: "in"
      },
      height: {
        value: 11,
        unit: "in"
      }
    },
    "legal": {
      width: {
        value: 8.5,
        unit: "in"
      },
      height: {
        value: 14,
        unit: "in"
      }
    },
    "ledger": {
      width: {
        value: 11,
        unit: "in"
      },
      height: {
        value: 17,
        unit: "in"
      }
    }
  };

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/paged-media/atpage.js
  var AtPage = class extends handler_default {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.pages = {};
      this.width = void 0;
      this.height = void 0;
      this.orientation = void 0;
      this.marginalia = {};
    }
    pageModel(selector) {
      return {
        selector,
        name: void 0,
        psuedo: void 0,
        nth: void 0,
        marginalia: {},
        width: void 0,
        height: void 0,
        orientation: void 0,
        margin: {
          top: {},
          right: {},
          left: {},
          bottom: {}
        },
        padding: {
          top: {},
          right: {},
          left: {},
          bottom: {}
        },
        border: {
          top: {},
          right: {},
          left: {},
          bottom: {}
        },
        backgroundOrigin: void 0,
        block: {},
        marks: void 0,
        notes: void 0,
        added: false
      };
    }
    // Find and Remove @page rules
    onAtPage(node, item, list) {
      let page, marginalia;
      let selector = "";
      let named, psuedo, nth;
      let needsMerge = false;
      if (node.prelude) {
        named = this.getTypeSelector(node);
        psuedo = this.getPsuedoSelector(node);
        nth = this.getNthSelector(node);
        selector = import_css_tree2.default.generate(node.prelude);
      } else {
        selector = "*";
      }
      if (selector in this.pages) {
        page = this.pages[selector];
        marginalia = this.replaceMarginalia(node);
        needsMerge = true;
        page.added = false;
      } else {
        page = this.pageModel(selector);
        marginalia = this.replaceMarginalia(node);
        this.pages[selector] = page;
      }
      page.name = named;
      page.psuedo = psuedo;
      page.nth = nth;
      if (needsMerge) {
        page.marginalia = Object.assign(page.marginalia, marginalia);
      } else {
        page.marginalia = marginalia;
      }
      let notes = this.replaceNotes(node);
      page.notes = notes;
      let declarations = this.replaceDeclarations(node);
      if (declarations.size) {
        page.size = declarations.size;
        page.width = declarations.size.width;
        page.height = declarations.size.height;
        page.orientation = declarations.size.orientation;
        page.format = declarations.size.format;
      }
      if (declarations.bleed && declarations.bleed[0] != "auto") {
        switch (declarations.bleed.length) {
          case 4:
            page.bleed = {
              top: declarations.bleed[0],
              right: declarations.bleed[1],
              bottom: declarations.bleed[2],
              left: declarations.bleed[3]
            };
            break;
          case 3:
            page.bleed = {
              top: declarations.bleed[0],
              right: declarations.bleed[1],
              bottom: declarations.bleed[2],
              left: declarations.bleed[1]
            };
            break;
          case 2:
            page.bleed = {
              top: declarations.bleed[0],
              right: declarations.bleed[1],
              bottom: declarations.bleed[0],
              left: declarations.bleed[1]
            };
            break;
          default:
            page.bleed = {
              top: declarations.bleed[0],
              right: declarations.bleed[0],
              bottom: declarations.bleed[0],
              left: declarations.bleed[0]
            };
        }
      }
      if (declarations.marks) {
        if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
          page.bleed = {
            top: { value: 6, unit: "mm" },
            right: { value: 6, unit: "mm" },
            bottom: { value: 6, unit: "mm" },
            left: { value: 6, unit: "mm" }
          };
        }
        page.marks = declarations.marks;
      }
      if (declarations.margin) {
        page.margin = declarations.margin;
      }
      if (declarations.padding) {
        page.padding = declarations.padding;
      }
      if (declarations.border) {
        page.border = declarations.border;
      }
      if (declarations.marks) {
        page.marks = declarations.marks;
      }
      if (needsMerge) {
        page.block.children.appendList(node.block.children);
      } else {
        page.block = node.block;
      }
      list.remove(item);
    }
    /* Handled in breaks */
    /*
    afterParsed(parsed) {
    	for (let b in this.named) {
    		// Find elements
    		let elements = parsed.querySelectorAll(b);
    		// Add break data
    		for (var i = 0; i < elements.length; i++) {
    			elements[i].setAttribute("data-page", this.named[b]);
    		}
    	}
    }
    */
    afterTreeWalk(ast, sheet) {
      let dirtyPage = "*" in this.pages && this.pages["*"].added === false;
      this.addPageClasses(this.pages, ast, sheet);
      if (dirtyPage) {
        let width = this.pages["*"].width;
        let height = this.pages["*"].height;
        let format2 = this.pages["*"].format;
        let orientation = this.pages["*"].orientation;
        let bleed = this.pages["*"].bleed;
        let marks = this.pages["*"].marks;
        let bleedverso = void 0;
        let bleedrecto = void 0;
        if (":left" in this.pages) {
          bleedverso = this.pages[":left"].bleed;
        }
        if (":right" in this.pages) {
          bleedrecto = this.pages[":right"].bleed;
        }
        if (width && height && (this.width !== width || this.height !== height)) {
          this.width = width;
          this.height = height;
          this.format = format2;
          this.orientation = orientation;
          this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
          this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);
          this.emit("size", { width, height, orientation, format: format2, bleed });
          this.emit("atpages", this.pages);
        }
      }
    }
    getTypeSelector(ast) {
      let name;
      import_css_tree2.default.walk(ast, {
        visit: "TypeSelector",
        enter: (node, item, list) => {
          name = node.name;
        }
      });
      return name;
    }
    getPsuedoSelector(ast) {
      let name;
      import_css_tree2.default.walk(ast, {
        visit: "PseudoClassSelector",
        enter: (node, item, list) => {
          if (node.name !== "nth") {
            name = node.name;
          }
        }
      });
      return name;
    }
    getNthSelector(ast) {
      let nth;
      import_css_tree2.default.walk(ast, {
        visit: "PseudoClassSelector",
        enter: (node, item, list) => {
          if (node.name === "nth" && node.children) {
            let raw = node.children.first();
            nth = raw.value;
          }
        }
      });
      return nth;
    }
    replaceMarginalia(ast) {
      let parsed = {};
      const MARGINS = [
        "top-left-corner",
        "top-left",
        "top",
        "top-center",
        "top-right",
        "top-right-corner",
        "bottom-left-corner",
        "bottom-left",
        "bottom",
        "bottom-center",
        "bottom-right",
        "bottom-right-corner",
        "left-top",
        "left-middle",
        "left",
        "left-bottom",
        "top-right-corner",
        "right-top",
        "right-middle",
        "right",
        "right-bottom",
        "right-right-corner"
      ];
      import_css_tree2.default.walk(ast.block, {
        visit: "Atrule",
        enter: (node, item, list) => {
          let name = node.name;
          if (MARGINS.includes(name)) {
            if (name === "top") {
              name = "top-center";
            }
            if (name === "right") {
              name = "right-middle";
            }
            if (name === "left") {
              name = "left-middle";
            }
            if (name === "bottom") {
              name = "bottom-center";
            }
            parsed[name] = node.block;
            list.remove(item);
          }
        }
      });
      return parsed;
    }
    replaceNotes(ast) {
      let parsed = {};
      import_css_tree2.default.walk(ast.block, {
        visit: "Atrule",
        enter: (node, item, list) => {
          let name = node.name;
          if (name === "footnote") {
            parsed[name] = node.block;
            list.remove(item);
          }
        }
      });
      return parsed;
    }
    replaceDeclarations(ast) {
      let parsed = {};
      import_css_tree2.default.walk(ast.block, {
        visit: "Declaration",
        enter: (declaration, dItem, dList) => {
          let prop = import_css_tree2.default.property(declaration.property).name;
          if (prop === "marks") {
            parsed.marks = [];
            import_css_tree2.default.walk(declaration, {
              visit: "Identifier",
              enter: (ident) => {
                parsed.marks.push(ident.name);
              }
            });
            dList.remove(dItem);
          } else if (prop === "margin") {
            parsed.margin = this.getMargins(declaration);
            dList.remove(dItem);
          } else if (prop.indexOf("margin-") === 0) {
            let m = prop.substring("margin-".length);
            if (!parsed.margin) {
              parsed.margin = {
                top: {},
                right: {},
                left: {},
                bottom: {}
              };
            }
            parsed.margin[m] = declaration.value.children.first();
            dList.remove(dItem);
          } else if (prop === "padding") {
            parsed.padding = this.getPaddings(declaration.value);
            dList.remove(dItem);
          } else if (prop.indexOf("padding-") === 0) {
            let p = prop.substring("padding-".length);
            if (!parsed.padding) {
              parsed.padding = {
                top: {},
                right: {},
                left: {},
                bottom: {}
              };
            }
            parsed.padding[p] = declaration.value.children.first();
            dList.remove(dItem);
          } else if (prop === "border") {
            if (!parsed.border) {
              parsed.border = {
                top: {},
                right: {},
                left: {},
                bottom: {}
              };
            }
            parsed.border.top = import_css_tree2.default.generate(declaration.value);
            parsed.border.right = import_css_tree2.default.generate(declaration.value);
            parsed.border.left = import_css_tree2.default.generate(declaration.value);
            parsed.border.bottom = import_css_tree2.default.generate(declaration.value);
            dList.remove(dItem);
          } else if (prop.indexOf("border-") === 0) {
            if (!parsed.border) {
              parsed.border = {
                top: {},
                right: {},
                left: {},
                bottom: {}
              };
            }
            let p = prop.substring("border-".length);
            parsed.border[p] = import_css_tree2.default.generate(declaration.value);
            dList.remove(dItem);
          } else if (prop === "size") {
            parsed.size = this.getSize(declaration);
            dList.remove(dItem);
          } else if (prop === "bleed") {
            parsed.bleed = [];
            import_css_tree2.default.walk(declaration, {
              enter: (subNode) => {
                switch (subNode.type) {
                  case "String":
                    if (subNode.value.indexOf("auto") > -1) {
                      parsed.bleed.push("auto");
                    }
                    break;
                  case "Dimension":
                    parsed.bleed.push({
                      value: subNode.value,
                      unit: subNode.unit
                    });
                    break;
                  case "Number":
                    parsed.bleed.push({
                      value: subNode.value,
                      unit: "px"
                    });
                    break;
                  default:
                }
              }
            });
            dList.remove(dItem);
          }
        }
      });
      return parsed;
    }
    getSize(declaration) {
      let width, height, orientation, format2;
      import_css_tree2.default.walk(declaration, {
        visit: "Dimension",
        enter: (node, item, list) => {
          let { value, unit } = node;
          if (typeof width === "undefined") {
            width = { value, unit };
          } else if (typeof height === "undefined") {
            height = { value, unit };
          }
        }
      });
      import_css_tree2.default.walk(declaration, {
        visit: "String",
        enter: (node, item, list) => {
          let name = node.value.replace(/["|']/g, "");
          let s = sizes_default[name];
          if (s) {
            width = s.width;
            height = s.height;
          }
        }
      });
      import_css_tree2.default.walk(declaration, {
        visit: "Identifier",
        enter: (node, item, list) => {
          let name = node.name;
          if (name === "landscape" || name === "portrait") {
            orientation = node.name;
          } else if (name !== "auto") {
            let s = sizes_default[name];
            if (s) {
              width = s.width;
              height = s.height;
            }
            format2 = name;
          }
        }
      });
      return {
        width,
        height,
        orientation,
        format: format2
      };
    }
    getMargins(declaration) {
      let margins = [];
      let margin = {
        top: {},
        right: {},
        left: {},
        bottom: {}
      };
      import_css_tree2.default.walk(declaration, {
        enter: (node) => {
          switch (node.type) {
            case "Dimension":
              margins.push(node);
              break;
            case "Number":
              margins.push({ value: node.value, unit: "px" });
              break;
            default:
          }
        }
      });
      if (margins.length === 1) {
        for (let m in margin) {
          margin[m] = margins[0];
        }
      } else if (margins.length === 2) {
        margin.top = margins[0];
        margin.right = margins[1];
        margin.bottom = margins[0];
        margin.left = margins[1];
      } else if (margins.length === 3) {
        margin.top = margins[0];
        margin.right = margins[1];
        margin.bottom = margins[2];
        margin.left = margins[1];
      } else if (margins.length === 4) {
        margin.top = margins[0];
        margin.right = margins[1];
        margin.bottom = margins[2];
        margin.left = margins[3];
      }
      return margin;
    }
    getPaddings(declaration) {
      let paddings = [];
      let padding = {
        top: {},
        right: {},
        left: {},
        bottom: {}
      };
      import_css_tree2.default.walk(declaration, {
        enter: (node) => {
          switch (node.type) {
            case "Dimension":
              paddings.push(node);
              break;
            case "Number":
              paddings.push({ value: node.value, unit: "px" });
              break;
            default:
          }
        }
      });
      if (paddings.length === 1) {
        for (let p in padding) {
          padding[p] = paddings[0];
        }
      } else if (paddings.length === 2) {
        padding.top = paddings[0];
        padding.right = paddings[1];
        padding.bottom = paddings[0];
        padding.left = paddings[1];
      } else if (paddings.length === 3) {
        padding.top = paddings[0];
        padding.right = paddings[1];
        padding.bottom = paddings[2];
        padding.left = paddings[1];
      } else if (paddings.length === 4) {
        padding.top = paddings[0];
        padding.right = paddings[1];
        padding.bottom = paddings[2];
        padding.left = paddings[3];
      }
      return padding;
    }
    // get values for the border on the @page to pass them to the element with the .pagedjs_area class
    getBorders(declaration) {
      let border = {
        top: {},
        right: {},
        left: {},
        bottom: {}
      };
      if (declaration.prop == "border") {
        border.top = import_css_tree2.default.generate(declaration.value);
        border.right = import_css_tree2.default.generate(declaration.value);
        border.bottom = import_css_tree2.default.generate(declaration.value);
        border.left = import_css_tree2.default.generate(declaration.value);
      } else if (declaration.prop == "border-top") {
        border.top = import_css_tree2.default.generate(declaration.value);
      } else if (declaration.prop == "border-right") {
        border.right = import_css_tree2.default.generate(declaration.value);
      } else if (declaration.prop == "border-bottom") {
        border.bottom = import_css_tree2.default.generate(declaration.value);
      } else if (declaration.prop == "border-left") {
        border.left = import_css_tree2.default.generate(declaration.value);
      }
      return border;
    }
    addPageClasses(pages, ast, sheet) {
      if ("*" in pages && pages["*"].added === false) {
        let p = this.createPage(pages["*"], ast.children, sheet);
        sheet.insertRule(p);
        pages["*"].added = true;
      }
      if (":left" in pages && pages[":left"].added === false) {
        let left = this.createPage(pages[":left"], ast.children, sheet);
        sheet.insertRule(left);
        pages[":left"].added = true;
      }
      if (":right" in pages && pages[":right"].added === false) {
        let right = this.createPage(pages[":right"], ast.children, sheet);
        sheet.insertRule(right);
        pages[":right"].added = true;
      }
      if (":first" in pages && pages[":first"].added === false) {
        let first = this.createPage(pages[":first"], ast.children, sheet);
        sheet.insertRule(first);
        pages[":first"].added = true;
      }
      if (":blank" in pages && pages[":blank"].added === false) {
        let blank = this.createPage(pages[":blank"], ast.children, sheet);
        sheet.insertRule(blank);
        pages[":blank"].added = true;
      }
      for (let pg in pages) {
        if (pages[pg].nth && pages[pg].added === false) {
          let nth = this.createPage(pages[pg], ast.children, sheet);
          sheet.insertRule(nth);
          pages[pg].added = true;
        }
      }
      for (let pg in pages) {
        if (pages[pg].name && pages[pg].added === false) {
          let named = this.createPage(pages[pg], ast.children, sheet);
          sheet.insertRule(named);
          pages[pg].added = true;
        }
      }
    }
    createPage(page, ruleList, sheet) {
      let selectors = this.selectorsForPage(page);
      let children = page.block.children.copy();
      let block = {
        type: "Block",
        loc: 0,
        children
      };
      let rule = this.createRule(selectors, block);
      this.addMarginVars(page.margin, children, children.first());
      this.addPaddingVars(page.padding, children, children.first());
      this.addBorderVars(page.border, children, children.first());
      if (page.width) {
        this.addDimensions(page.width, page.height, page.orientation, children, children.first());
      }
      if (page.marginalia) {
        this.addMarginaliaStyles(page, ruleList, rule, sheet);
        this.addMarginaliaContent(page, ruleList, rule, sheet);
      }
      if (page.notes) {
        this.addNotesStyles(page.notes, page, ruleList, rule, sheet);
      }
      return rule;
    }
    addMarginVars(margin, list, item) {
      for (let m in margin) {
        if (typeof margin[m].value !== "undefined") {
          let value = margin[m].value + (margin[m].unit || "");
          let mVar = list.createItem({
            type: "Declaration",
            property: "--pagedjs-margin-" + m,
            value: {
              type: "Raw",
              value
            }
          });
          list.append(mVar, item);
        }
      }
    }
    addPaddingVars(padding, list, item) {
      for (let p in padding) {
        if (typeof padding[p].value !== "undefined") {
          let value = padding[p].value + (padding[p].unit || "");
          let pVar = list.createItem({
            type: "Declaration",
            property: "--pagedjs-padding-" + p,
            value: {
              type: "Raw",
              value
            }
          });
          list.append(pVar, item);
        }
      }
    }
    addBorderVars(border, list, item) {
      for (const name of Object.keys(border)) {
        const value = border[name];
        if (typeof value === "string") {
          const borderItem = list.createItem({
            type: "Declaration",
            property: "--pagedjs-border-" + name,
            value: {
              type: "Raw",
              value
            }
          });
          list.append(borderItem, item);
        }
      }
    }
    addDimensions(width, height, orientation, list, item) {
      let widthString, heightString;
      widthString = CSSValueToString(width);
      heightString = CSSValueToString(height);
      if (orientation && orientation !== "portrait") {
        [widthString, heightString] = [heightString, widthString];
      }
      let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
      list.appendData(wVar);
      let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
      list.appendData(hVar);
    }
    addMarginaliaStyles(page, list, item, sheet) {
      for (let loc in page.marginalia) {
        let block = import_css_tree2.default.clone(page.marginalia[loc]);
        let hasContent2 = false;
        if (block.children.isEmpty()) {
          continue;
        }
        import_css_tree2.default.walk(block, {
          visit: "Declaration",
          enter: (node, item2, list2) => {
            if (node.property === "content") {
              if (node.value.children && node.value.children.first().name === "none") {
                hasContent2 = false;
              } else {
                hasContent2 = true;
              }
              list2.remove(item2);
            }
            if (node.property === "vertical-align") {
              import_css_tree2.default.walk(node, {
                visit: "Identifier",
                enter: (identNode, identItem, identlist) => {
                  let name = identNode.name;
                  if (name === "top") {
                    identNode.name = "flex-start";
                  } else if (name === "middle") {
                    identNode.name = "center";
                  } else if (name === "bottom") {
                    identNode.name = "flex-end";
                  }
                }
              });
              node.property = "align-items";
            }
            if (node.property === "width" && (loc === "top-left" || loc === "top-center" || loc === "top-right" || loc === "bottom-left" || loc === "bottom-center" || loc === "bottom-right")) {
              let c = import_css_tree2.default.clone(node);
              c.property = "max-width";
              list2.appendData(c);
            }
            if (node.property === "height" && (loc === "left-top" || loc === "left-middle" || loc === "left-bottom" || loc === "right-top" || loc === "right-middle" || loc === "right-bottom")) {
              let c = import_css_tree2.default.clone(node);
              c.property = "max-height";
              list2.appendData(c);
            }
          }
        });
        let marginSelectors = this.selectorsForPageMargin(page, loc);
        let marginRule = this.createRule(marginSelectors, block);
        list.appendData(marginRule);
        let sel = import_css_tree2.default.generate({
          type: "Selector",
          children: marginSelectors
        });
        this.marginalia[sel] = {
          page,
          selector: sel,
          block: page.marginalia[loc],
          hasContent: hasContent2
        };
      }
    }
    addMarginaliaContent(page, list, item, sheet) {
      let displayNone;
      for (let loc in page.marginalia) {
        let content = import_css_tree2.default.clone(page.marginalia[loc]);
        import_css_tree2.default.walk(content, {
          visit: "Declaration",
          enter: (node, item2, list2) => {
            if (node.property !== "content") {
              list2.remove(item2);
            }
            if (node.value.children && node.value.children.first().name === "none") {
              displayNone = true;
            }
          }
        });
        if (content.children.isEmpty()) {
          continue;
        }
        let displaySelectors = this.selectorsForPageMargin(page, loc);
        let displayDeclaration;
        displaySelectors.insertData({
          type: "Combinator",
          name: ">"
        });
        displaySelectors.insertData({
          type: "ClassSelector",
          name: "pagedjs_margin-content"
        });
        displaySelectors.insertData({
          type: "Combinator",
          name: ">"
        });
        displaySelectors.insertData({
          type: "TypeSelector",
          name: "*"
        });
        if (displayNone) {
          displayDeclaration = this.createDeclaration("display", "none");
        } else {
          displayDeclaration = this.createDeclaration("display", "block");
        }
        let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
        sheet.insertRule(displayRule);
        let contentSelectors = this.selectorsForPageMargin(page, loc);
        contentSelectors.insertData({
          type: "Combinator",
          name: ">"
        });
        contentSelectors.insertData({
          type: "ClassSelector",
          name: "pagedjs_margin-content"
        });
        contentSelectors.insertData({
          type: "PseudoElementSelector",
          name: "after",
          children: null
        });
        let contentRule = this.createRule(contentSelectors, content);
        sheet.insertRule(contentRule);
      }
    }
    addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
      let rules = [];
      let selectors = new import_css_tree2.default.List();
      selectors.insertData({
        type: "PseudoClassSelector",
        name: "root",
        children: null
      });
      let widthString, heightString;
      let widthStringRight, heightStringRight;
      let widthStringLeft, heightStringLeft;
      if (!bleed) {
        widthString = CSSValueToString(width);
        heightString = CSSValueToString(height);
        widthStringRight = CSSValueToString(width);
        heightStringRight = CSSValueToString(height);
        widthStringLeft = CSSValueToString(width);
        heightStringLeft = CSSValueToString(height);
      } else {
        widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
        heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;
        widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
        heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;
        widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
        heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;
        let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
        let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
        let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
        let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));
        let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
        let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
        let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
        let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));
        let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
        let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
        let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
        let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));
        if (bleedrecto) {
          bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
          bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
          bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
          bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));
          widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
          heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
        }
        if (bleedverso) {
          bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
          bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
          bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
          bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));
          widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
          heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
        }
        let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
        let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));
        rules.push(
          bleedTop,
          bleedRight,
          bleedBottom,
          bleedLeft,
          bleedTopRecto,
          bleedRightRecto,
          bleedBottomRecto,
          bleedLeftRecto,
          bleedTopVerso,
          bleedRightVerso,
          bleedBottomVerso,
          bleedLeftVerso,
          pageWidthVar,
          pageHeightVar
        );
      }
      if (marks) {
        marks.forEach((mark) => {
          let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
          rules.push(markDisplay);
        });
      }
      if (orientation) {
        let oVar = this.createVariable("--pagedjs-orientation", orientation);
        rules.push(oVar);
        if (orientation !== "portrait") {
          [widthString, heightString] = [heightString, widthString];
          [widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
          [widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
        }
      }
      let wVar = this.createVariable("--pagedjs-width", widthString);
      let hVar = this.createVariable("--pagedjs-height", heightString);
      let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
      let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);
      let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
      let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);
      rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);
      let rule = this.createRule(selectors, rules);
      ast.children.appendData(rule);
    }
    addNotesStyles(notes, page, list, item, sheet) {
      for (const note in notes) {
        let selectors = this.selectorsForPage(page);
        selectors.insertData({
          type: "Combinator",
          name: " "
        });
        selectors.insertData({
          type: "ClassSelector",
          name: "pagedjs_" + note + "_content"
        });
        let notesRule = this.createRule(selectors, notes[note]);
        list.appendData(notesRule);
      }
    }
    /*
    @page {
    	size: var(--pagedjs-width) var(--pagedjs-height);
    	margin: 0;
    	padding: 0;
    }
    */
    addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
      let { width, height, orientation, format: format2 } = size;
      let children = new import_css_tree2.default.List();
      let childrenLeft = new import_css_tree2.default.List();
      let childrenRight = new import_css_tree2.default.List();
      let dimensions = new import_css_tree2.default.List();
      let dimensionsLeft = new import_css_tree2.default.List();
      let dimensionsRight = new import_css_tree2.default.List();
      if (bleed) {
        let widthCalculations = new import_css_tree2.default.List();
        let heightCalculations = new import_css_tree2.default.List();
        widthCalculations.appendData({
          type: "Dimension",
          unit: width.unit,
          value: width.value
        });
        widthCalculations.appendData({
          type: "WhiteSpace",
          value: " "
        });
        widthCalculations.appendData({
          type: "Operator",
          value: "+"
        });
        widthCalculations.appendData({
          type: "WhiteSpace",
          value: " "
        });
        widthCalculations.appendData({
          type: "Dimension",
          unit: bleed.left.unit,
          value: bleed.left.value
        });
        widthCalculations.appendData({
          type: "WhiteSpace",
          value: " "
        });
        widthCalculations.appendData({
          type: "Operator",
          value: "+"
        });
        widthCalculations.appendData({
          type: "WhiteSpace",
          value: " "
        });
        widthCalculations.appendData({
          type: "Dimension",
          unit: bleed.right.unit,
          value: bleed.right.value
        });
        heightCalculations.appendData({
          type: "Dimension",
          unit: height.unit,
          value: height.value
        });
        heightCalculations.appendData({
          type: "WhiteSpace",
          value: " "
        });
        heightCalculations.appendData({
          type: "Operator",
          value: "+"
        });
        heightCalculations.appendData({
          type: "WhiteSpace",
          value: " "
        });
        heightCalculations.appendData({
          type: "Dimension",
          unit: bleed.top.unit,
          value: bleed.top.value
        });
        heightCalculations.appendData({
          type: "WhiteSpace",
          value: " "
        });
        heightCalculations.appendData({
          type: "Operator",
          value: "+"
        });
        heightCalculations.appendData({
          type: "WhiteSpace",
          value: " "
        });
        heightCalculations.appendData({
          type: "Dimension",
          unit: bleed.bottom.unit,
          value: bleed.bottom.value
        });
        dimensions.appendData({
          type: "Function",
          name: "calc",
          children: widthCalculations
        });
        dimensions.appendData({
          type: "WhiteSpace",
          value: " "
        });
        dimensions.appendData({
          type: "Function",
          name: "calc",
          children: heightCalculations
        });
      } else if (format2) {
        dimensions.appendData({
          type: "Identifier",
          name: format2
        });
        if (orientation) {
          dimensions.appendData({
            type: "WhiteSpace",
            value: " "
          });
          dimensions.appendData({
            type: "Identifier",
            name: orientation
          });
        }
      } else {
        dimensions.appendData({
          type: "Dimension",
          unit: width.unit,
          value: width.value
        });
        dimensions.appendData({
          type: "WhiteSpace",
          value: " "
        });
        dimensions.appendData({
          type: "Dimension",
          unit: height.unit,
          value: height.value
        });
      }
      children.appendData({
        type: "Declaration",
        property: "size",
        loc: null,
        value: {
          type: "Value",
          children: dimensions
        }
      });
      children.appendData({
        type: "Declaration",
        property: "margin",
        loc: null,
        value: {
          type: "Value",
          children: [{
            type: "Dimension",
            unit: "px",
            value: 0
          }]
        }
      });
      children.appendData({
        type: "Declaration",
        property: "padding",
        loc: null,
        value: {
          type: "Value",
          children: [{
            type: "Dimension",
            unit: "px",
            value: 0
          }]
        }
      });
      children.appendData({
        type: "Declaration",
        property: "padding",
        loc: null,
        value: {
          type: "Value",
          children: [{
            type: "Dimension",
            unit: "px",
            value: 0
          }]
        }
      });
      let rule = ast.children.createItem({
        type: "Atrule",
        prelude: null,
        name: "page",
        block: {
          type: "Block",
          loc: null,
          children
        }
      });
      ast.children.append(rule);
      if (bleedverso) {
        let widthCalculationsLeft = new import_css_tree2.default.List();
        let heightCalculationsLeft = new import_css_tree2.default.List();
        widthCalculationsLeft.appendData({
          type: "Dimension",
          unit: width.unit,
          value: width.value
        });
        widthCalculationsLeft.appendData({
          type: "WhiteSpace",
          value: " "
        });
        widthCalculationsLeft.appendData({
          type: "Operator",
          value: "+"
        });
        widthCalculationsLeft.appendData({
          type: "WhiteSpace",
          value: " "
        });
        widthCalculationsLeft.appendData({
          type: "Dimension",
          unit: bleedverso.left.unit,
          value: bleedverso.left.value
        });
        widthCalculationsLeft.appendData({
          type: "WhiteSpace",
          value: " "
        });
        widthCalculationsLeft.appendData({
          type: "Operator",
          value: "+"
        });
        widthCalculationsLeft.appendData({
          type: "WhiteSpace",
          value: " "
        });
        widthCalculationsLeft.appendData({
          type: "Dimension",
          unit: bleedverso.right.unit,
          value: bleedverso.right.value
        });
        heightCalculationsLeft.appendData({
          type: "Dimension",
          unit: height.unit,
          value: height.value
        });
        heightCalculationsLeft.appendData({
          type: "WhiteSpace",
          value: " "
        });
        heightCalculationsLeft.appendData({
          type: "Operator",
          value: "+"
        });
        heightCalculationsLeft.appendData({
          type: "WhiteSpace",
          value: " "
        });
        heightCalculationsLeft.appendData({
          type: "Dimension",
          unit: bleedverso.top.unit,
          value: bleedverso.top.value
        });
        heightCalculationsLeft.appendData({
          type: "WhiteSpace",
          value: " "
        });
        heightCalculationsLeft.appendData({
          type: "Operator",
          value: "+"
        });
        heightCalculationsLeft.appendData({
          type: "WhiteSpace",
          value: " "
        });
        heightCalculationsLeft.appendData({
          type: "Dimension",
          unit: bleedverso.bottom.unit,
          value: bleedverso.bottom.value
        });
        dimensionsLeft.appendData({
          type: "Function",
          name: "calc",
          children: widthCalculationsLeft
        });
        dimensionsLeft.appendData({
          type: "WhiteSpace",
          value: " "
        });
        dimensionsLeft.appendData({
          type: "Function",
          name: "calc",
          children: heightCalculationsLeft
        });
        childrenLeft.appendData({
          type: "Declaration",
          property: "size",
          loc: null,
          value: {
            type: "Value",
            children: dimensionsLeft
          }
        });
        let ruleLeft = ast.children.createItem({
          type: "Atrule",
          prelude: null,
          name: "page :left",
          block: {
            type: "Block",
            loc: null,
            children: childrenLeft
          }
        });
        ast.children.append(ruleLeft);
      }
      if (bleedrecto) {
        let widthCalculationsRight = new import_css_tree2.default.List();
        let heightCalculationsRight = new import_css_tree2.default.List();
        widthCalculationsRight.appendData({
          type: "Dimension",
          unit: width.unit,
          value: width.value
        });
        widthCalculationsRight.appendData({
          type: "WhiteSpace",
          value: " "
        });
        widthCalculationsRight.appendData({
          type: "Operator",
          value: "+"
        });
        widthCalculationsRight.appendData({
          type: "WhiteSpace",
          value: " "
        });
        widthCalculationsRight.appendData({
          type: "Dimension",
          unit: bleedrecto.left.unit,
          value: bleedrecto.left.value
        });
        widthCalculationsRight.appendData({
          type: "WhiteSpace",
          value: " "
        });
        widthCalculationsRight.appendData({
          type: "Operator",
          value: "+"
        });
        widthCalculationsRight.appendData({
          type: "WhiteSpace",
          value: " "
        });
        widthCalculationsRight.appendData({
          type: "Dimension",
          unit: bleedrecto.right.unit,
          value: bleedrecto.right.value
        });
        heightCalculationsRight.appendData({
          type: "Dimension",
          unit: height.unit,
          value: height.value
        });
        heightCalculationsRight.appendData({
          type: "WhiteSpace",
          value: " "
        });
        heightCalculationsRight.appendData({
          type: "Operator",
          value: "+"
        });
        heightCalculationsRight.appendData({
          type: "WhiteSpace",
          value: " "
        });
        heightCalculationsRight.appendData({
          type: "Dimension",
          unit: bleedrecto.top.unit,
          value: bleedrecto.top.value
        });
        heightCalculationsRight.appendData({
          type: "WhiteSpace",
          value: " "
        });
        heightCalculationsRight.appendData({
          type: "Operator",
          value: "+"
        });
        heightCalculationsRight.appendData({
          type: "WhiteSpace",
          value: " "
        });
        heightCalculationsRight.appendData({
          type: "Dimension",
          unit: bleedrecto.bottom.unit,
          value: bleedrecto.bottom.value
        });
        dimensionsRight.appendData({
          type: "Function",
          name: "calc",
          children: widthCalculationsRight
        });
        dimensionsRight.appendData({
          type: "WhiteSpace",
          value: " "
        });
        dimensionsRight.appendData({
          type: "Function",
          name: "calc",
          children: heightCalculationsRight
        });
        childrenRight.appendData({
          type: "Declaration",
          property: "size",
          loc: null,
          value: {
            type: "Value",
            children: dimensionsRight
          }
        });
        let ruleRight = ast.children.createItem({
          type: "Atrule",
          prelude: null,
          name: "page :right",
          block: {
            type: "Block",
            loc: null,
            children: childrenRight
          }
        });
        ast.children.append(ruleRight);
      }
    }
    getNth(nth) {
      let n = nth.indexOf("n");
      let plus = nth.indexOf("+");
      let splitN = nth.split("n");
      let splitP = nth.split("+");
      let a = null;
      let b = null;
      if (n > -1) {
        a = splitN[0];
        if (plus > -1) {
          b = splitP[1];
        }
      } else {
        b = nth;
      }
      return {
        type: "Nth",
        loc: null,
        selector: null,
        nth: {
          type: "AnPlusB",
          loc: null,
          a,
          b
        }
      };
    }
    addPageAttributes(page, start, pages) {
      let namedPages = [start.dataset.page];
      if (namedPages && namedPages.length) {
        for (const named of namedPages) {
          if (!named) {
            continue;
          }
          page.name = named;
          page.element.classList.add("pagedjs_named_page");
          page.element.classList.add("pagedjs_" + named + "_page");
          if (!start.dataset.splitFrom) {
            page.element.classList.add("pagedjs_" + named + "_first_page");
          }
        }
      }
    }
    getStartElement(content, breakToken) {
      let node = breakToken && breakToken.node;
      if (!content && !breakToken) {
        return;
      }
      if (!node) {
        return content.children[0];
      }
      if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
        return node;
      }
      if (node.nodeType === 1 && node.dataset.page) {
        return node;
      }
      let fragment = rebuildAncestors(node);
      let pages = fragment.querySelectorAll("[data-page]");
      if (pages.length) {
        return pages[pages.length - 1];
      } else {
        return fragment.children[0];
      }
    }
    beforePageLayout(page, contents, breakToken, chunker) {
      let start = this.getStartElement(contents, breakToken);
      if (start) {
        this.addPageAttributes(page, start, chunker.pages);
      }
    }
    finalizePage(fragment, page, breakToken, chunker) {
      for (let m in this.marginalia) {
        let margin = this.marginalia[m];
        let sels = m.split(" ");
        let content;
        if (page.element.matches(sels[0]) && margin.hasContent) {
          content = page.element.querySelector(sels[1]);
          content.classList.add("hasContent");
        }
      }
      ["top", "bottom"].forEach((loc) => {
        let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
        let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
        let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
        let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");
        let centerContent = center.classList.contains("hasContent");
        let leftContent = left.classList.contains("hasContent");
        let rightContent = right.classList.contains("hasContent");
        let centerWidth, leftWidth, rightWidth;
        if (leftContent) {
          leftWidth = window.getComputedStyle(left)["max-width"];
        }
        if (rightContent) {
          rightWidth = window.getComputedStyle(right)["max-width"];
        }
        if (centerContent) {
          centerWidth = window.getComputedStyle(center)["max-width"];
          if (centerWidth === "none" || centerWidth === "auto") {
            if (!leftContent && !rightContent) {
              marginGroup.style["grid-template-columns"] = "0 1fr 0";
            } else if (leftContent) {
              if (!rightContent) {
                if (leftWidth !== "none" && leftWidth !== "auto") {
                  marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
                } else {
                  marginGroup.style["grid-template-columns"] = "auto auto 1fr";
                  left.style["white-space"] = "nowrap";
                  center.style["white-space"] = "nowrap";
                  let leftOuterWidth = left.offsetWidth;
                  let centerOuterWidth = center.offsetWidth;
                  let outerwidths = leftOuterWidth + centerOuterWidth;
                  let newcenterWidth = centerOuterWidth * 100 / outerwidths;
                  marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
                  left.style["white-space"] = "normal";
                  center.style["white-space"] = "normal";
                }
              } else {
                if (leftWidth !== "none" && leftWidth !== "auto") {
                  if (rightWidth !== "none" && rightWidth !== "auto") {
                    marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
                  } else {
                    marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
                  }
                } else {
                  if (rightWidth !== "none" && rightWidth !== "auto") {
                    marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
                  } else {
                    marginGroup.style["grid-template-columns"] = "auto auto 1fr";
                    left.style["white-space"] = "nowrap";
                    center.style["white-space"] = "nowrap";
                    right.style["white-space"] = "nowrap";
                    let leftOuterWidth = left.offsetWidth;
                    let centerOuterWidth = center.offsetWidth;
                    let rightOuterWidth = right.offsetWidth;
                    let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
                    let newcenterWidth = centerOuterWidth * 100 / outerwidths;
                    if (newcenterWidth > 40) {
                      marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
                    } else {
                      marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
                    }
                    left.style["white-space"] = "normal";
                    center.style["white-space"] = "normal";
                    right.style["white-space"] = "normal";
                  }
                }
              }
            } else {
              if (rightWidth !== "none" && rightWidth !== "auto") {
                marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
              } else {
                marginGroup.style["grid-template-columns"] = "auto auto 1fr";
                right.style["white-space"] = "nowrap";
                center.style["white-space"] = "nowrap";
                let rightOuterWidth = right.offsetWidth;
                let centerOuterWidth = center.offsetWidth;
                let outerwidths = rightOuterWidth + centerOuterWidth;
                let newcenterWidth = centerOuterWidth * 100 / outerwidths;
                marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
                right.style["white-space"] = "normal";
                center.style["white-space"] = "normal";
              }
            }
          } else if (centerWidth !== "none" && centerWidth !== "auto") {
            if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
              marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
            } else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
              marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
            } else {
              marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
            }
          }
        } else {
          if (leftContent) {
            if (!rightContent) {
              marginGroup.style["grid-template-columns"] = "1fr 0 0";
            } else {
              if (leftWidth !== "none" && leftWidth !== "auto") {
                if (rightWidth !== "none" && rightWidth !== "auto") {
                  marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
                } else {
                  marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
                }
              } else {
                if (rightWidth !== "none" && rightWidth !== "auto") {
                  marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
                } else {
                  marginGroup.style["grid-template-columns"] = "auto 1fr auto";
                  left.style["white-space"] = "nowrap";
                  right.style["white-space"] = "nowrap";
                  let leftOuterWidth = left.offsetWidth;
                  let rightOuterWidth = right.offsetWidth;
                  let outerwidths = leftOuterWidth + rightOuterWidth;
                  let newLeftWidth = leftOuterWidth * 100 / outerwidths;
                  marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
                  left.style["white-space"] = "normal";
                  right.style["white-space"] = "normal";
                }
              }
            }
          } else {
            if (rightWidth !== "none" && rightWidth !== "auto") {
              marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
            } else {
              marginGroup.style["grid-template-columns"] = "0 0 1fr";
            }
          }
        }
      });
      ["left", "right"].forEach((loc) => {
        let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
        let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
        let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
        let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
        let topContent = top.classList.contains("hasContent");
        let bottomContent = bottom.classList.contains("hasContent");
        let middleHeight, topHeight, bottomHeight;
        if (topContent) {
          topHeight = window.getComputedStyle(top)["max-height"];
        }
        if (bottomContent) {
          bottomHeight = window.getComputedStyle(bottom)["max-height"];
        }
        if (middle) {
          middleHeight = window.getComputedStyle(middle)["max-height"];
          if (middleHeight === "none" || middleHeight === "auto") {
            if (!topContent && !bottomContent) {
              marginGroup.style["grid-template-rows"] = "0 1fr 0";
            } else if (topContent) {
              if (!bottomContent) {
                if (topHeight !== "none" && topHeight !== "auto") {
                  marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
                }
              } else {
                if (topHeight !== "none" && topHeight !== "auto") {
                  if (bottomHeight !== "none" && bottomHeight !== "auto") {
                    marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
                  } else {
                    marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
                  }
                } else {
                  if (bottomHeight !== "none" && bottomHeight !== "auto") {
                    marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
                  }
                }
              }
            } else {
              if (bottomHeight !== "none" && bottomHeight !== "auto") {
                marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
              }
            }
          } else {
            if (topContent && topHeight !== "none" && topHeight !== "auto") {
              marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
            } else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
              marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
            } else {
              marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
            }
          }
        } else {
          if (topContent) {
            if (!bottomContent) {
              marginGroup.style["grid-template-rows"] = "1fr 0 0";
            } else {
              if (topHeight !== "none" && topHeight !== "auto") {
                if (bottomHeight !== "none" && bottomHeight !== "auto") {
                  marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
                } else {
                  marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
                }
              } else {
                if (bottomHeight !== "none" && bottomHeight !== "auto") {
                  marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
                } else {
                  marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
                }
              }
            }
          } else {
            if (bottomHeight !== "none" && bottomHeight !== "auto") {
              marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
            } else {
              marginGroup.style["grid-template-rows"] = "0 0 1fr";
            }
          }
        }
      });
    }
    // CSS Tree Helpers
    selectorsForPage(page) {
      let nthlist;
      let nth;
      let selectors = new import_css_tree2.default.List();
      selectors.insertData({
        type: "ClassSelector",
        name: "pagedjs_page"
      });
      if (page.name) {
        selectors.insertData({
          type: "ClassSelector",
          name: "pagedjs_named_page"
        });
        selectors.insertData({
          type: "ClassSelector",
          name: "pagedjs_" + page.name + "_page"
        });
      }
      if (page.psuedo && !(page.name && page.psuedo === "first")) {
        selectors.insertData({
          type: "ClassSelector",
          name: "pagedjs_" + page.psuedo + "_page"
        });
      }
      if (page.name && page.psuedo === "first") {
        selectors.insertData({
          type: "ClassSelector",
          name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
        });
      }
      if (page.nth) {
        nthlist = new import_css_tree2.default.List();
        nth = this.getNth(page.nth);
        nthlist.insertData(nth);
        selectors.insertData({
          type: "PseudoClassSelector",
          name: "nth-of-type",
          children: nthlist
        });
      }
      return selectors;
    }
    selectorsForPageMargin(page, margin) {
      let selectors = this.selectorsForPage(page);
      selectors.insertData({
        type: "Combinator",
        name: " "
      });
      selectors.insertData({
        type: "ClassSelector",
        name: "pagedjs_margin-" + margin
      });
      return selectors;
    }
    createDeclaration(property, value, important) {
      let children = new import_css_tree2.default.List();
      children.insertData({
        type: "Identifier",
        loc: null,
        name: value
      });
      return {
        type: "Declaration",
        loc: null,
        important,
        property,
        value: {
          type: "Value",
          loc: null,
          children
        }
      };
    }
    createVariable(property, value) {
      return {
        type: "Declaration",
        loc: null,
        property,
        value: {
          type: "Raw",
          value
        }
      };
    }
    createCalculatedDimension(property, items, important, operator = "+") {
      let children = new import_css_tree2.default.List();
      let calculations = new import_css_tree2.default.List();
      items.forEach((item, index) => {
        calculations.appendData({
          type: "Dimension",
          unit: item.unit,
          value: item.value
        });
        calculations.appendData({
          type: "WhiteSpace",
          value: " "
        });
        if (index + 1 < items.length) {
          calculations.appendData({
            type: "Operator",
            value: operator
          });
          calculations.appendData({
            type: "WhiteSpace",
            value: " "
          });
        }
      });
      children.insertData({
        type: "Function",
        loc: null,
        name: "calc",
        children: calculations
      });
      return {
        type: "Declaration",
        loc: null,
        important,
        property,
        value: {
          type: "Value",
          loc: null,
          children
        }
      };
    }
    createDimension(property, cssValue, important) {
      let children = new import_css_tree2.default.List();
      children.insertData({
        type: "Dimension",
        loc: null,
        value: cssValue.value,
        unit: cssValue.unit
      });
      return {
        type: "Declaration",
        loc: null,
        important,
        property,
        value: {
          type: "Value",
          loc: null,
          children
        }
      };
    }
    createBlock(declarations) {
      let block = new import_css_tree2.default.List();
      declarations.forEach((declaration) => {
        block.insertData(declaration);
      });
      return {
        type: "Block",
        loc: null,
        children: block
      };
    }
    createRule(selectors, block) {
      let selectorList = new import_css_tree2.default.List();
      selectorList.insertData({
        type: "Selector",
        children: selectors
      });
      if (Array.isArray(block)) {
        block = this.createBlock(block);
      }
      return {
        type: "Rule",
        prelude: {
          type: "SelectorList",
          children: selectorList
        },
        block
      };
    }
  };
  var atpage_default = AtPage;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/paged-media/breaks.js
  var import_css_tree3 = __toESM(require_lib(), 1);
  var Breaks = class extends handler_default {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.breaks = {};
    }
    onDeclaration(declaration, dItem, dList, rule) {
      let property = declaration.property;
      if (property === "page") {
        let children = declaration.value.children.first();
        let value = children.name;
        let selector = import_css_tree3.default.generate(rule.ruleNode.prelude);
        let name = value;
        let breaker = {
          property,
          value,
          selector,
          name
        };
        selector.split(",").forEach((s) => {
          if (!this.breaks[s]) {
            this.breaks[s] = [breaker];
          } else {
            this.breaks[s].push(breaker);
          }
        });
        dList.remove(dItem);
      }
      if (property === "break-before" || property === "break-after" || property === "page-break-before" || property === "page-break-after") {
        let child2 = declaration.value.children.first();
        let value = child2.name;
        let selector = import_css_tree3.default.generate(rule.ruleNode.prelude);
        if (property === "page-break-before") {
          property = "break-before";
        } else if (property === "page-break-after") {
          property = "break-after";
        }
        let breaker = {
          property,
          value,
          selector
        };
        selector.split(",").forEach((s) => {
          if (!this.breaks[s]) {
            this.breaks[s] = [breaker];
          } else {
            this.breaks[s].push(breaker);
          }
        });
        dList.remove(dItem);
      }
    }
    afterParsed(parsed) {
      this.processBreaks(parsed, this.breaks);
    }
    processBreaks(parsed, breaks) {
      for (let b in breaks) {
        let elements = parsed.querySelectorAll(b);
        for (var i = 0; i < elements.length; i++) {
          for (let prop of breaks[b]) {
            if (prop.property === "break-after") {
              let nodeAfter2 = displayedElementAfter(elements[i], parsed);
              elements[i].setAttribute("data-break-after", prop.value);
              if (nodeAfter2) {
                nodeAfter2.setAttribute("data-previous-break-after", prop.value);
              }
            } else if (prop.property === "break-before") {
              let nodeBefore2 = displayedElementBefore(elements[i], parsed);
              if (nodeBefore2) {
                if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore2)) {
                  continue;
                }
                elements[i].setAttribute("data-break-before", prop.value);
                nodeBefore2.setAttribute("data-next-break-before", prop.value);
              }
            } else if (prop.property === "page") {
              elements[i].setAttribute("data-page", prop.value);
              let nodeAfter2 = displayedElementAfter(elements[i], parsed);
              if (nodeAfter2) {
                nodeAfter2.setAttribute("data-after-page", prop.value);
              }
            } else {
              elements[i].setAttribute("data-" + prop.property, prop.value);
            }
          }
        }
      }
    }
    mergeBreaks(pageBreaks, newBreaks) {
      for (let b in newBreaks) {
        if (b in pageBreaks) {
          pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
        } else {
          pageBreaks[b] = newBreaks[b];
        }
      }
      return pageBreaks;
    }
    addBreakAttributes(pageElement, page) {
      let before = pageElement.querySelector("[data-break-before]");
      let after = pageElement.querySelector("[data-break-after]");
      let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");
      if (before) {
        if (before.dataset.splitFrom) {
          page.splitFrom = before.dataset.splitFrom;
          pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
        } else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
          page.breakBefore = before.dataset.breakBefore;
          pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
        }
      }
      if (after && after.dataset) {
        if (after.dataset.splitTo) {
          page.splitTo = after.dataset.splitTo;
          pageElement.setAttribute("data-split-to", after.dataset.splitTo);
        } else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
          page.breakAfter = after.dataset.breakAfter;
          pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
        }
      }
      if (previousBreakAfter && previousBreakAfter.dataset) {
        if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
          page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
        }
      }
    }
    afterPageLayout(pageElement, page) {
      this.addBreakAttributes(pageElement, page);
    }
  };
  var breaks_default = Breaks;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/paged-media/print-media.js
  var import_css_tree4 = __toESM(require_lib(), 1);
  var PrintMedia = class extends handler_default {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    onAtMedia(node, item, list) {
      let media = this.getMediaName(node);
      let rules;
      if (media.includes("print")) {
        rules = node.block.children;
        list.appendList(rules);
        list.remove(item);
      } else if (!media.includes("all") && !media.includes("pagedjs-ignore")) {
        list.remove(item);
      }
    }
    getMediaName(node) {
      let media = [];
      if (typeof node.prelude === "undefined" || node.prelude.type !== "AtrulePrelude") {
        return;
      }
      import_css_tree4.default.walk(node.prelude, {
        visit: "Identifier",
        enter: (identNode, iItem, iList) => {
          media.push(identNode.name);
        }
      });
      return media;
    }
  };
  var print_media_default = PrintMedia;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/paged-media/splits.js
  var Splits = class extends handler_default {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    afterPageLayout(pageElement, page, breakToken, chunker) {
      let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
      let pages = pageElement.parentNode;
      let index = Array.prototype.indexOf.call(pages.children, pageElement);
      let prevPage;
      if (index === 0) {
        return;
      }
      prevPage = pages.children[index - 1];
      let from;
      splits.forEach((split) => {
        let ref = split.dataset.ref;
        from = prevPage.querySelector("[data-ref='" + ref + "']:not([data-split-to])");
        if (from) {
          from.dataset.splitTo = ref;
          if (!from.dataset.splitFrom) {
            from.dataset.splitOriginal = true;
          }
        }
      });
      if (from) {
        this.handleAlignment(from);
      }
    }
    handleAlignment(node) {
      let styles = window.getComputedStyle(node);
      let align = styles["text-align"];
      let alignLast = styles["text-align-last"];
      node.dataset.lastSplitElement = "true";
      if (align === "justify" && alignLast === "auto") {
        node.dataset.alignLastSplitElement = "justify";
      } else {
        node.dataset.alignLastSplitElement = alignLast;
      }
    }
  };
  var splits_default = Splits;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/paged-media/counters.js
  var import_css_tree5 = __toESM(require_lib(), 1);
  var Counters = class extends handler_default {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.styleSheet = polisher.styleSheet;
      this.counters = {};
      this.resetCountersMap = /* @__PURE__ */ new Map();
    }
    onDeclaration(declaration, dItem, dList, rule) {
      let property = declaration.property;
      if (property === "counter-increment") {
        this.handleIncrement(declaration, rule);
        let hasProperities = false;
        declaration.value.children.forEach((data) => {
          if (data.type && data.type !== "WhiteSpace") {
            hasProperities = true;
          }
        });
        if (!hasProperities) {
          dList.remove(dItem);
        }
      } else if (property === "counter-reset") {
        this.handleReset(declaration, rule);
        let hasProperities = false;
        declaration.value.children.forEach((data) => {
          if (data.type && data.type !== "WhiteSpace") {
            hasProperities = true;
          }
        });
        if (!hasProperities) {
          dList.remove(dItem);
        }
      }
    }
    afterParsed(parsed) {
      this.processCounters(parsed, this.counters);
      this.scopeCounters(this.counters);
    }
    addCounter(name) {
      if (name in this.counters) {
        return this.counters[name];
      }
      this.counters[name] = {
        name,
        increments: {},
        resets: {}
      };
      return this.counters[name];
    }
    handleIncrement(declaration, rule) {
      let increments = [];
      let children = declaration.value.children;
      children.forEach((data, item) => {
        if (data.type && data.type === "Identifier") {
          let name = data.name;
          if (name === "page" || name.indexOf("target-counter-") === 0) {
            return;
          }
          let whitespace, number, value;
          if (item.next && item.next.data.type === "WhiteSpace") {
            whitespace = item.next;
          }
          if (whitespace && whitespace.next && whitespace.next.data.type === "Number") {
            number = whitespace.next;
            value = parseInt(number.data.value);
          }
          let selector = import_css_tree5.default.generate(rule.ruleNode.prelude);
          let counter;
          if (!(name in this.counters)) {
            counter = this.addCounter(name);
          } else {
            counter = this.counters[name];
          }
          let increment = {
            selector,
            number: value || 1
          };
          counter.increments[selector] = increment;
          increments.push(increment);
          children.remove(item);
          if (whitespace) {
            children.remove(whitespace);
          }
          if (number) {
            children.remove(number);
          }
        }
      });
      return increments;
    }
    handleReset(declaration, rule) {
      let children = declaration.value.children;
      children.forEach((data, item) => {
        if (data.type && data.type === "Identifier") {
          let name = data.name;
          let whitespace, number, value;
          if (item.next && item.next.data.type === "WhiteSpace") {
            whitespace = item.next;
          }
          if (whitespace && whitespace.next) {
            if (whitespace.next.data.type === "Number") {
              number = whitespace.next;
              value = parseInt(number.data.value);
            } else if (whitespace.next.data.type === "Function" && whitespace.next.data.name === "var") {
              number = whitespace.next;
              value = whitespace.next.data.children.head.data.name;
            }
          }
          let counter;
          let selector;
          let prelude = rule.ruleNode.prelude;
          if (rule.ruleNode.type === "Atrule" && rule.ruleNode.name === "page") {
            selector = ".pagedjs_page";
          } else {
            selector = import_css_tree5.default.generate(prelude || rule.ruleNode);
          }
          if (name === "footnote") {
            this.addFootnoteMarkerCounter(declaration.value.children);
          }
          if (!(name in this.counters)) {
            counter = this.addCounter(name);
          } else {
            counter = this.counters[name];
          }
          let reset = {
            selector,
            number: value || 0
          };
          counter.resets[selector] = reset;
          if (selector !== ".pagedjs_page") {
            children.remove(item);
            if (whitespace) {
              children.remove(whitespace);
            }
            if (number) {
              children.remove(number);
            }
          }
        }
      });
    }
    processCounters(parsed, counters) {
      let counter;
      for (let c in counters) {
        counter = this.counters[c];
        this.processCounterIncrements(parsed, counter);
        this.processCounterResets(parsed, counter);
        if (c !== "page") {
          this.addCounterValues(parsed, counter);
        }
      }
    }
    scopeCounters(counters) {
      let countersArray = [];
      for (let c in counters) {
        if (c !== "page") {
          countersArray.push(`${counters[c].name} 0`);
        }
      }
      this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count) footnote var(--pagedjs-footnotes-count) footnote-marker var(--pagedjs-footnotes-count)}`);
    }
    insertRule(rule) {
      this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
    }
    processCounterIncrements(parsed, counter) {
      let increment;
      for (let inc in counter.increments) {
        increment = counter.increments[inc];
        let incrementElements = parsed.querySelectorAll(increment.selector);
        for (let i = 0; i < incrementElements.length; i++) {
          incrementElements[i].setAttribute("data-counter-" + counter.name + "-increment", increment.number);
          if (incrementElements[i].getAttribute("data-counter-increment")) {
            incrementElements[i].setAttribute("data-counter-increment", incrementElements[i].getAttribute("data-counter-increment") + " " + counter.name);
          } else {
            incrementElements[i].setAttribute("data-counter-increment", counter.name);
          }
        }
      }
    }
    processCounterResets(parsed, counter) {
      let reset;
      for (let r in counter.resets) {
        reset = counter.resets[r];
        let resetElements = parsed.querySelectorAll(reset.selector);
        for (var i = 0; i < resetElements.length; i++) {
          let value = reset.number;
          if (typeof value === "string" && value.startsWith("--")) {
            value = resetElements[i].style.getPropertyValue(value) || 0;
          }
          resetElements[i].setAttribute("data-counter-" + counter.name + "-reset", value);
          if (resetElements[i].getAttribute("data-counter-reset")) {
            resetElements[i].setAttribute("data-counter-reset", resetElements[i].getAttribute("data-counter-reset") + " " + counter.name);
          } else {
            resetElements[i].setAttribute("data-counter-reset", counter.name);
          }
        }
      }
    }
    addCounterValues(parsed, counter) {
      let counterName = counter.name;
      if (counterName === "page" || counterName === "footnote") {
        return;
      }
      let elements = parsed.querySelectorAll("[data-counter-" + counterName + "-reset], [data-counter-" + counterName + "-increment]");
      let count = 0;
      let element2;
      let increment, reset;
      let resetValue, incrementValue, resetDelta;
      let incrementArray;
      for (let i = 0; i < elements.length; i++) {
        element2 = elements[i];
        resetDelta = 0;
        incrementArray = [];
        if (element2.hasAttribute("data-counter-" + counterName + "-reset")) {
          reset = element2.getAttribute("data-counter-" + counterName + "-reset");
          resetValue = parseInt(reset);
          resetDelta = resetValue - count;
          incrementArray.push(`${counterName} ${resetDelta}`);
          count = resetValue;
        }
        if (element2.hasAttribute("data-counter-" + counterName + "-increment")) {
          increment = element2.getAttribute("data-counter-" + counterName + "-increment");
          incrementValue = parseInt(increment);
          count += incrementValue;
          element2.setAttribute("data-counter-" + counterName + "-value", count);
          incrementArray.push(`${counterName} ${incrementValue}`);
        }
        if (incrementArray.length > 0) {
          this.incrementCounterForElement(element2, incrementArray);
        }
      }
    }
    addFootnoteMarkerCounter(list) {
      let markers = [];
      import_css_tree5.default.walk(list, {
        visit: "Identifier",
        enter: (identNode, iItem, iList) => {
          markers.push(identNode.name);
        }
      });
      if (markers.includes("footnote-maker")) {
        return;
      }
      list.insertData({
        type: "WhiteSpace",
        value: " "
      });
      list.insertData({
        type: "Identifier",
        name: "footnote-marker"
      });
      list.insertData({
        type: "WhiteSpace",
        value: " "
      });
      list.insertData({
        type: "Number",
        value: 0
      });
    }
    incrementCounterForElement(element2, incrementArray) {
      if (!element2 || !incrementArray || incrementArray.length === 0)
        return;
      const ref = element2.dataset.ref;
      const increments = Array.from(this.styleSheet.cssRules).filter((rule) => {
        return rule.selectorText === `[data-ref="${element2.dataset.ref}"]:not([data-split-from])` && rule.style[0] === "counter-increment";
      }).map((rule) => rule.style.counterIncrement);
      increments.push(this.mergeIncrements(
        incrementArray,
        (prev, next) => (parseInt(prev) || 0) + (parseInt(next) || 0)
      ));
      const counterIncrement = this.mergeIncrements(increments, (prev, next) => next);
      this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${counterIncrement} }`);
    }
    /**
     * Merge multiple values of a counter-increment CSS rule, using the specified operator.
     *
     * @param {Array} incrementArray the values to merge, e.g. ['c1 1', 'c1 -7 c2 1']
     * @param {Function} operator the function used to merge counter values (e.g. keep the last value of a counter or sum
     *					the counter values)
     * @return {string} the merged value of the counter-increment CSS rule
     */
    mergeIncrements(incrementArray, operator) {
      const increments = {};
      incrementArray.forEach((increment) => {
        let values = increment.split(" ");
        for (let i = 0; i < values.length; i += 2) {
          increments[values[i]] = operator(increments[values[i]], values[i + 1]);
        }
      });
      return Object.entries(increments).map(([key, value]) => `${key} ${value}`).join(" ");
    }
    afterPageLayout(pageElement, page) {
      let resets = [];
      let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]:not([data-split-from])");
      pgreset.forEach((reset) => {
        const ref = reset.dataset && reset.dataset.ref;
        if (ref && this.resetCountersMap.has(ref)) {
        } else {
          if (ref) {
            this.resetCountersMap.set(ref, "");
          }
          let value = reset.dataset.counterPageReset;
          resets.push(`page ${value}`);
        }
      });
      let notereset = pageElement.querySelectorAll("[data-counter-footnote-reset]:not([data-split-from])");
      notereset.forEach((reset) => {
        let value = reset.dataset.counterFootnoteReset;
        resets.push(`footnote ${value}`);
        resets.push(`footnote-marker ${value}`);
      });
      if (resets.length) {
        this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: ${resets.join(" ")} }`, this.styleSheet.cssRules.length);
      }
    }
  };
  var counters_default = Counters;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/paged-media/lists.js
  var Lists = class extends handler_default {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    afterParsed(content) {
      const orderedLists = content.querySelectorAll("ol");
      for (var list of orderedLists) {
        this.addDataNumbers(list);
      }
    }
    afterPageLayout(pageElement, page, breakToken, chunker) {
      var orderedLists = pageElement.getElementsByTagName("ol");
      for (var list of orderedLists) {
        if (list.firstElementChild) {
          list.start = list.firstElementChild.dataset.itemNum;
        }
      }
    }
    addDataNumbers(list) {
      let start = 1;
      if (list.hasAttribute("start")) {
        start = parseInt(list.getAttribute("start"), 10);
        if (isNaN(start)) {
          start = 1;
        }
      }
      let items = list.children;
      for (var i = 0; i < items.length; i++) {
        items[i].setAttribute("data-item-num", i + start);
      }
    }
  };
  var lists_default = Lists;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/paged-media/position-fixed.js
  var import_css_tree6 = __toESM(require_lib(), 1);
  var PositionFixed = class extends handler_default {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.styleSheet = polisher.styleSheet;
      this.fixedElementsSelector = [];
      this.fixedElements = [];
    }
    onDeclaration(declaration, dItem, dList, rule) {
      if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
        let selector = import_css_tree6.default.generate(rule.ruleNode.prelude);
        this.fixedElementsSelector.push(selector);
        dList.remove(dItem);
      }
    }
    afterParsed(fragment) {
      this.fixedElementsSelector.forEach((fixedEl) => {
        fragment.querySelectorAll(`${fixedEl}`).forEach((el) => {
          el.style.setProperty("position", "absolute");
          this.fixedElements.push(el);
          el.remove();
        });
      });
    }
    afterPageLayout(pageElement, page, breakToken) {
      this.fixedElements.forEach((el) => {
        const clone = el.cloneNode(true);
        pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
      });
    }
  };
  var position_fixed_default = PositionFixed;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/paged-media/page-counter-increment.js
  var import_css_tree7 = __toESM(require_lib(), 1);
  var PageCounterIncrement = class extends handler_default {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.styleSheet = polisher.styleSheet;
      this.pageCounter = {
        name: "page",
        increments: {},
        resets: {}
      };
    }
    onDeclaration(declaration, dItem, dList, rule) {
      const property = declaration.property;
      if (property === "counter-increment") {
        let inc = this.handleIncrement(declaration, rule);
        if (inc) {
          dList.remove(dItem);
        }
      }
    }
    afterParsed(_) {
      for (const inc in this.pageCounter.increments) {
        const increment = this.pageCounter.increments[inc];
        this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
      }
    }
    handleIncrement(declaration, rule) {
      const identifier = declaration.value.children.first();
      const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
      const name = identifier && identifier.name;
      if (name && name.indexOf("target-counter-") === 0) {
        return;
      }
      if (name !== "page") {
        return;
      }
      if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
        return;
      }
      const selector = import_css_tree7.default.generate(rule.ruleNode.prelude);
      return this.pageCounter.increments[selector] = {
        selector,
        number
      };
    }
    insertRule(rule) {
      this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
    }
  };
  var page_counter_increment_default = PageCounterIncrement;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/paged-media/nth-of-type.js
  var import_css_tree8 = __toESM(require_lib(), 1);
  var NthOfType = class extends handler_default {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.styleSheet = polisher.styleSheet;
      this.selectors = {};
    }
    onRule(ruleNode, ruleItem, rulelist) {
      let selector = import_css_tree8.default.generate(ruleNode.prelude);
      if (selector.match(/:(first|last|nth)-of-type/)) {
        let declarations = import_css_tree8.default.generate(ruleNode.block);
        declarations = declarations.replace(/[{}]/g, "");
        let uuid = "nth-of-type-" + UUID();
        selector.split(",").forEach((s) => {
          if (!this.selectors[s]) {
            this.selectors[s] = [uuid, declarations];
          } else {
            this.selectors[s][1] = `${this.selectors[s][1]};${declarations}`;
          }
        });
        rulelist.remove(ruleItem);
      }
    }
    afterParsed(parsed) {
      this.processSelectors(parsed, this.selectors);
    }
    processSelectors(parsed, selectors) {
      for (let s in selectors) {
        let elements = parsed.querySelectorAll(s);
        for (var i = 0; i < elements.length; i++) {
          let dataNthOfType = elements[i].getAttribute("data-nth-of-type");
          if (dataNthOfType && dataNthOfType != "") {
            dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
            elements[i].setAttribute("data-nth-of-type", dataNthOfType);
          } else {
            elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
          }
        }
        let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
        this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
      }
    }
  };
  var nth_of_type_default = NthOfType;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/paged-media/following.js
  var import_css_tree9 = __toESM(require_lib(), 1);
  var Following = class extends handler_default {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.styleSheet = polisher.styleSheet;
      this.selectors = {};
    }
    onRule(ruleNode, ruleItem, rulelist) {
      let selector = import_css_tree9.default.generate(ruleNode.prelude);
      if (selector.match(/\+/)) {
        let declarations = import_css_tree9.default.generate(ruleNode.block);
        declarations = declarations.replace(/[{}]/g, "");
        let uuid = "following-" + UUID();
        selector.split(",").forEach((s) => {
          if (!this.selectors[s]) {
            this.selectors[s] = [uuid, declarations];
          } else {
            this.selectors[s][1] = `${this.selectors[s][1]};${declarations}`;
          }
        });
        rulelist.remove(ruleItem);
      }
    }
    afterParsed(parsed) {
      this.processSelectors(parsed, this.selectors);
    }
    processSelectors(parsed, selectors) {
      for (let s in selectors) {
        let elements = parsed.querySelectorAll(s);
        for (var i = 0; i < elements.length; i++) {
          let dataFollowing = elements[i].getAttribute("data-following");
          if (dataFollowing && dataFollowing != "") {
            dataFollowing = `${dataFollowing},${selectors[s][0]}`;
            elements[i].setAttribute("data-following", dataFollowing);
          } else {
            elements[i].setAttribute("data-following", selectors[s][0]);
          }
        }
        let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
        this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
      }
    }
  };
  var following_default = Following;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/paged-media/footnotes.js
  var import_css_tree10 = __toESM(require_lib(), 1);
  var Footnotes = class extends handler_default {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.footnotes = {};
      this.needsLayout = [];
    }
    onDeclaration(declaration, dItem, dList, rule) {
      let property = declaration.property;
      if (property === "float") {
        let identifier = declaration.value.children && declaration.value.children.first();
        let location = identifier && identifier.name;
        if (location === "footnote") {
          let selector = import_css_tree10.default.generate(rule.ruleNode.prelude);
          this.footnotes[selector] = {
            selector,
            policy: "auto",
            display: "block"
          };
          dList.remove(dItem);
        }
      }
      if (property === "footnote-policy") {
        let identifier = declaration.value.children && declaration.value.children.first();
        let policy = identifier && identifier.name;
        if (policy) {
          let selector = import_css_tree10.default.generate(rule.ruleNode.prelude);
          let note = this.footnotes[selector];
          if (note) {
            note.policy = policy;
          }
        }
      }
      if (property === "footnote-display") {
        let identifier = declaration.value.children && declaration.value.children.first();
        let display = identifier && identifier.name;
        let selector = import_css_tree10.default.generate(rule.ruleNode.prelude);
        if (display && this.footnotes[selector]) {
          let note = this.footnotes[selector];
          if (note) {
            note.display = display;
          }
        }
      }
    }
    onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
      let name = pseudoNode.name;
      if (name === "footnote-marker") {
        let prelude = rule.ruleNode.prelude;
        let newPrelude = new import_css_tree10.default.List();
        prelude.children.first().children.each((node) => {
          if (node.type !== "PseudoElementSelector") {
            newPrelude.appendData(node);
          }
        });
        newPrelude.appendData({
          type: "AttributeSelector",
          name: {
            type: "Identifier",
            name: "data-footnote-marker"
          },
          flags: null,
          loc: null,
          matcher: null,
          value: null
        });
        newPrelude.appendData({
          type: "PseudoElementSelector",
          name: "marker",
          loc: null,
          children: null
        });
        prelude.children.first().children = newPrelude;
      }
      if (name === "footnote-call") {
        let prelude = rule.ruleNode.prelude;
        let newPrelude = new import_css_tree10.default.List();
        prelude.children.first().children.each((node) => {
          if (node.type !== "PseudoElementSelector") {
            newPrelude.appendData(node);
          }
        });
        newPrelude.appendData({
          type: "AttributeSelector",
          name: {
            type: "Identifier",
            name: "data-footnote-call"
          },
          flags: null,
          loc: null,
          matcher: null,
          value: null
        });
        newPrelude.appendData({
          type: "PseudoElementSelector",
          name: "after",
          loc: null,
          children: null
        });
        prelude.children.first().children = newPrelude;
      }
    }
    afterParsed(parsed) {
      this.processFootnotes(parsed, this.footnotes);
    }
    processFootnotes(parsed, notes) {
      for (let n in notes) {
        let elements = parsed.querySelectorAll(n);
        let element2;
        let note = notes[n];
        for (var i = 0; i < elements.length; i++) {
          element2 = elements[i];
          element2.setAttribute("data-note", "footnote");
          element2.setAttribute("data-break-before", "avoid");
          element2.setAttribute("data-note-policy", note.policy || "auto");
          element2.setAttribute("data-note-display", note.display || "block");
          this.processFootnoteContainer(element2);
        }
      }
    }
    processFootnoteContainer(node) {
      let element2 = node.parentElement;
      let prevElement = element2;
      while (element2) {
        if (isContainer(element2)) {
          prevElement.setAttribute("data-has-notes", "true");
          break;
        }
        prevElement = element2;
        element2 = element2.parentElement;
        if (!element2) {
          prevElement.setAttribute("data-has-notes", "true");
        }
      }
    }
    renderNode(node) {
      if (node.nodeType == 1) {
        let notes;
        if (!node.dataset) {
          return;
        }
        if (node.dataset.note === "footnote") {
          notes = [node];
        } else if (node.dataset.hasNotes || node.querySelectorAll("[data-note='footnote']")) {
          notes = node.querySelectorAll("[data-note='footnote']");
        }
        if (notes && notes.length) {
          this.findVisibleFootnotes(notes, node);
        }
      }
    }
    findVisibleFootnotes(notes, node) {
      let area, size, right;
      area = node.closest(".pagedjs_page_content");
      size = area.getBoundingClientRect();
      right = size.left + size.width;
      for (let i = 0; i < notes.length; ++i) {
        let currentNote = notes[i];
        let bounds = currentNote.getBoundingClientRect();
        let left = bounds.left;
        if (left < right) {
          this.moveFootnote(currentNote, node.closest(".pagedjs_area"), true);
        }
      }
    }
    moveFootnote(node, pageArea, needsNoteCall) {
      let noteArea = pageArea.querySelector(".pagedjs_footnote_area");
      let noteContent = noteArea.querySelector(".pagedjs_footnote_content");
      let noteInnerContent = noteContent.querySelector(".pagedjs_footnote_inner_content");
      if (!isElement(node)) {
        return;
      }
      let noteCall;
      if (needsNoteCall) {
        noteCall = this.createFootnoteCall(node);
      }
      node.removeAttribute("data-break-before");
      let existing = noteInnerContent.querySelector(`[data-ref="${node.dataset.ref}"]`);
      if (existing) {
        node.remove();
        return;
      }
      noteInnerContent.appendChild(node);
      if (noteContent.classList.contains("pagedjs_footnote_empty")) {
        noteContent.classList.remove("pagedjs_footnote_empty");
      }
      node.dataset.footnoteMarker = node.dataset.ref;
      node.id = `note-${node.dataset.ref}`;
      let height = noteContent.scrollHeight;
      let area = pageArea.querySelector(".pagedjs_page_content");
      let size = area.getBoundingClientRect();
      let right = size.left + size.width;
      let noteCallBounds = noteCall && noteCall.getBoundingClientRect();
      let noteAreaBounds = noteArea.getBoundingClientRect();
      let noteContentMargins = this.marginsHeight(noteContent);
      let noteContentPadding = this.paddingHeight(noteContent);
      let noteContentBorders = this.borderHeight(noteContent);
      let total = noteContentMargins + noteContentPadding + noteContentBorders;
      let notAreaTop = Math.floor(noteAreaBounds.top);
      if (noteAreaBounds.height === 0) {
        notAreaTop -= this.marginsHeight(noteContent, false);
        notAreaTop -= this.paddingHeight(noteContent, false);
        notAreaTop -= this.borderHeight(noteContent, false);
      }
      let notePolicy = node.dataset.notePolicy;
      let noteCallPosition = 0;
      let noteCallOffset = 0;
      if (noteCall) {
        let prevSibling = noteCall.previousSibling;
        let range = new Range();
        if (prevSibling) {
          range.setStartBefore(prevSibling);
        } else {
          range.setStartBefore(noteCall);
        }
        range.setEndAfter(noteCall);
        let rangeBounds = range.getBoundingClientRect();
        noteCallPosition = rangeBounds.bottom;
        if (!notePolicy || notePolicy === "auto") {
          noteCallOffset = Math.ceil(rangeBounds.bottom);
        } else if (notePolicy === "line") {
          noteCallOffset = Math.ceil(rangeBounds.top);
        } else if (notePolicy === "block") {
          let parentParagraph = noteCall.closest("p").previousElementSibling;
          if (parentParagraph) {
            noteCallOffset = Math.ceil(
              parentParagraph.getBoundingClientRect().bottom
            );
          } else {
            noteCallOffset = Math.ceil(rangeBounds.bottom);
          }
        }
      }
      let contentDelta = height + total - noteAreaBounds.height;
      let noteDelta = noteCallPosition ? notAreaTop - noteCallPosition : 0;
      let notePolicyDelta = noteCallPosition ? Math.floor(noteAreaBounds.top) - noteCallOffset : 0;
      let hasNotes = noteArea.querySelector("[data-note='footnote']");
      if (needsNoteCall && noteCallBounds.left > right) {
        node.remove();
      } else if (!hasNotes && needsNoteCall && total > noteDelta) {
        pageArea.style.setProperty("--pagedjs-footnotes-height", "0px");
        let wrapperDiv = document.createElement("div");
        wrapperDiv.appendChild(node);
        this.needsLayout.push(wrapperDiv);
      } else if (!needsNoteCall) {
        pageArea.style.setProperty(
          "--pagedjs-footnotes-height",
          `${height + total}px`
        );
      } else if (noteCallPosition < noteAreaBounds.top - contentDelta) {
        pageArea.style.setProperty(
          "--pagedjs-footnotes-height",
          `${height + noteContentMargins + noteContentBorders}px`
        );
      } else {
        pageArea.style.setProperty(
          "--pagedjs-footnotes-height",
          `${noteAreaBounds.height + notePolicyDelta}px`
        );
        noteInnerContent.style.height = noteAreaBounds.height + notePolicyDelta - total + "px";
      }
    }
    createFootnoteCall(node) {
      let parentElement = node.parentElement;
      let footnoteCall = document.createElement("a");
      for (const className of node.classList) {
        footnoteCall.classList.add(`${className}`);
      }
      footnoteCall.dataset.footnoteCall = node.dataset.ref;
      footnoteCall.dataset.ref = node.dataset.ref;
      footnoteCall.dataset.dataCounterFootnoteIncrement = 1;
      footnoteCall.href = `#note-${node.dataset.ref}`;
      parentElement.insertBefore(footnoteCall, node);
      return footnoteCall;
    }
    afterPageLayout(pageElement, page, breakToken, chunker) {
      let pageArea = pageElement.querySelector(".pagedjs_area");
      let noteArea = page.footnotesArea;
      let noteContent = noteArea.querySelector(".pagedjs_footnote_content");
      let noteInnerContent = noteArea.querySelector(".pagedjs_footnote_inner_content");
      let noteContentBounds = noteContent.getBoundingClientRect();
      let { width } = noteContentBounds;
      noteInnerContent.style.columnWidth = Math.round(width) + "px";
      noteInnerContent.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
      let layout = new layout_default(noteArea, void 0, chunker.settings);
      let overflow = layout.findOverflow(noteInnerContent, noteContentBounds);
      if (overflow) {
        let { startContainer, startOffset } = overflow;
        let startIsNode;
        if (isElement(startContainer)) {
          let start = startContainer.childNodes[startOffset];
          startIsNode = isElement(start) && start.hasAttribute("data-footnote-marker");
        }
        let extracted = overflow.extractContents();
        if (!startIsNode) {
          let splitChild = extracted.firstElementChild;
          splitChild.dataset.splitFrom = splitChild.dataset.ref;
          this.handleAlignment(noteInnerContent.lastElementChild);
        }
        this.needsLayout.push(extracted);
        noteContent.style.removeProperty("height");
        noteInnerContent.style.removeProperty("height");
        let noteInnerContentBounds = noteInnerContent.getBoundingClientRect();
        let { height } = noteInnerContentBounds;
        let noteContentMargins = this.marginsHeight(noteContent);
        let noteContentPadding = this.paddingHeight(noteContent);
        let noteContentBorders = this.borderHeight(noteContent);
        pageArea.style.setProperty(
          "--pagedjs-footnotes-height",
          `${height + noteContentMargins + noteContentBorders + noteContentPadding}px`
        );
        if (noteInnerContent.childNodes.length === 0) {
          noteContent.classList.add("pagedjs_footnote_empty");
        }
        if (!breakToken) {
          chunker.clonePage(page);
        } else {
          let breakBefore, previousBreakAfter;
          if (breakToken.node && typeof breakToken.node.dataset !== "undefined" && typeof breakToken.node.dataset.previousBreakAfter !== "undefined") {
            previousBreakAfter = breakToken.node.dataset.previousBreakAfter;
          }
          if (breakToken.node && typeof breakToken.node.dataset !== "undefined" && typeof breakToken.node.dataset.breakBefore !== "undefined") {
            breakBefore = breakToken.node.dataset.breakBefore;
          }
          if (breakBefore || previousBreakAfter) {
            chunker.clonePage(page);
          }
        }
      }
      noteInnerContent.style.height = "auto";
    }
    handleAlignment(node) {
      let styles = window.getComputedStyle(node);
      let alignLast = styles["text-align-last"];
      node.dataset.lastSplitElement = "true";
      if (alignLast === "auto") {
        node.dataset.alignLastSplitElement = "justify";
      } else {
        node.dataset.alignLastSplitElement = alignLast;
      }
    }
    beforePageLayout(page) {
      while (this.needsLayout.length) {
        let fragment = this.needsLayout.shift();
        Array.from(fragment.childNodes).forEach((node) => {
          this.moveFootnote(
            node,
            page.element.querySelector(".pagedjs_area"),
            false
          );
        });
      }
    }
    afterOverflowRemoved(removed, rendered) {
      let area = rendered.closest(".pagedjs_area");
      let notes = area.querySelectorAll(".pagedjs_footnote_area [data-note='footnote']");
      for (let n = 0; n < notes.length; n++) {
        const note = notes[n];
        let call = removed.querySelector(`[data-footnote-call="${note.dataset.ref}"]`);
        if (call) {
          note.remove();
        }
      }
      let noteInnerContent = area.querySelector(".pagedjs_footnote_inner_content");
      if (noteInnerContent && noteInnerContent.childNodes.length === 0) {
        noteInnerContent.parentElement.classList.add("pagedjs_footnote_empty");
      }
    }
    marginsHeight(element2, total = true) {
      let styles = window.getComputedStyle(element2);
      let marginTop = parseInt(styles.marginTop);
      let marginBottom = parseInt(styles.marginBottom);
      let margin = 0;
      if (marginTop) {
        margin += marginTop;
      }
      if (marginBottom && total) {
        margin += marginBottom;
      }
      return margin;
    }
    paddingHeight(element2, total = true) {
      let styles = window.getComputedStyle(element2);
      let paddingTop = parseInt(styles.paddingTop);
      let paddingBottom = parseInt(styles.paddingBottom);
      let padding = 0;
      if (paddingTop) {
        padding += paddingTop;
      }
      if (paddingBottom && total) {
        padding += paddingBottom;
      }
      return padding;
    }
    borderHeight(element2, total = true) {
      let styles = window.getComputedStyle(element2);
      let borderTop = parseInt(styles.borderTop);
      let borderBottom = parseInt(styles.borderBottom);
      let borders = 0;
      if (borderTop) {
        borders += borderTop;
      }
      if (borderBottom && total) {
        borders += borderBottom;
      }
      return borders;
    }
  };
  var footnotes_default = Footnotes;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/paged-media/index.js
  var paged_media_default = [
    print_media_default,
    atpage_default,
    breaks_default,
    splits_default,
    counters_default,
    lists_default,
    position_fixed_default,
    page_counter_increment_default,
    nth_of_type_default,
    following_default,
    footnotes_default
  ];

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/generated-content/running-headers.js
  var import_css_tree11 = __toESM(require_lib(), 1);
  var RunningHeaders = class extends handler_default {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.runningSelectors = {};
      this.elements = {};
    }
    onDeclaration(declaration, dItem, dList, rule) {
      if (declaration.property === "position") {
        let selector = import_css_tree11.default.generate(rule.ruleNode.prelude);
        let identifier = declaration.value.children.first().name;
        if (identifier === "running") {
          let value;
          import_css_tree11.default.walk(declaration, {
            visit: "Function",
            enter: (node, item, list) => {
              value = node.children.first().name;
            }
          });
          this.runningSelectors[value] = {
            identifier,
            value,
            selector
          };
        }
      }
      if (declaration.property === "content") {
        import_css_tree11.default.walk(declaration, {
          visit: "Function",
          enter: (funcNode, fItem, fList) => {
            if (funcNode.name.indexOf("element") > -1) {
              let selector = import_css_tree11.default.generate(rule.ruleNode.prelude);
              let func = funcNode.name;
              let value = funcNode.children.first().name;
              let args = [value];
              let style = "first";
              selector.split(",").forEach((s) => {
                s = s.replace(/::after|::before/, "");
                this.elements[s] = {
                  func,
                  args,
                  value,
                  style: style || "first",
                  selector: s,
                  fullSelector: selector
                };
              });
            }
          }
        });
      }
    }
    afterParsed(fragment) {
      for (let name of Object.keys(this.runningSelectors)) {
        let set = this.runningSelectors[name];
        let selected = Array.from(fragment.querySelectorAll(set.selector));
        if (set.identifier === "running") {
          for (let header of selected) {
            header.style.display = "none";
          }
        }
      }
    }
    afterPageLayout(fragment) {
      for (let name of Object.keys(this.runningSelectors)) {
        let set = this.runningSelectors[name];
        let selected = fragment.querySelector(set.selector);
        if (selected) {
          if (set.identifier === "running") {
            set.first = selected;
          } else {
            console.warn(set.value + "needs css replacement");
          }
        }
      }
      if (!this.orderedSelectors) {
        this.orderedSelectors = this.orderSelectors(this.elements);
      }
      for (let selector of this.orderedSelectors) {
        if (selector) {
          let el = this.elements[selector];
          let selected = fragment.querySelector(selector);
          if (selected) {
            let running = this.runningSelectors[el.args[0]];
            if (running && running.first) {
              selected.innerHTML = "";
              let clone = running.first.cloneNode(true);
              clone.style.display = null;
              selected.appendChild(clone);
            }
          }
        }
      }
    }
    /**
    * Assign a weight to @page selector classes
    * 1) page
    * 2) left & right
    * 3) blank
    * 4) first & nth
    * 5) named page
    * 6) named left & right
    * 7) named first & nth
    * @param {string} [s] selector string
    * @return {int} weight
    */
    pageWeight(s) {
      let weight = 1;
      let selector = s.split(" ");
      let parts = selector.length && selector[0].split(".");
      parts.shift();
      switch (parts.length) {
        case 4:
          if (/^pagedjs_[\w-]+_first_page$/.test(parts[3])) {
            weight = 7;
          } else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
            weight = 6;
          }
          break;
        case 3:
          if (parts[1] === "pagedjs_named_page") {
            if (parts[2].indexOf(":nth-of-type") > -1) {
              weight = 7;
            } else {
              weight = 5;
            }
          }
          break;
        case 2:
          if (parts[1] === "pagedjs_first_page") {
            weight = 4;
          } else if (parts[1] === "pagedjs_blank_page") {
            weight = 3;
          } else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
            weight = 2;
          }
          break;
        default:
          if (parts[0].indexOf(":nth-of-type") > -1) {
            weight = 4;
          } else {
            weight = 1;
          }
      }
      return weight;
    }
    /**
    * Orders the selectors based on weight
    *
    * Does not try to deduplicate base on specifity of the selector
    * Previous matched selector will just be overwritten
    * @param {obj} [obj] selectors object
    * @return {Array} orderedSelectors
    */
    orderSelectors(obj) {
      let selectors = Object.keys(obj);
      let weighted = {
        1: [],
        2: [],
        3: [],
        4: [],
        5: [],
        6: [],
        7: []
      };
      let orderedSelectors = [];
      for (let s of selectors) {
        let w = this.pageWeight(s);
        weighted[w].unshift(s);
      }
      for (var i = 1; i <= 7; i++) {
        orderedSelectors = orderedSelectors.concat(weighted[i]);
      }
      return orderedSelectors;
    }
    beforeTreeParse(text, sheet) {
      sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
    }
  };
  var running_headers_default = RunningHeaders;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/generated-content/string-sets.js
  var import_css_tree12 = __toESM(require_lib(), 1);

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/utils/css.js
  function cleanPseudoContent(el, trim = `"' `) {
    if (el == null)
      return;
    return el.replace(new RegExp(`^[${trim}]+`), "").replace(new RegExp(`[${trim}]+$`), "").replace(/["']/g, (match) => {
      return "\\" + match;
    }).replace(/[\n]/g, (match) => {
      return "\\00000A";
    });
  }
  function cleanSelector(el) {
    if (el == null)
      return;
    return el.replace(new RegExp("::footnote-call", "g"), "").replace(new RegExp("::footnote-marker", "g"), "");
  }

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/generated-content/string-sets.js
  var StringSets = class extends handler_default {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.stringSetSelectors = {};
      this.type;
      this.pageLastString;
    }
    onDeclaration(declaration, dItem, dList, rule) {
      if (declaration.property === "string-set") {
        let selector = import_css_tree12.default.generate(rule.ruleNode.prelude);
        let identifiers = [];
        let functions = [];
        let values = [];
        declaration.value.children.forEach((child2) => {
          if (child2.type === "Identifier") {
            identifiers.push(child2.name);
          }
          if (child2.type === "Function") {
            functions.push(child2.name);
            child2.children.forEach((subchild) => {
              if (subchild.type === "Identifier") {
                values.push(subchild.name);
              }
            });
          }
        });
        identifiers.forEach((identifier, index) => {
          let func = functions[index];
          let value = values[index];
          this.stringSetSelectors[identifier] = {
            identifier,
            func,
            value,
            selector
          };
        });
      }
    }
    onContent(funcNode, fItem, fList, declaration, rule) {
      if (funcNode.name === "string") {
        let identifier = funcNode.children && funcNode.children.first().name;
        this.type = funcNode.children.last().name;
        funcNode.name = "var";
        funcNode.children = new import_css_tree12.default.List();
        if (this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except") {
          funcNode.children.append(
            funcNode.children.createItem({
              type: "Identifier",
              loc: null,
              name: "--pagedjs-string-" + this.type + "-" + identifier
            })
          );
        } else {
          funcNode.children.append(
            funcNode.children.createItem({
              type: "Identifier",
              loc: null,
              name: "--pagedjs-string-first-" + identifier
            })
          );
        }
      }
    }
    afterPageLayout(fragment) {
      if (this.pageLastString === void 0) {
        this.pageLastString = {};
      }
      for (let name of Object.keys(this.stringSetSelectors)) {
        let set = this.stringSetSelectors[name];
        let value = set.value;
        let func = set.func;
        let selected = fragment.querySelectorAll(set.selector);
        let stringPrevPage = name in this.pageLastString ? this.pageLastString[name] : "";
        let varFirst, varLast, varStart, varFirstExcept;
        if (selected.length == 0) {
          varFirst = stringPrevPage;
          varLast = stringPrevPage;
          varStart = stringPrevPage;
          varFirstExcept = stringPrevPage;
        } else {
          selected.forEach((sel) => {
            if (func === "content") {
              this.pageLastString[name] = selected[selected.length - 1].textContent;
            }
            if (func === "attr") {
              this.pageLastString[name] = selected[selected.length - 1].getAttribute(value) || "";
            }
          });
          if (func === "content") {
            varFirst = selected[0].textContent;
          }
          if (func === "attr") {
            varFirst = selected[0].getAttribute(value) || "";
          }
          if (func === "content") {
            varLast = selected[selected.length - 1].textContent;
          }
          if (func === "attr") {
            varLast = selected[selected.length - 1].getAttribute(value) || "";
          }
          let selTop = selected[0].getBoundingClientRect().top;
          let pageContent = selected[0].closest(".pagedjs_page_content");
          let pageContentTop = pageContent.getBoundingClientRect().top;
          if (selTop == pageContentTop) {
            varStart = varFirst;
          } else {
            varStart = stringPrevPage;
          }
          varFirstExcept = "";
        }
        fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
        fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
        fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
        fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
      }
    }
  };
  var string_sets_default = StringSets;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/generated-content/target-counters.js
  var import_css_tree13 = __toESM(require_lib(), 1);
  var TargetCounters = class extends handler_default {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.styleSheet = polisher.styleSheet;
      this.counterTargets = {};
    }
    onContent(funcNode, fItem, fList, declaration, rule) {
      if (funcNode.name === "target-counter") {
        let selector = import_css_tree13.default.generate(rule.ruleNode.prelude);
        let first = funcNode.children.first();
        let func = first.name;
        let value = import_css_tree13.default.generate(funcNode);
        let args = [];
        first.children.forEach((child2) => {
          if (child2.type === "Identifier") {
            args.push(child2.name);
          }
        });
        let counter;
        let style;
        let styleIdentifier;
        funcNode.children.forEach((child2) => {
          if (child2.type === "Identifier") {
            if (!counter) {
              counter = child2.name;
            } else if (!style) {
              styleIdentifier = import_css_tree13.default.clone(child2);
              style = child2.name;
            }
          }
        });
        let variable = "target-counter-" + UUID();
        selector.split(",").forEach((s) => {
          this.counterTargets[s] = {
            func,
            args,
            value,
            counter,
            style,
            selector: s,
            fullSelector: selector,
            variable
          };
        });
        funcNode.name = "counter";
        funcNode.children = new import_css_tree13.default.List();
        funcNode.children.appendData({
          type: "Identifier",
          loc: 0,
          name: variable
        });
        if (styleIdentifier) {
          funcNode.children.appendData({ type: "Operator", loc: null, value: "," });
          funcNode.children.appendData(styleIdentifier);
        }
      }
    }
    afterPageLayout(fragment, page, breakToken, chunker) {
      Object.keys(this.counterTargets).forEach((name) => {
        let target = this.counterTargets[name];
        let split = target.selector.split(/::?/g);
        let query = split[0];
        let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");
        queried.forEach((selected, index) => {
          if (target.func !== "attr") {
            return;
          }
          let val = attr(selected, target.args);
          let element2 = chunker.pagesArea.querySelector(querySelectorEscape(val));
          if (element2) {
            let selector = UUID();
            selected.setAttribute("data-" + target.variable, selector);
            let pseudo = "";
            if (split.length > 1) {
              pseudo += "::" + split[1];
            }
            if (target.counter === "page") {
              let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
              let pg = 0;
              for (let i = 0; i < pages.length; i++) {
                let page2 = pages[i];
                let styles = window.getComputedStyle(page2);
                let reset = styles["counter-reset"].replace("page", "").trim();
                let increment = styles["counter-increment"].replace("page", "").trim();
                if (reset !== "none") {
                  pg = parseInt(reset);
                }
                if (increment !== "none") {
                  pg += parseInt(increment);
                }
                if (page2.contains(element2)) {
                  break;
                }
              }
              this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
            } else {
              let value = element2.getAttribute(`data-counter-${target.counter}-value`);
              if (value) {
                this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
              }
            }
            let el = document.querySelector(`[data-${target.variable}="${selector}"]`);
            if (el) {
              el.style.display = "none";
              el.clientHeight;
              el.style.removeProperty("display");
            }
          }
        });
      });
    }
  };
  var target_counters_default = TargetCounters;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/generated-content/target-text.js
  var import_css_tree14 = __toESM(require_lib(), 1);
  var TargetText = class extends handler_default {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.styleSheet = polisher.styleSheet;
      this.textTargets = {};
      this.beforeContent = "";
      this.afterContent = "";
      this.selector = {};
    }
    onContent(funcNode, fItem, fList, declaration, rule) {
      if (funcNode.name === "target-text") {
        this.selector = import_css_tree14.default.generate(rule.ruleNode.prelude);
        let first = funcNode.children.first();
        let last = funcNode.children.last();
        let func = first.name;
        let value = import_css_tree14.default.generate(funcNode);
        let args = [];
        first.children.forEach((child2) => {
          if (child2.type === "Identifier") {
            args.push(child2.name);
          }
        });
        let style;
        if (last !== first) {
          style = last.name;
        }
        let variable = "--pagedjs-" + UUID();
        this.selector.split(",").forEach((s) => {
          this.textTargets[s] = {
            func,
            args,
            value,
            style: style || "content",
            selector: s,
            fullSelector: this.selector,
            variable
          };
        });
        funcNode.name = "var";
        funcNode.children = new import_css_tree14.default.List();
        funcNode.children.appendData({
          type: "Identifier",
          loc: 0,
          name: variable
        });
      }
    }
    //   parse this on the ONCONTENT : get all before and after and replace the value with a variable
    onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
      rule.ruleNode.block.children.forEach((properties) => {
        if (pseudoNode.name === "before" && properties.property === "content") {
          let contenu = properties.value.children;
          contenu.forEach((prop) => {
            if (prop.type === "String") {
              this.beforeContent = prop.value;
            }
          });
        } else if (pseudoNode.name === "after" && properties.property === "content") {
          properties.value.children.forEach((prop) => {
            if (prop.type === "String") {
              this.afterContent = prop.value;
            }
          });
        }
      });
    }
    afterParsed(fragment) {
      Object.keys(this.textTargets).forEach((name) => {
        let target = this.textTargets[name];
        let split = target.selector.split("::");
        let query = split[0];
        let queried = fragment.querySelectorAll(query);
        let textContent;
        queried.forEach((selected, index) => {
          let val = attr(selected, target.args);
          let element2 = fragment.querySelector(querySelectorEscape(val));
          if (element2) {
            if (target.style) {
              this.selector = UUID();
              selected.setAttribute("data-target-text", this.selector);
              let psuedo = "";
              if (split.length > 1) {
                psuedo += "::" + split[1];
              }
              if (target.style === "before" || target.style === "after") {
                const pseudoType = `${target.style}Content`;
                textContent = cleanPseudoContent(this[pseudoType]);
              } else {
                textContent = cleanPseudoContent(element2.textContent, " ");
              }
              textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
              this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
            } else {
              console.warn("missed target", val);
            }
          }
        });
      });
    }
  };
  var target_text_default = TargetText;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/generated-content/index.js
  var generated_content_default = [
    running_headers_default,
    string_sets_default,
    target_counters_default,
    target_text_default
  ];

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/filters/whitespace.js
  var WhiteSpaceFilter = class extends handler_default {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    filter(content) {
      filterTree(content, (node) => {
        return this.filterEmpty(node);
      }, NodeFilter.SHOW_TEXT);
    }
    filterEmpty(node) {
      if (node.textContent.length > 1 && isIgnorable(node)) {
        let parent = node.parentNode;
        let pre = isElement(parent) && parent.closest("pre");
        if (pre) {
          return NodeFilter.FILTER_REJECT;
        }
        const previousSibling = previousSignificantNode(node);
        const nextSibling = nextSignificantNode(node);
        if (nextSibling === null && previousSibling === null) {
          node.textContent = " ";
          return NodeFilter.FILTER_REJECT;
        }
        if (nextSibling === null) {
          return NodeFilter.FILTER_ACCEPT;
        }
        if (previousSibling === null) {
          return NodeFilter.FILTER_ACCEPT;
        }
        node.textContent = " ";
        return NodeFilter.FILTER_REJECT;
      } else {
        return NodeFilter.FILTER_REJECT;
      }
    }
  };
  var whitespace_default = WhiteSpaceFilter;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/filters/comments.js
  var CommentsFilter = class extends handler_default {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    filter(content) {
      filterTree(content, null, NodeFilter.SHOW_COMMENT);
    }
  };
  var comments_default = CommentsFilter;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/filters/scripts.js
  var ScriptsFilter = class extends handler_default {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    filter(content) {
      content.querySelectorAll("script").forEach((script) => {
        script.remove();
      });
    }
  };
  var scripts_default = ScriptsFilter;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/filters/undisplayed.js
  var import_css_tree15 = __toESM(require_lib(), 1);
  var import_clear_cut = __toESM(require_clear_cut(), 1);
  var UndisplayedFilter = class extends handler_default {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.displayRules = {};
    }
    onDeclaration(declaration, dItem, dList, rule) {
      if (declaration.property === "display") {
        let selector = import_css_tree15.default.generate(rule.ruleNode.prelude);
        let value = declaration.value.children.first().name;
        selector.split(",").forEach((s) => {
          this.displayRules[s] = {
            value,
            selector: s,
            specificity: (0, import_clear_cut.calculateSpecificity)(s),
            important: declaration.important
          };
        });
      }
    }
    filter(content) {
      let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);
      for (let i = 0; i < matches.length; i++) {
        let element2 = matches[i];
        let selector = selectors[i];
        let displayValue = selector[selector.length - 1].value;
        if (this.removable(element2) && displayValue === "none") {
          element2.dataset.undisplayed = "undisplayed";
        }
      }
      let styledElements = content.querySelectorAll("[style]");
      for (let i = 0; i < styledElements.length; i++) {
        let element2 = styledElements[i];
        if (this.removable(element2)) {
          element2.dataset.undisplayed = "undisplayed";
        }
      }
    }
    sorter(a, b) {
      if (a.important && !b.important) {
        return 1;
      }
      if (b.important && !a.important) {
        return -1;
      }
      return a.specificity - b.specificity;
    }
    sortDisplayedSelectors(content, displayRules = []) {
      let matches = [];
      let selectors = [];
      for (let d in displayRules) {
        let displayItem = displayRules[d];
        let selector = displayItem.selector;
        let query = [];
        try {
          try {
            query = content.querySelectorAll(selector);
          } catch (e) {
            query = content.querySelectorAll(cleanSelector(selector));
          }
        } catch (e) {
          query = [];
        }
        let elements = Array.from(query);
        for (let e of elements) {
          if (matches.includes(e)) {
            let index = matches.indexOf(e);
            selectors[index].push(displayItem);
            selectors[index] = selectors[index].sort(this.sorter);
          } else {
            matches.push(e);
            selectors.push([displayItem]);
          }
        }
      }
      return { matches, selectors };
    }
    removable(element2) {
      if (element2.style && element2.style.display !== "" && element2.style.display !== "none") {
        return false;
      }
      return true;
    }
  };
  var undisplayed_default = UndisplayedFilter;

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/modules/filters/index.js
  var filters_default = [
    whitespace_default,
    comments_default,
    scripts_default,
    undisplayed_default
  ];

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/utils/handlers.js
  var import_event_emitter5 = __toESM(require_event_emitter(), 1);
  var import_pipe = __toESM(require_pipe(), 1);
  var registeredHandlers = [...paged_media_default, ...generated_content_default, ...filters_default];
  var Handlers = class {
    constructor(chunker, polisher, caller) {
      let handlers = [];
      registeredHandlers.forEach((Handler2) => {
        let handler = new Handler2(chunker, polisher, caller);
        handlers.push(handler);
        (0, import_pipe.default)(handler, this);
      });
    }
  };
  (0, import_event_emitter5.default)(Handlers.prototype);
  function registerHandlers() {
    for (var i = 0; i < arguments.length; i++) {
      registeredHandlers.push(arguments[i]);
    }
  }
  function initializeHandlers(chunker, polisher, caller) {
    let handlers = new Handlers(chunker, polisher, caller);
    return handlers;
  }

  // node_modules/.pnpm/pagedjs@0.4.3/node_modules/pagedjs/src/polyfill/previewer.js
  var Previewer = class {
    constructor(options) {
      this.settings = options || {};
      this.polisher = new polisher_default(false);
      this.chunker = new chunker_default(void 0, void 0, this.settings);
      this.hooks = {};
      this.hooks.beforePreview = new hook_default(this);
      this.hooks.afterPreview = new hook_default(this);
      this.size = {
        width: {
          value: 8.5,
          unit: "in"
        },
        height: {
          value: 11,
          unit: "in"
        },
        format: void 0,
        orientation: void 0
      };
      this.chunker.on("page", (page) => {
        this.emit("page", page);
      });
      this.chunker.on("rendering", () => {
        this.emit("rendering", this.chunker);
      });
    }
    initializeHandlers() {
      let handlers = initializeHandlers(this.chunker, this.polisher, this);
      handlers.on("size", (size) => {
        this.size = size;
        this.emit("size", size);
      });
      handlers.on("atpages", (pages) => {
        this.atpages = pages;
        this.emit("atpages", pages);
      });
      return handlers;
    }
    registerHandlers() {
      return registerHandlers.apply(registerHandlers, arguments);
    }
    getParams(name) {
      let param;
      let url = new URL(window.location);
      let params = new URLSearchParams(url.search);
      for (var pair of params.entries()) {
        if (pair[0] === name) {
          param = pair[1];
        }
      }
      return param;
    }
    wrapContent() {
      let body = document.querySelector("body");
      let template;
      template = body.querySelector(":scope > template[data-ref='pagedjs-content']");
      if (!template) {
        template = document.createElement("template");
        template.dataset.ref = "pagedjs-content";
        template.innerHTML = body.innerHTML;
        body.innerHTML = "";
        body.appendChild(template);
      }
      return template.content;
    }
    removeStyles(doc = document) {
      const stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']:not([data-pagedjs-ignore], [media~='screen'])"));
      const inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles], [data-pagedjs-ignore], [media~='screen'])"));
      const elements = [...stylesheets, ...inlineStyles];
      return elements.sort(function(element1, element2) {
        const position = element1.compareDocumentPosition(element2);
        if (position === Node.DOCUMENT_POSITION_PRECEDING) {
          return 1;
        } else if (position === Node.DOCUMENT_POSITION_FOLLOWING) {
          return -1;
        }
        return 0;
      }).map((element2) => {
        if (element2.nodeName === "STYLE") {
          const obj = {};
          obj[window.location.href] = element2.textContent;
          element2.remove();
          return obj;
        }
        if (element2.nodeName === "LINK") {
          element2.remove();
          return element2.href;
        }
        console.warn(`Unable to process: ${element2}, ignoring.`);
      });
    }
    async preview(content, stylesheets, renderTo) {
      await this.hooks.beforePreview.trigger(content, renderTo);
      if (!content) {
        content = this.wrapContent();
      }
      if (!stylesheets) {
        stylesheets = this.removeStyles();
      }
      this.polisher.setup();
      this.handlers = this.initializeHandlers();
      await this.polisher.add(...stylesheets);
      let startTime = performance.now();
      let flow = await this.chunker.flow(content, renderTo);
      let endTime = performance.now();
      flow.performance = endTime - startTime;
      flow.size = this.size;
      this.emit("rendered", flow);
      await this.hooks.afterPreview.trigger(flow.pages);
      return flow;
    }
  };
  (0, import_event_emitter6.default)(Previewer.prototype);
  var previewer_default = Previewer;

  // src/lib/pager/entities.ts
  var PREFIX = "pagedjs_custom";
  var PAGES_GROUP_DATA_ATTRIBUTE = `data-${PREFIX}-group-id`;
  var PAGES_GROUP_CLASS_NAME = `${PREFIX}_pagesgroup`;
  var HEADER_CLASS_NAME = `${PREFIX}_header`;
  var FOOTER_CLASS_NAME = `${PREFIX}_footer`;

  // src/lib/pager/registerPageHandler.ts
  var pageHandlers = /* @__PURE__ */ new Set();
  var getPagesGroupId = (pageEl) => {
    const pageGroupId = pageEl.querySelector(`[${PAGES_GROUP_DATA_ATTRIBUTE}]`)?.getAttribute(PAGES_GROUP_DATA_ATTRIBUTE);
    if (!pageGroupId) {
      throw new TypeError("Could not derive page group id from page element.");
    }
    return pageGroupId;
  };
  var getPageType = (pageEl) => {
    const elClasses = Array.from(pageEl.classList);
    if (elClasses.includes("pagedjs_first_page")) {
      return "first";
    }
    if (elClasses.includes("pagedjs_left_page")) {
      return "odd";
    }
    if (elClasses.includes("pagedjs_right_page")) {
      return "even";
    }
    throw new TypeError("Could not derive page type from page element.");
  };
  var PagedJsHandler = class extends handler_default {
    afterPageLayout(pageEl) {
      const pagesGroupId = getPagesGroupId(pageEl);
      pageEl.setAttribute(PAGES_GROUP_DATA_ATTRIBUTE, pagesGroupId);
      pageHandlers.forEach(
        (pageHandler) => pageHandler(pageEl, pagesGroupId, getPageType(pageEl))
      );
    }
  };
  registerHandlers(PagedJsHandler);
  var registerPageHandler = (pageHandler) => {
    const wrappedFn = pageHandler.bind(void 0);
    pageHandlers.add(wrappedFn);
    return () => {
      pageHandlers.delete(wrappedFn);
    };
  };

  // src/entities/document.ts
  var PAGE_TYPES = ["default", "even", "odd", "first"];
  function assertPageType(value) {
    if (!PAGE_TYPES.includes(value)) {
      throw new TypeError(`Invalid Page Type "${value}".`);
    }
  }
  var mapPageTypes = (obj, fn) => Object.fromEntries(
    PAGE_TYPES.map((pageType) => [pageType, fn(pageType, obj[pageType])])
  );
  var DEFAULT_PAGE_OPTIONS = {
    width: "8.5in",
    height: "11in",
    marginTop: "0.5in",
    marginRight: "0.5in",
    marginBottom: "0.5in",
    marginLeft: "0.5in",
    headerHtml: false,
    footerHtml: false
  };
  var PAGE_OPTIONS_KEYS = Object.keys(DEFAULT_PAGE_OPTIONS);
  var extendPageOptions = (...optionsObjects) => {
    optionsObjects.reverse();
    return Object.fromEntries(
      PAGE_OPTIONS_KEYS.map((key) => [
        key,
        optionsObjects.find(
          (obj) => obj?.[key] && obj[key] !== false && obj[key] !== null
        )?.[key]
      ])
    );
  };
  var parsePageTypes = (pageTypes = {}) => {
    const defaultOptions = extendPageOptions(
      DEFAULT_PAGE_OPTIONS,
      pageTypes.default
    );
    return Object.fromEntries(
      PAGE_TYPES.map((pageType) => [
        pageType,
        pageType === "default" ? defaultOptions : extendPageOptions(defaultOptions, pageTypes[pageType])
      ])
    );
  };

  // src/entities/schema.ts
  var import_typebox2 = __toESM(require_typebox(), 1);

  // src/utils/units.ts
  var UNITS = ["cm", "in"];
  var unitsExp = new RegExp(`^([0-9]+(?:.[0-9]+)?)(${UNITS.join("|")})$`);
  var parseUnits = (str) => {
    const result = str.match(unitsExp);
    if (!result) {
      throw new TypeError(`Invalid unit value "${str}".`);
    }
    return [parseFloat(result[1]), result[2]];
  };
  var toUnits = (value, units) => {
    if (!UNITS.includes(units)) {
      throw new TypeError(`Invalid units "${units}".`);
    }
    return `${value}${units}`;
  };
  var mathUnits = (method, str1, str2) => {
    const [value1, units1] = parseUnits(str1);
    const [value2, units2] = parseUnits(str2);
    if (units1 !== units2) {
      throw new TypeError(`Cannot add units ${units1} and ${units2}.`);
    }
    if (method === "add") {
      return toUnits(value1 + value2, units2);
    }
    if (method === "subtract") {
      return toUnits(value1 - value2, units2);
    }
    throw new TypeError(`Invalid math method "${method}".`);
  };

  // src/utils/elements.ts
  var createEl = (innerHtml, attributes = {}) => {
    if (!innerHtml) {
      return null;
    }
    const el = document.createElement("div");
    el.innerHTML = innerHtml;
    for (const attributeName in attributes) {
      el.setAttribute(attributeName, attributes[attributeName]);
    }
    return el;
  };
  var createHtml = (innerHtml, attributes = {}) => {
    if (!innerHtml) {
      return null;
    }
    const attributesStr = Object.entries(attributes).reduce(
      (str, [key, value]) => str + `${key}="${value}"`,
      ""
    );
    return `<div ${attributesStr}>${innerHtml}</div>`;
  };
  var getElHeight = (el, baseWidth) => {
    const [widthValue, units] = parseUnits(baseWidth);
    if (!el) {
      return toUnits(0, units);
    }
    const clonedEl = el.cloneNode(true);
    clonedEl.style.visibility = "hidden";
    clonedEl.style.display = "block";
    clonedEl.style.position = "absolute";
    clonedEl.style.width = baseWidth;
    document.body.appendChild(clonedEl);
    const { width, height } = clonedEl.getBoundingClientRect();
    clonedEl.remove();
    return toUnits(widthValue * height / width, units);
  };
  var appendCloneTo = (parentEl, el) => {
    if (!el) {
      return;
    }
    parentEl.appendChild(el.cloneNode(true));
  };

  // src/utils/styles.ts
  var jsToCss = (obj) => {
    let cssString = "";
    for (let objectKey in obj) {
      cssString += objectKey.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`) + ": " + obj[objectKey] + ";\n";
    }
    return cssString;
  };
  var addStyleSheet = (css) => {
    const style = document.createElement("style");
    style.textContent = css;
    document.head.appendChild(style);
  };

  // src/utils/utilities.ts
  var asArray = (value) => Array.isArray(value) ? value : [value];

  // node_modules/.pnpm/docx@8.2.3/node_modules/docx/build/index.mjs
  var __defProp2 = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var BaseXmlComponent = class {
    constructor(rootKey) {
      __publicField(this, "rootKey");
      this.rootKey = rootKey;
    }
  };
  var EMPTY_OBJECT = Object.seal({});
  var XmlComponent = class extends BaseXmlComponent {
    constructor(rootKey) {
      super(rootKey);
      __publicField(this, "root");
      this.root = new Array();
    }
    // This method is called by the formatter to get the XML representation of this component.
    // It is called recursively for all child components.
    // It is a serializer to be used in the xml library.
    // https://www.npmjs.com/package/xml
    // Child components can override this method to customize the XML representation, or execute side effects.
    prepForXml(context) {
      var _a;
      context.stack.push(this);
      const children = this.root.map((comp) => {
        if (comp instanceof BaseXmlComponent) {
          return comp.prepForXml(context);
        }
        return comp;
      }).filter((comp) => comp !== void 0);
      context.stack.pop();
      return {
        [this.rootKey]: children.length ? children.length === 1 && ((_a = children[0]) == null ? void 0 : _a._attr) ? children[0] : children : EMPTY_OBJECT
      };
    }
    addChildElement(child2) {
      this.root.push(child2);
      return this;
    }
  };
  var XmlAttributeComponent = class extends BaseXmlComponent {
    constructor(root) {
      super("_attr");
      __publicField(this, "xmlKeys");
      this.root = root;
    }
    prepForXml(_) {
      const attrs = {};
      Object.keys(this.root).forEach((key) => {
        const value = this.root[key];
        if (value !== void 0) {
          const newKey = this.xmlKeys && this.xmlKeys[key] || key;
          attrs[newKey] = value;
        }
      });
      return { _attr: attrs };
    }
  };
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var sax$1 = {};
  var events = { exports: {} };
  var R = typeof Reflect === "object" ? Reflect : null;
  var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  };
  var ReflectOwnKeys;
  if (R && typeof R.ownKeys === "function") {
    ReflectOwnKeys = R.ownKeys;
  } else if (Object.getOwnPropertySymbols) {
    ReflectOwnKeys = function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
    };
  } else {
    ReflectOwnKeys = function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target);
    };
  }
  function ProcessEmitWarning(warning) {
    if (console && console.warn)
      console.warn(warning);
  }
  var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
    return value !== value;
  };
  function EventEmitter7() {
    EventEmitter7.init.call(this);
  }
  events.exports = EventEmitter7;
  events.exports.once = once2;
  EventEmitter7.EventEmitter = EventEmitter7;
  EventEmitter7.prototype._events = void 0;
  EventEmitter7.prototype._eventsCount = 0;
  EventEmitter7.prototype._maxListeners = void 0;
  var defaultMaxListeners = 10;
  function checkListener(listener) {
    if (typeof listener !== "function") {
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
    }
  }
  Object.defineProperty(EventEmitter7, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
      }
      defaultMaxListeners = arg;
    }
  });
  EventEmitter7.init = function() {
    if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || void 0;
  };
  EventEmitter7.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
    }
    this._maxListeners = n;
    return this;
  };
  function _getMaxListeners(that) {
    if (that._maxListeners === void 0)
      return EventEmitter7.defaultMaxListeners;
    return that._maxListeners;
  }
  EventEmitter7.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
  };
  EventEmitter7.prototype.emit = function emit(type) {
    var args = [];
    for (var i = 1; i < arguments.length; i++)
      args.push(arguments[i]);
    var doError = type === "error";
    var events2 = this._events;
    if (events2 !== void 0)
      doError = doError && events2.error === void 0;
    else if (!doError)
      return false;
    if (doError) {
      var er;
      if (args.length > 0)
        er = args[0];
      if (er instanceof Error) {
        throw er;
      }
      var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
      err.context = er;
      throw err;
    }
    var handler = events2[type];
    if (handler === void 0)
      return false;
    if (typeof handler === "function") {
      ReflectApply(handler, this, args);
    } else {
      var len = handler.length;
      var listeners2 = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        ReflectApply(listeners2[i], this, args);
    }
    return true;
  };
  function _addListener(target, type, listener, prepend) {
    var m;
    var events2;
    var existing;
    checkListener(listener);
    events2 = target._events;
    if (events2 === void 0) {
      events2 = target._events = /* @__PURE__ */ Object.create(null);
      target._eventsCount = 0;
    } else {
      if (events2.newListener !== void 0) {
        target.emit(
          "newListener",
          type,
          listener.listener ? listener.listener : listener
        );
        events2 = target._events;
      }
      existing = events2[type];
    }
    if (existing === void 0) {
      existing = events2[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === "function") {
        existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
      } else if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
      m = _getMaxListeners(target);
      if (m > 0 && existing.length > m && !existing.warned) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        ProcessEmitWarning(w);
      }
    }
    return target;
  }
  EventEmitter7.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
  };
  EventEmitter7.prototype.on = EventEmitter7.prototype.addListener;
  EventEmitter7.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
  };
  function onceWrapper() {
    if (!this.fired) {
      this.target.removeListener(this.type, this.wrapFn);
      this.fired = true;
      if (arguments.length === 0)
        return this.listener.call(this.target);
      return this.listener.apply(this.target, arguments);
    }
  }
  function _onceWrap(target, type, listener) {
    var state2 = { fired: false, wrapFn: void 0, target, type, listener };
    var wrapped = onceWrapper.bind(state2);
    wrapped.listener = listener;
    state2.wrapFn = wrapped;
    return wrapped;
  }
  EventEmitter7.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
  };
  EventEmitter7.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
  };
  EventEmitter7.prototype.removeListener = function removeListener(type, listener) {
    var list, events2, position, i, originalListener;
    checkListener(listener);
    events2 = this._events;
    if (events2 === void 0)
      return this;
    list = events2[type];
    if (list === void 0)
      return this;
    if (list === listener || list.listener === listener) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else {
        delete events2[type];
        if (events2.removeListener)
          this.emit("removeListener", type, list.listener || listener);
      }
    } else if (typeof list !== "function") {
      position = -1;
      for (i = list.length - 1; i >= 0; i--) {
        if (list[i] === listener || list[i].listener === listener) {
          originalListener = list[i].listener;
          position = i;
          break;
        }
      }
      if (position < 0)
        return this;
      if (position === 0)
        list.shift();
      else {
        spliceOne(list, position);
      }
      if (list.length === 1)
        events2[type] = list[0];
      if (events2.removeListener !== void 0)
        this.emit("removeListener", type, originalListener || listener);
    }
    return this;
  };
  EventEmitter7.prototype.off = EventEmitter7.prototype.removeListener;
  EventEmitter7.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners2, events2, i;
    events2 = this._events;
    if (events2 === void 0)
      return this;
    if (events2.removeListener === void 0) {
      if (arguments.length === 0) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      } else if (events2[type] !== void 0) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else
          delete events2[type];
      }
      return this;
    }
    if (arguments.length === 0) {
      var keys = Object.keys(events2);
      var key;
      for (i = 0; i < keys.length; ++i) {
        key = keys[i];
        if (key === "removeListener")
          continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners("removeListener");
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
      return this;
    }
    listeners2 = events2[type];
    if (typeof listeners2 === "function") {
      this.removeListener(type, listeners2);
    } else if (listeners2 !== void 0) {
      for (i = listeners2.length - 1; i >= 0; i--) {
        this.removeListener(type, listeners2[i]);
      }
    }
    return this;
  };
  function _listeners(target, type, unwrap) {
    var events2 = target._events;
    if (events2 === void 0)
      return [];
    var evlistener = events2[type];
    if (evlistener === void 0)
      return [];
    if (typeof evlistener === "function")
      return unwrap ? [evlistener.listener || evlistener] : [evlistener];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
  }
  EventEmitter7.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
  };
  EventEmitter7.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
  };
  EventEmitter7.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === "function") {
      return emitter.listenerCount(type);
    } else {
      return listenerCount.call(emitter, type);
    }
  };
  EventEmitter7.prototype.listenerCount = listenerCount;
  function listenerCount(type) {
    var events2 = this._events;
    if (events2 !== void 0) {
      var evlistener = events2[type];
      if (typeof evlistener === "function") {
        return 1;
      } else if (evlistener !== void 0) {
        return evlistener.length;
      }
    }
    return 0;
  }
  EventEmitter7.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
  };
  function arrayClone(arr, n) {
    var copy = new Array(n);
    for (var i = 0; i < n; ++i)
      copy[i] = arr[i];
    return copy;
  }
  function spliceOne(list, index) {
    for (; index + 1 < list.length; index++)
      list[index] = list[index + 1];
    list.pop();
  }
  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }
    return ret;
  }
  function once2(emitter, name) {
    return new Promise(function(resolve2, reject) {
      function errorListener(err) {
        emitter.removeListener(name, resolver);
        reject(err);
      }
      function resolver() {
        if (typeof emitter.removeListener === "function") {
          emitter.removeListener("error", errorListener);
        }
        resolve2([].slice.call(arguments));
      }
      eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
      if (name !== "error") {
        addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
      }
    });
  }
  function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === "function") {
      eventTargetAgnosticAddListener(emitter, "error", handler, flags);
    }
  }
  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
      if (flags.once) {
        emitter.once(name, listener);
      } else {
        emitter.on(name, listener);
      }
    } else if (typeof emitter.addEventListener === "function") {
      emitter.addEventListener(name, function wrapListener(arg) {
        if (flags.once) {
          emitter.removeEventListener(name, wrapListener);
        }
        listener(arg);
      });
    } else {
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
    }
  }
  var eventsExports = events.exports;
  var inherits_browser = { exports: {} };
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  var inherits_browserExports = inherits_browser.exports;
  var buffer = {};
  var base64Js = {};
  var hasRequiredBase64Js;
  function requireBase64Js() {
    if (hasRequiredBase64Js)
      return base64Js;
    hasRequiredBase64Js = 1;
    base64Js.byteLength = byteLength;
    base64Js.toByteArray = toByteArray;
    base64Js.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
    return base64Js;
  }
  var ieee754 = {};
  var hasRequiredIeee754;
  function requireIeee754() {
    if (hasRequiredIeee754)
      return ieee754;
    hasRequiredIeee754 = 1;
    ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer2[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer2[offset + i - d] |= s * 128;
    };
    return ieee754;
  }
  var hasRequiredBuffer;
  function requireBuffer() {
    if (hasRequiredBuffer)
      return buffer;
    hasRequiredBuffer = 1;
    (function(exports) {
      var base64 = requireBase64Js();
      var ieee7542 = requireIeee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          var arr = new Uint8Array(1);
          var proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        var buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        var valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        var b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(
            value[Symbol.toPrimitive]("string"),
            encodingOrOffset,
            length
          );
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer2, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        var length = byteLength(string, encoding) | 0;
        var buf = createBuffer(length);
        var actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        var length = array.length < 0 ? 0 : checked(array.length) | 0;
        var buf = createBuffer(length);
        for (var i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          var copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        var buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          var len = checked(obj.length) | 0;
          var buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, Uint8Array))
          a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, Uint8Array))
          b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b)
          return 0;
        var x = a.length;
        var y = b.length;
        for (var i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        var i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        var buffer2 = Buffer2.allocUnsafe(length);
        var pos = 0;
        for (i = 0; i < list.length; ++i) {
          var buf = list[i];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer2.length) {
              Buffer2.from(buf).copy(buffer2, pos);
            } else {
              Uint8Array.prototype.set.call(
                buffer2,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer2, pos);
          }
          pos += buf.length;
        }
        return buffer2;
      };
      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        var len = string.length;
        var mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        var loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        var i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        var len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (var i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        var len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (var i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        var len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (var i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        var length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        var str = "";
        var max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        var x = thisEnd - thisStart;
        var y = end - start;
        var len = Math.min(x, y);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);
        for (var i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
        if (buffer2.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer2.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer2.length + byteOffset;
        if (byteOffset >= buffer2.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer2.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        var indexSize = 1;
        var arrLength = arr.length;
        var valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        var i;
        if (dir) {
          var foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            var found = true;
            for (var j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        var remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        var strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        for (var i = 0; i < length; ++i) {
          var parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        var remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        var res = [];
        var i = start;
        while (i < end) {
          var firstByte = buf[i];
          var codePoint = null;
          var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        var len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        var res = "";
        var i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        var len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        var out = "";
        for (var i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        var bytes = buf.slice(start, end);
        var res = "";
        for (var i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        var newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        var val = this[offset + --byteLength2];
        var mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var i = byteLength2;
        var mul = 1;
        var val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee7542.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee7542.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee7542.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee7542.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        var mul = 1;
        var i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        var i = byteLength2 - 1;
        var mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        var i = 0;
        var mul = 1;
        var sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        var i = byteLength2 - 1;
        var mul = 1;
        var sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4);
        }
        ieee7542.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8);
        }
        ieee7542.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        var len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        var i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          var len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        var codePoint;
        var length = string.length;
        var leadSurrogate = null;
        var bytes = [];
        for (var i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        var byteArray = [];
        for (var i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        var c, hi, lo;
        var byteArray = [];
        for (var i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src2, dst, offset, length) {
        for (var i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src2.length)
            break;
          dst[i + offset] = src2[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        var alphabet = "0123456789abcdef";
        var table = new Array(256);
        for (var i = 0; i < 16; ++i) {
          var i16 = i * 16;
          for (var j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
    })(buffer);
    return buffer;
  }
  requireBuffer();
  var browser$1 = { exports: {} };
  var process = browser$1.exports = {};
  var cachedSetTimeout;
  var cachedClearTimeout;
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      if (typeof setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      } else {
        cachedSetTimeout = defaultSetTimout;
      }
    } catch (e) {
      cachedSetTimeout = defaultSetTimout;
    }
    try {
      if (typeof clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      } else {
        cachedClearTimeout = defaultClearTimeout;
      }
    } catch (e) {
      cachedClearTimeout = defaultClearTimeout;
    }
  })();
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e2) {
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e2) {
        return cachedClearTimeout.call(this, marker);
      }
    }
  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = "browser";
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = "";
  process.versions = {};
  function noop() {
  }
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.prependListener = noop;
  process.prependOnceListener = noop;
  process.listeners = function(name) {
    return [];
  };
  process.binding = function(name) {
    throw new Error("process.binding is not supported");
  };
  process.cwd = function() {
    return "/";
  };
  process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
  };
  process.umask = function() {
    return 0;
  };
  var browserExports = browser$1.exports;
  var process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
  (function(Object2) {
    function get() {
      var _global2 = this || self;
      delete Object2.prototype.__magic__;
      return _global2;
    }
    if (typeof globalThis === "object") {
      return globalThis;
    }
    if (this) {
      return get();
    } else {
      Object2.defineProperty(Object2.prototype, "__magic__", {
        configurable: true,
        get
      });
      var _global = __magic__;
      return _global;
    }
  })(Object);
  var streamBrowser;
  var hasRequiredStreamBrowser;
  function requireStreamBrowser() {
    if (hasRequiredStreamBrowser)
      return streamBrowser;
    hasRequiredStreamBrowser = 1;
    streamBrowser = eventsExports.EventEmitter;
    return streamBrowser;
  }
  var util = {};
  var types = {};
  var shams$1;
  var hasRequiredShams$1;
  function requireShams$1() {
    if (hasRequiredShams$1)
      return shams$1;
    hasRequiredShams$1 = 1;
    shams$1 = function hasSymbols2() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
    return shams$1;
  }
  var shams;
  var hasRequiredShams;
  function requireShams() {
    if (hasRequiredShams)
      return shams;
    hasRequiredShams = 1;
    var hasSymbols2 = requireShams$1();
    shams = function hasToStringTagShams() {
      return hasSymbols2() && !!Symbol.toStringTag;
    };
    return shams;
  }
  var hasSymbols;
  var hasRequiredHasSymbols;
  function requireHasSymbols() {
    if (hasRequiredHasSymbols)
      return hasSymbols;
    hasRequiredHasSymbols = 1;
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = requireShams$1();
    hasSymbols = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
    return hasSymbols;
  }
  var implementation;
  var hasRequiredImplementation;
  function requireImplementation() {
    if (hasRequiredImplementation)
      return implementation;
    hasRequiredImplementation = 1;
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    implementation = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
    return implementation;
  }
  var functionBind;
  var hasRequiredFunctionBind;
  function requireFunctionBind() {
    if (hasRequiredFunctionBind)
      return functionBind;
    hasRequiredFunctionBind = 1;
    var implementation2 = requireImplementation();
    functionBind = Function.prototype.bind || implementation2;
    return functionBind;
  }
  var src;
  var hasRequiredSrc;
  function requireSrc() {
    if (hasRequiredSrc)
      return src;
    hasRequiredSrc = 1;
    var bind = requireFunctionBind();
    src = bind.call(Function.call, Object.prototype.hasOwnProperty);
    return src;
  }
  var getIntrinsic;
  var hasRequiredGetIntrinsic;
  function requireGetIntrinsic() {
    if (hasRequiredGetIntrinsic)
      return getIntrinsic;
    hasRequiredGetIntrinsic = 1;
    var undefined$1;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols2 = requireHasSymbols()();
    var getProto = Object.getPrototypeOf || function(x) {
      return x.__proto__;
    };
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" ? undefined$1 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols2 ? getProto([][Symbol.iterator]()) : undefined$1,
      "%AsyncFromSyncIteratorPrototype%": undefined$1,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols2 ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
      "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
      "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols2 ? getProto(""[Symbol.iterator]()) : undefined$1,
      "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
    };
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = requireFunctionBind();
    var hasOwn = requireSrc();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    getIntrinsic = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
    return getIntrinsic;
  }
  var callBind = { exports: {} };
  var hasRequiredCallBind;
  function requireCallBind() {
    if (hasRequiredCallBind)
      return callBind.exports;
    hasRequiredCallBind = 1;
    (function(module) {
      var bind = requireFunctionBind();
      var GetIntrinsic = requireGetIntrinsic();
      var $apply = GetIntrinsic("%Function.prototype.apply%");
      var $call = GetIntrinsic("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
      var $max = GetIntrinsic("%Math.max%");
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e) {
          $defineProperty = null;
        }
      }
      module.exports = function callBind2(originalFunction) {
        var func = $reflectApply(bind, $call, arguments);
        if ($gOPD && $defineProperty) {
          var desc = $gOPD(func, "length");
          if (desc.configurable) {
            $defineProperty(
              func,
              "length",
              { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
            );
          }
        }
        return func;
      };
      var applyBind = function applyBind2() {
        return $reflectApply(bind, $apply, arguments);
      };
      if ($defineProperty) {
        $defineProperty(module.exports, "apply", { value: applyBind });
      } else {
        module.exports.apply = applyBind;
      }
    })(callBind);
    return callBind.exports;
  }
  var callBound;
  var hasRequiredCallBound;
  function requireCallBound() {
    if (hasRequiredCallBound)
      return callBound;
    hasRequiredCallBound = 1;
    var GetIntrinsic = requireGetIntrinsic();
    var callBind2 = requireCallBind();
    var $indexOf = callBind2(GetIntrinsic("String.prototype.indexOf"));
    callBound = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind2(intrinsic);
      }
      return intrinsic;
    };
    return callBound;
  }
  var isArguments;
  var hasRequiredIsArguments;
  function requireIsArguments() {
    if (hasRequiredIsArguments)
      return isArguments;
    hasRequiredIsArguments = 1;
    var hasToStringTag = requireShams()();
    var callBound2 = requireCallBound();
    var $toString = callBound2("Object.prototype.toString");
    var isStandardArguments = function isArguments2(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments2(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    return isArguments;
  }
  var isGeneratorFunction;
  var hasRequiredIsGeneratorFunction;
  function requireIsGeneratorFunction() {
    if (hasRequiredIsGeneratorFunction)
      return isGeneratorFunction;
    hasRequiredIsGeneratorFunction = 1;
    var toStr = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*(?:function)?\*/;
    var hasToStringTag = requireShams()();
    var getProto = Object.getPrototypeOf;
    var getGeneratorFunc = function() {
      if (!hasToStringTag) {
        return false;
      }
      try {
        return Function("return function*() {}")();
      } catch (e) {
      }
    };
    var GeneratorFunction;
    isGeneratorFunction = function isGeneratorFunction2(fn) {
      if (typeof fn !== "function") {
        return false;
      }
      if (isFnRegex.test(fnToStr.call(fn))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr.call(fn);
        return str === "[object GeneratorFunction]";
      }
      if (!getProto) {
        return false;
      }
      if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
      }
      return getProto(fn) === GeneratorFunction;
    };
    return isGeneratorFunction;
  }
  var isCallable;
  var hasRequiredIsCallable;
  function requireIsCallable() {
    if (hasRequiredIsCallable)
      return isCallable;
    hasRequiredIsCallable = 1;
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_) {
        if (_ !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      var all = document.all;
      if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e) {
            }
          }
          return false;
        };
      }
    }
    isCallable = reflectApply ? function isCallable2(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e) {
        if (e !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable2(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
    return isCallable;
  }
  var forEach_1;
  var hasRequiredForEach;
  function requireForEach() {
    if (hasRequiredForEach)
      return forEach_1;
    hasRequiredForEach = 1;
    var isCallable2 = requireIsCallable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator, receiver) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty2.call(array, i)) {
          if (receiver == null) {
            iterator(array[i], i, array);
          } else {
            iterator.call(receiver, array[i], i, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string, iterator, receiver) {
      for (var i = 0, len = string.length; i < len; i++) {
        if (receiver == null) {
          iterator(string.charAt(i), i, string);
        } else {
          iterator.call(receiver, string.charAt(i), i, string);
        }
      }
    };
    var forEachObject = function forEachObject2(object, iterator, receiver) {
      for (var k in object) {
        if (hasOwnProperty2.call(object, k)) {
          if (receiver == null) {
            iterator(object[k], k, object);
          } else {
            iterator.call(receiver, object[k], k, object);
          }
        }
      }
    };
    var forEach = function forEach2(list, iterator, thisArg) {
      if (!isCallable2(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (toStr.call(list) === "[object Array]") {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    };
    forEach_1 = forEach;
    return forEach_1;
  }
  var availableTypedArrays;
  var hasRequiredAvailableTypedArrays;
  function requireAvailableTypedArrays() {
    if (hasRequiredAvailableTypedArrays)
      return availableTypedArrays;
    hasRequiredAvailableTypedArrays = 1;
    var possibleNames = [
      "BigInt64Array",
      "BigUint64Array",
      "Float32Array",
      "Float64Array",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Uint16Array",
      "Uint32Array",
      "Uint8Array",
      "Uint8ClampedArray"
    ];
    var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
    availableTypedArrays = function availableTypedArrays2() {
      var out = [];
      for (var i = 0; i < possibleNames.length; i++) {
        if (typeof g[possibleNames[i]] === "function") {
          out[out.length] = possibleNames[i];
        }
      }
      return out;
    };
    return availableTypedArrays;
  }
  var gopd;
  var hasRequiredGopd;
  function requireGopd() {
    if (hasRequiredGopd)
      return gopd;
    hasRequiredGopd = 1;
    var GetIntrinsic = requireGetIntrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    gopd = $gOPD;
    return gopd;
  }
  var isTypedArray;
  var hasRequiredIsTypedArray;
  function requireIsTypedArray() {
    if (hasRequiredIsTypedArray)
      return isTypedArray;
    hasRequiredIsTypedArray = 1;
    var forEach = requireForEach();
    var availableTypedArrays2 = requireAvailableTypedArrays();
    var callBound2 = requireCallBound();
    var $toString = callBound2("Object.prototype.toString");
    var hasToStringTag = requireShams()();
    var gOPD = requireGopd();
    var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
    var typedArrays = availableTypedArrays2();
    var $indexOf = callBound2("Array.prototype.indexOf", true) || function indexOf2(array, value) {
      for (var i = 0; i < array.length; i += 1) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    };
    var $slice = callBound2("String.prototype.slice");
    var toStrTags = {};
    var getPrototypeOf = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr) {
          var proto = getPrototypeOf(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          toStrTags[typedArray] = descriptor.get;
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var anyTrue = false;
      forEach(toStrTags, function(getter, typedArray) {
        if (!anyTrue) {
          try {
            anyTrue = getter.call(value) === typedArray;
          } catch (e) {
          }
        }
      });
      return anyTrue;
    };
    isTypedArray = function isTypedArray2(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        var tag = $slice($toString(value), 8, -1);
        return $indexOf(typedArrays, tag) > -1;
      }
      if (!gOPD) {
        return false;
      }
      return tryTypedArrays(value);
    };
    return isTypedArray;
  }
  var whichTypedArray;
  var hasRequiredWhichTypedArray;
  function requireWhichTypedArray() {
    if (hasRequiredWhichTypedArray)
      return whichTypedArray;
    hasRequiredWhichTypedArray = 1;
    var forEach = requireForEach();
    var availableTypedArrays2 = requireAvailableTypedArrays();
    var callBound2 = requireCallBound();
    var gOPD = requireGopd();
    var $toString = callBound2("Object.prototype.toString");
    var hasToStringTag = requireShams()();
    var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
    var typedArrays = availableTypedArrays2();
    var $slice = callBound2("String.prototype.slice");
    var toStrTags = {};
    var getPrototypeOf = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        if (typeof g[typedArray] === "function") {
          var arr = new g[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
          }
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var foundName = false;
      forEach(toStrTags, function(getter, typedArray) {
        if (!foundName) {
          try {
            var name = getter.call(value);
            if (name === typedArray) {
              foundName = name;
            }
          } catch (e) {
          }
        }
      });
      return foundName;
    };
    var isTypedArray2 = requireIsTypedArray();
    whichTypedArray = function whichTypedArray2(value) {
      if (!isTypedArray2(value)) {
        return false;
      }
      if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        return $slice($toString(value), 8, -1);
      }
      return tryTypedArrays(value);
    };
    return whichTypedArray;
  }
  var hasRequiredTypes;
  function requireTypes() {
    if (hasRequiredTypes)
      return types;
    hasRequiredTypes = 1;
    (function(exports) {
      var isArgumentsObject = requireIsArguments();
      var isGeneratorFunction2 = requireIsGeneratorFunction();
      var whichTypedArray2 = requireWhichTypedArray();
      var isTypedArray2 = requireIsTypedArray();
      function uncurryThis(f) {
        return f.call.bind(f);
      }
      var BigIntSupported = typeof BigInt !== "undefined";
      var SymbolSupported = typeof Symbol !== "undefined";
      var ObjectToString = uncurryThis(Object.prototype.toString);
      var numberValue = uncurryThis(Number.prototype.valueOf);
      var stringValue = uncurryThis(String.prototype.valueOf);
      var booleanValue = uncurryThis(Boolean.prototype.valueOf);
      if (BigIntSupported) {
        var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
      }
      if (SymbolSupported) {
        var symbolValue = uncurryThis(Symbol.prototype.valueOf);
      }
      function checkBoxedPrimitive(value, prototypeValueOf) {
        if (typeof value !== "object") {
          return false;
        }
        try {
          prototypeValueOf(value);
          return true;
        } catch (e) {
          return false;
        }
      }
      exports.isArgumentsObject = isArgumentsObject;
      exports.isGeneratorFunction = isGeneratorFunction2;
      exports.isTypedArray = isTypedArray2;
      function isPromise(input) {
        return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
      }
      exports.isPromise = isPromise;
      function isArrayBufferView(value) {
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          return ArrayBuffer.isView(value);
        }
        return isTypedArray2(value) || isDataView(value);
      }
      exports.isArrayBufferView = isArrayBufferView;
      function isUint8Array(value) {
        return whichTypedArray2(value) === "Uint8Array";
      }
      exports.isUint8Array = isUint8Array;
      function isUint8ClampedArray(value) {
        return whichTypedArray2(value) === "Uint8ClampedArray";
      }
      exports.isUint8ClampedArray = isUint8ClampedArray;
      function isUint16Array(value) {
        return whichTypedArray2(value) === "Uint16Array";
      }
      exports.isUint16Array = isUint16Array;
      function isUint32Array(value) {
        return whichTypedArray2(value) === "Uint32Array";
      }
      exports.isUint32Array = isUint32Array;
      function isInt8Array(value) {
        return whichTypedArray2(value) === "Int8Array";
      }
      exports.isInt8Array = isInt8Array;
      function isInt16Array(value) {
        return whichTypedArray2(value) === "Int16Array";
      }
      exports.isInt16Array = isInt16Array;
      function isInt32Array(value) {
        return whichTypedArray2(value) === "Int32Array";
      }
      exports.isInt32Array = isInt32Array;
      function isFloat32Array(value) {
        return whichTypedArray2(value) === "Float32Array";
      }
      exports.isFloat32Array = isFloat32Array;
      function isFloat64Array(value) {
        return whichTypedArray2(value) === "Float64Array";
      }
      exports.isFloat64Array = isFloat64Array;
      function isBigInt64Array(value) {
        return whichTypedArray2(value) === "BigInt64Array";
      }
      exports.isBigInt64Array = isBigInt64Array;
      function isBigUint64Array(value) {
        return whichTypedArray2(value) === "BigUint64Array";
      }
      exports.isBigUint64Array = isBigUint64Array;
      function isMapToString(value) {
        return ObjectToString(value) === "[object Map]";
      }
      isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
      function isMap(value) {
        if (typeof Map === "undefined") {
          return false;
        }
        return isMapToString.working ? isMapToString(value) : value instanceof Map;
      }
      exports.isMap = isMap;
      function isSetToString(value) {
        return ObjectToString(value) === "[object Set]";
      }
      isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
      function isSet(value) {
        if (typeof Set === "undefined") {
          return false;
        }
        return isSetToString.working ? isSetToString(value) : value instanceof Set;
      }
      exports.isSet = isSet;
      function isWeakMapToString(value) {
        return ObjectToString(value) === "[object WeakMap]";
      }
      isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
      function isWeakMap(value) {
        if (typeof WeakMap === "undefined") {
          return false;
        }
        return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
      }
      exports.isWeakMap = isWeakMap;
      function isWeakSetToString(value) {
        return ObjectToString(value) === "[object WeakSet]";
      }
      isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
      function isWeakSet(value) {
        return isWeakSetToString(value);
      }
      exports.isWeakSet = isWeakSet;
      function isArrayBufferToString(value) {
        return ObjectToString(value) === "[object ArrayBuffer]";
      }
      isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
      function isArrayBuffer(value) {
        if (typeof ArrayBuffer === "undefined") {
          return false;
        }
        return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
      }
      exports.isArrayBuffer = isArrayBuffer;
      function isDataViewToString(value) {
        return ObjectToString(value) === "[object DataView]";
      }
      isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
      function isDataView(value) {
        if (typeof DataView === "undefined") {
          return false;
        }
        return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
      }
      exports.isDataView = isDataView;
      var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
      function isSharedArrayBufferToString(value) {
        return ObjectToString(value) === "[object SharedArrayBuffer]";
      }
      function isSharedArrayBuffer(value) {
        if (typeof SharedArrayBufferCopy === "undefined") {
          return false;
        }
        if (typeof isSharedArrayBufferToString.working === "undefined") {
          isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
        }
        return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
      }
      exports.isSharedArrayBuffer = isSharedArrayBuffer;
      function isAsyncFunction(value) {
        return ObjectToString(value) === "[object AsyncFunction]";
      }
      exports.isAsyncFunction = isAsyncFunction;
      function isMapIterator(value) {
        return ObjectToString(value) === "[object Map Iterator]";
      }
      exports.isMapIterator = isMapIterator;
      function isSetIterator(value) {
        return ObjectToString(value) === "[object Set Iterator]";
      }
      exports.isSetIterator = isSetIterator;
      function isGeneratorObject(value) {
        return ObjectToString(value) === "[object Generator]";
      }
      exports.isGeneratorObject = isGeneratorObject;
      function isWebAssemblyCompiledModule(value) {
        return ObjectToString(value) === "[object WebAssembly.Module]";
      }
      exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
      function isNumberObject(value) {
        return checkBoxedPrimitive(value, numberValue);
      }
      exports.isNumberObject = isNumberObject;
      function isStringObject(value) {
        return checkBoxedPrimitive(value, stringValue);
      }
      exports.isStringObject = isStringObject;
      function isBooleanObject(value) {
        return checkBoxedPrimitive(value, booleanValue);
      }
      exports.isBooleanObject = isBooleanObject;
      function isBigIntObject(value) {
        return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
      }
      exports.isBigIntObject = isBigIntObject;
      function isSymbolObject(value) {
        return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
      }
      exports.isSymbolObject = isSymbolObject;
      function isBoxedPrimitive(value) {
        return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
      }
      exports.isBoxedPrimitive = isBoxedPrimitive;
      function isAnyArrayBuffer(value) {
        return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
      }
      exports.isAnyArrayBuffer = isAnyArrayBuffer;
      ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
        Object.defineProperty(exports, method, {
          enumerable: false,
          value: function() {
            throw new Error(method + " is not supported in userland");
          }
        });
      });
    })(types);
    return types;
  }
  var isBufferBrowser;
  var hasRequiredIsBufferBrowser;
  function requireIsBufferBrowser() {
    if (hasRequiredIsBufferBrowser)
      return isBufferBrowser;
    hasRequiredIsBufferBrowser = 1;
    isBufferBrowser = function isBuffer(arg) {
      return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
    };
    return isBufferBrowser;
  }
  var hasRequiredUtil;
  function requireUtil() {
    if (hasRequiredUtil)
      return util;
    hasRequiredUtil = 1;
    (function(exports) {
      var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
        var keys = Object.keys(obj);
        var descriptors = {};
        for (var i = 0; i < keys.length; i++) {
          descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
        }
        return descriptors;
      };
      var formatRegExp = /%[sdj%]/g;
      exports.format = function(f) {
        if (!isString(f)) {
          var objects = [];
          for (var i = 0; i < arguments.length; i++) {
            objects.push(inspect(arguments[i]));
          }
          return objects.join(" ");
        }
        var i = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function(x2) {
          if (x2 === "%%")
            return "%";
          if (i >= len)
            return x2;
          switch (x2) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return "[Circular]";
              }
            default:
              return x2;
          }
        });
        for (var x = args[i]; i < len; x = args[++i]) {
          if (isNull(x) || !isObject(x)) {
            str += " " + x;
          } else {
            str += " " + inspect(x);
          }
        }
        return str;
      };
      exports.deprecate = function(fn, msg) {
        if (typeof process$1 !== "undefined" && process$1.noDeprecation === true) {
          return fn;
        }
        if (typeof process$1 === "undefined") {
          return function() {
            return exports.deprecate(fn, msg).apply(this, arguments);
          };
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (process$1.throwDeprecation) {
              throw new Error(msg);
            } else if (process$1.traceDeprecation) {
              console.trace(msg);
            } else {
              console.error(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      };
      var debugs = {};
      var debugEnvRegex = /^$/;
      if (process$1.env.NODE_DEBUG) {
        var debugEnv = process$1.env.NODE_DEBUG;
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
        debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
      }
      exports.debuglog = function(set) {
        set = set.toUpperCase();
        if (!debugs[set]) {
          if (debugEnvRegex.test(set)) {
            var pid = process$1.pid;
            debugs[set] = function() {
              var msg = exports.format.apply(exports, arguments);
              console.error("%s %d: %s", set, pid, msg);
            };
          } else {
            debugs[set] = function() {
            };
          }
        }
        return debugs[set];
      };
      function inspect(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3)
          ctx.depth = arguments[2];
        if (arguments.length >= 4)
          ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          exports._extend(ctx, opts);
        }
        if (isUndefined(ctx.showHidden))
          ctx.showHidden = false;
        if (isUndefined(ctx.depth))
          ctx.depth = 2;
        if (isUndefined(ctx.colors))
          ctx.colors = false;
        if (isUndefined(ctx.customInspect))
          ctx.customInspect = true;
        if (ctx.colors)
          ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }
      exports.inspect = inspect;
      inspect.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        // "name": intentionally not styling
        "regexp": "red"
      };
      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];
        if (style) {
          return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
        } else {
          return str;
        }
      }
      function stylizeNoColor(str, styleType) {
        return str;
      }
      function arrayToHash(array) {
        var hash = {};
        array.forEach(function(val, idx) {
          hash[val] = true;
        });
        return hash;
      }
      function formatValue(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
        value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys = Object.keys(value);
        var visibleKeys = arrayToHash(keys);
        if (ctx.showHidden) {
          keys = Object.getOwnPropertyNames(value);
        }
        if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
          return formatError(value);
        }
        if (keys.length === 0) {
          if (isFunction(value)) {
            var name = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name + "]", "special");
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), "date");
          }
          if (isError(value)) {
            return formatError(value);
          }
        }
        var base = "", array = false, braces = ["{", "}"];
        if (isArray2(value)) {
          array = true;
          braces = ["[", "]"];
        }
        if (isFunction(value)) {
          var n = value.name ? ": " + value.name : "";
          base = " [Function" + n + "]";
        }
        if (isRegExp(value)) {
          base = " " + RegExp.prototype.toString.call(value);
        }
        if (isDate(value)) {
          base = " " + Date.prototype.toUTCString.call(value);
        }
        if (isError(value)) {
          base = " " + formatError(value);
        }
        if (keys.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          } else {
            return ctx.stylize("[Object]", "special");
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
        } else {
          output = keys.map(function(key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base, braces);
      }
      function formatPrimitive(ctx, value) {
        if (isUndefined(value))
          return ctx.stylize("undefined", "undefined");
        if (isString(value)) {
          var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return ctx.stylize(simple, "string");
        }
        if (isNumber(value))
          return ctx.stylize("" + value, "number");
        if (isBoolean(value))
          return ctx.stylize("" + value, "boolean");
        if (isNull(value))
          return ctx.stylize("null", "null");
      }
      function formatError(value) {
        return "[" + Error.prototype.toString.call(value) + "]";
      }
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
        var output = [];
        for (var i = 0, l = value.length; i < l; ++i) {
          if (hasOwnProperty2(value, String(i))) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              String(i),
              true
            ));
          } else {
            output.push("");
          }
        }
        keys.forEach(function(key) {
          if (!key.match(/^\d+$/)) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              key,
              true
            ));
          }
        });
        return output;
      }
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name, str, desc;
        desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize("[Getter/Setter]", "special");
          } else {
            str = ctx.stylize("[Getter]", "special");
          }
        } else {
          if (desc.set) {
            str = ctx.stylize("[Setter]", "special");
          }
        }
        if (!hasOwnProperty2(visibleKeys, key)) {
          name = "[" + key + "]";
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue(ctx, desc.value, null);
            } else {
              str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf("\n") > -1) {
              if (array) {
                str = str.split("\n").map(function(line) {
                  return "  " + line;
                }).join("\n").slice(2);
              } else {
                str = "\n" + str.split("\n").map(function(line) {
                  return "   " + line;
                }).join("\n");
              }
            }
          } else {
            str = ctx.stylize("[Circular]", "special");
          }
        }
        if (isUndefined(name)) {
          if (array && key.match(/^\d+$/)) {
            return str;
          }
          name = JSON.stringify("" + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.slice(1, -1);
            name = ctx.stylize(name, "name");
          } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, "string");
          }
        }
        return name + ": " + str;
      }
      function reduceToSingleString(output, base, braces) {
        var length = output.reduce(function(prev, cur) {
          if (cur.indexOf("\n") >= 0)
            ;
          return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
        }
        return braces[0] + base + " " + output.join(", ") + " " + braces[1];
      }
      exports.types = requireTypes();
      function isArray2(ar) {
        return Array.isArray(ar);
      }
      exports.isArray = isArray2;
      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      exports.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === "number";
      }
      exports.isNumber = isNumber;
      function isString(arg) {
        return typeof arg === "string";
      }
      exports.isString = isString;
      function isSymbol(arg) {
        return typeof arg === "symbol";
      }
      exports.isSymbol = isSymbol;
      function isUndefined(arg) {
        return arg === void 0;
      }
      exports.isUndefined = isUndefined;
      function isRegExp(re) {
        return isObject(re) && objectToString(re) === "[object RegExp]";
      }
      exports.isRegExp = isRegExp;
      exports.types.isRegExp = isRegExp;
      function isObject(arg) {
        return typeof arg === "object" && arg !== null;
      }
      exports.isObject = isObject;
      function isDate(d) {
        return isObject(d) && objectToString(d) === "[object Date]";
      }
      exports.isDate = isDate;
      exports.types.isDate = isDate;
      function isError(e) {
        return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
      }
      exports.isError = isError;
      exports.types.isNativeError = isError;
      function isFunction(arg) {
        return typeof arg === "function";
      }
      exports.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
        typeof arg === "undefined";
      }
      exports.isPrimitive = isPrimitive;
      exports.isBuffer = requireIsBufferBrowser();
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
      function pad(n) {
        return n < 10 ? "0" + n.toString(10) : n.toString(10);
      }
      var months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      function timestamp() {
        var d = /* @__PURE__ */ new Date();
        var time = [
          pad(d.getHours()),
          pad(d.getMinutes()),
          pad(d.getSeconds())
        ].join(":");
        return [d.getDate(), months[d.getMonth()], time].join(" ");
      }
      exports.log = function() {
        console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
      };
      exports.inherits = inherits_browserExports;
      exports._extend = function(origin, add) {
        if (!add || !isObject(add))
          return origin;
        var keys = Object.keys(add);
        var i = keys.length;
        while (i--) {
          origin[keys[i]] = add[keys[i]];
        }
        return origin;
      };
      function hasOwnProperty2(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
      exports.promisify = function promisify(original) {
        if (typeof original !== "function")
          throw new TypeError('The "original" argument must be of type Function');
        if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
          var fn = original[kCustomPromisifiedSymbol];
          if (typeof fn !== "function") {
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          }
          Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
          });
          return fn;
        }
        function fn() {
          var promiseResolve, promiseReject;
          var promise = new Promise(function(resolve2, reject) {
            promiseResolve = resolve2;
            promiseReject = reject;
          });
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          args.push(function(err, value) {
            if (err) {
              promiseReject(err);
            } else {
              promiseResolve(value);
            }
          });
          try {
            original.apply(this, args);
          } catch (err) {
            promiseReject(err);
          }
          return promise;
        }
        Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
        if (kCustomPromisifiedSymbol)
          Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
          });
        return Object.defineProperties(
          fn,
          getOwnPropertyDescriptors(original)
        );
      };
      exports.promisify.custom = kCustomPromisifiedSymbol;
      function callbackifyOnRejected(reason, cb) {
        if (!reason) {
          var newReason = new Error("Promise was rejected with a falsy value");
          newReason.reason = reason;
          reason = newReason;
        }
        return cb(reason);
      }
      function callbackify(original) {
        if (typeof original !== "function") {
          throw new TypeError('The "original" argument must be of type Function');
        }
        function callbackified() {
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          var maybeCb = args.pop();
          if (typeof maybeCb !== "function") {
            throw new TypeError("The last argument must be of type Function");
          }
          var self2 = this;
          var cb = function() {
            return maybeCb.apply(self2, arguments);
          };
          original.apply(this, args).then(
            function(ret) {
              process$1.nextTick(cb.bind(null, null, ret));
            },
            function(rej) {
              process$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));
            }
          );
        }
        Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
        Object.defineProperties(
          callbackified,
          getOwnPropertyDescriptors(original)
        );
        return callbackified;
      }
      exports.callbackify = callbackify;
    })(util);
    return util;
  }
  var buffer_list;
  var hasRequiredBuffer_list;
  function requireBuffer_list() {
    if (hasRequiredBuffer_list)
      return buffer_list;
    hasRequiredBuffer_list = 1;
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var _require = requireBuffer(), Buffer2 = _require.Buffer;
    var _require2 = requireUtil(), inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src2, target, offset) {
      Buffer2.prototype.copy.call(src2, target, offset);
    }
    buffer_list = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) {
            ret += s + p.data;
          }
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options2) {
          return inspect(this, _objectSpread({}, options2, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
    return buffer_list;
  }
  var destroy_1;
  var hasRequiredDestroy;
  function requireDestroy() {
    if (hasRequiredDestroy)
      return destroy_1;
    hasRequiredDestroy = 1;
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process$1.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process$1.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process$1.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process$1.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process$1.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process$1.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process$1.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    destroy_1 = {
      destroy,
      undestroy,
      errorOrDestroy
    };
    return destroy_1;
  }
  var errorsBrowser = {};
  var hasRequiredErrorsBrowser;
  function requireErrorsBrowser() {
    if (hasRequiredErrorsBrowser)
      return errorsBrowser;
    hasRequiredErrorsBrowser = 1;
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = /* @__PURE__ */ function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    errorsBrowser.codes = codes;
    return errorsBrowser;
  }
  var state;
  var hasRequiredState;
  function requireState() {
    if (hasRequiredState)
      return state;
    hasRequiredState = 1;
    var ERR_INVALID_OPT_VALUE = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options2, isDuplex, duplexKey) {
      return options2.highWaterMark != null ? options2.highWaterMark : isDuplex ? options2[duplexKey] : null;
    }
    function getHighWaterMark(state2, options2, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options2, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state2.objectMode ? 16 : 16 * 1024;
    }
    state = {
      getHighWaterMark
    };
    return state;
  }
  var browser;
  var hasRequiredBrowser;
  function requireBrowser() {
    if (hasRequiredBrowser)
      return browser;
    hasRequiredBrowser = 1;
    browser = deprecate;
    function deprecate(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name) {
      try {
        if (!commonjsGlobal.localStorage)
          return false;
      } catch (_) {
        return false;
      }
      var val = commonjsGlobal.localStorage[name];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
    return browser;
  }
  var _stream_writable;
  var hasRequired_stream_writable;
  function require_stream_writable() {
    if (hasRequired_stream_writable)
      return _stream_writable;
    hasRequired_stream_writable = 1;
    _stream_writable = Writable;
    function CorkedRequest(state2) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state2);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: requireBrowser()
    };
    var Stream2 = requireStreamBrowser();
    var Buffer2 = requireBuffer().Buffer;
    var OurUint8Array = commonjsGlobal.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = requireDestroy();
    var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    inherits_browserExports(Writable, Stream2);
    function nop() {
    }
    function WritableState(options2, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options2 = options2 || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options2.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options2.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options2, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options2.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options2.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options2.emitClose !== false;
      this.autoDestroy = !!options2.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options2) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options2);
      this._writableState = new WritableState(options2, this, isDuplex);
      this.writable = true;
      if (options2) {
        if (typeof options2.write === "function")
          this._write = options2.write;
        if (typeof options2.writev === "function")
          this._writev = options2.writev;
        if (typeof options2.destroy === "function")
          this._destroy = options2.destroy;
        if (typeof options2.final === "function")
          this._final = options2.final;
      }
      Stream2.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process$1.nextTick(cb, er);
    }
    function validChunk(stream, state2, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state2.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process$1.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state2 = this._writableState;
      var ret = false;
      var isBuf = !state2.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state2.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state2.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state2, chunk, cb)) {
        state2.pendingcb++;
        ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state2 = this._writableState;
      if (state2.corked) {
        state2.corked--;
        if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest)
          clearBuffer(this, state2);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state2, chunk, encoding) {
      if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state2, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state2, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state2.objectMode ? 1 : chunk.length;
      state2.length += len;
      var ret = state2.length < state2.highWaterMark;
      if (!ret)
        state2.needDrain = true;
      if (state2.writing || state2.corked) {
        var last = state2.lastBufferedRequest;
        state2.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state2.lastBufferedRequest;
        } else {
          state2.bufferedRequest = state2.lastBufferedRequest;
        }
        state2.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state2, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state2, writev, len, chunk, encoding, cb) {
      state2.writelen = len;
      state2.writecb = cb;
      state2.writing = true;
      state2.sync = true;
      if (state2.destroyed)
        state2.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state2.onwrite);
      else
        stream._write(chunk, encoding, state2.onwrite);
      state2.sync = false;
    }
    function onwriteError(stream, state2, sync, er, cb) {
      --state2.pendingcb;
      if (sync) {
        process$1.nextTick(cb, er);
        process$1.nextTick(finishMaybe, stream, state2);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state2);
      }
    }
    function onwriteStateUpdate(state2) {
      state2.writing = false;
      state2.writecb = null;
      state2.length -= state2.writelen;
      state2.writelen = 0;
    }
    function onwrite(stream, er) {
      var state2 = stream._writableState;
      var sync = state2.sync;
      var cb = state2.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state2);
      if (er)
        onwriteError(stream, state2, sync, er, cb);
      else {
        var finished = needFinish(state2) || stream.destroyed;
        if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
          clearBuffer(stream, state2);
        }
        if (sync) {
          process$1.nextTick(afterWrite, stream, state2, finished, cb);
        } else {
          afterWrite(stream, state2, finished, cb);
        }
      }
    }
    function afterWrite(stream, state2, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state2);
      state2.pendingcb--;
      cb();
      finishMaybe(stream, state2);
    }
    function onwriteDrain(stream, state2) {
      if (state2.length === 0 && state2.needDrain) {
        state2.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state2) {
      state2.bufferProcessing = true;
      var entry = state2.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state2.bufferedRequestCount;
        var buffer2 = new Array(l);
        var holder = state2.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer2[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer2.allBuffers = allBuffers;
        doWrite(stream, state2, true, state2.length, buffer2, "", holder.finish);
        state2.pendingcb++;
        state2.lastBufferedRequest = null;
        if (holder.next) {
          state2.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state2.corkedRequestsFree = new CorkedRequest(state2);
        }
        state2.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state2.objectMode ? 1 : chunk.length;
          doWrite(stream, state2, false, len, chunk, encoding, cb);
          entry = entry.next;
          state2.bufferedRequestCount--;
          if (state2.writing) {
            break;
          }
        }
        if (entry === null)
          state2.lastBufferedRequest = null;
      }
      state2.bufferedRequest = entry;
      state2.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state2 = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state2.corked) {
        state2.corked = 1;
        this.uncork();
      }
      if (!state2.ending)
        endWritable(this, state2, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state2) {
      return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
    }
    function callFinal(stream, state2) {
      stream._final(function(err) {
        state2.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state2.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state2);
      });
    }
    function prefinish(stream, state2) {
      if (!state2.prefinished && !state2.finalCalled) {
        if (typeof stream._final === "function" && !state2.destroyed) {
          state2.pendingcb++;
          state2.finalCalled = true;
          process$1.nextTick(callFinal, stream, state2);
        } else {
          state2.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state2) {
      var need = needFinish(state2);
      if (need) {
        prefinish(stream, state2);
        if (state2.pendingcb === 0) {
          state2.finished = true;
          stream.emit("finish");
          if (state2.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state2, cb) {
      state2.ending = true;
      finishMaybe(stream, state2);
      if (cb) {
        if (state2.finished)
          process$1.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state2.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state2, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state2.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state2.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    return _stream_writable;
  }
  var _stream_duplex;
  var hasRequired_stream_duplex;
  function require_stream_duplex() {
    if (hasRequired_stream_duplex)
      return _stream_duplex;
    hasRequired_stream_duplex = 1;
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    _stream_duplex = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    inherits_browserExports(Duplex, Readable);
    {
      var keys = objectKeys(Writable.prototype);
      for (var v = 0; v < keys.length; v++) {
        var method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    function Duplex(options2) {
      if (!(this instanceof Duplex))
        return new Duplex(options2);
      Readable.call(this, options2);
      Writable.call(this, options2);
      this.allowHalfOpen = true;
      if (options2) {
        if (options2.readable === false)
          this.readable = false;
        if (options2.writable === false)
          this.writable = false;
        if (options2.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process$1.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    return _stream_duplex;
  }
  var string_decoder = {};
  var safeBuffer = { exports: {} };
  var hasRequiredSafeBuffer;
  function requireSafeBuffer() {
    if (hasRequiredSafeBuffer)
      return safeBuffer.exports;
    hasRequiredSafeBuffer = 1;
    (function(module, exports) {
      var buffer2 = requireBuffer();
      var Buffer2 = buffer2.Buffer;
      function copyProps(src2, dst) {
        for (var key in src2) {
          dst[key] = src2[key];
        }
      }
      if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
        module.exports = buffer2;
      } else {
        copyProps(buffer2, exports);
        exports.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer2(arg, encodingOrOffset, length);
      }
      copyProps(Buffer2, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer2(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer2(size);
        if (fill !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer2(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer2.SlowBuffer(size);
      };
    })(safeBuffer, safeBuffer.exports);
    return safeBuffer.exports;
  }
  var hasRequiredString_decoder;
  function requireString_decoder() {
    if (hasRequiredString_decoder)
      return string_decoder;
    hasRequiredString_decoder = 1;
    var Buffer2 = requireSafeBuffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    string_decoder.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
    return string_decoder;
  }
  var endOfStream;
  var hasRequiredEndOfStream;
  function requireEndOfStream() {
    if (hasRequiredEndOfStream)
      return endOfStream;
    hasRequiredEndOfStream = 1;
    var ERR_STREAM_PREMATURE_CLOSE = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once3(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop2() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once3(callback || noop2);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    endOfStream = eos;
    return endOfStream;
  }
  var async_iterator;
  var hasRequiredAsync_iterator;
  function requireAsync_iterator() {
    if (hasRequiredAsync_iterator)
      return async_iterator;
    hasRequiredAsync_iterator = 1;
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var finished = requireEndOfStream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve2 = iter[kLastResolve];
      if (resolve2 !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve2(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process$1.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve2, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve2(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve2, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve2, reject) {
            process$1.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve2(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve2, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve2(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve2, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve2(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve2;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve2 = iterator[kLastResolve];
        if (resolve2 !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve2(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    async_iterator = createReadableStreamAsyncIterator;
    return async_iterator;
  }
  var fromBrowser;
  var hasRequiredFromBrowser;
  function requireFromBrowser() {
    if (hasRequiredFromBrowser)
      return fromBrowser;
    hasRequiredFromBrowser = 1;
    fromBrowser = function() {
      throw new Error("Readable.from is not available in the browser");
    };
    return fromBrowser;
  }
  var _stream_readable;
  var hasRequired_stream_readable;
  function require_stream_readable() {
    if (hasRequired_stream_readable)
      return _stream_readable;
    hasRequired_stream_readable = 1;
    _stream_readable = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    eventsExports.EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream2 = requireStreamBrowser();
    var Buffer2 = requireBuffer().Buffer;
    var OurUint8Array = commonjsGlobal.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = requireUtil();
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = requireBuffer_list();
    var destroyImpl = requireDestroy();
    var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    inherits_browserExports(Readable, Stream2);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener2(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options2, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options2 = options2 || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options2.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options2.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options2, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options2.emitClose !== false;
      this.autoDestroy = !!options2.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options2.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options2.encoding) {
        if (!StringDecoder)
          StringDecoder = requireString_decoder().StringDecoder;
        this.decoder = new StringDecoder(options2.encoding);
        this.encoding = options2.encoding;
      }
    }
    function Readable(options2) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options2);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options2, this, isDuplex);
      this.readable = true;
      if (options2) {
        if (typeof options2.read === "function")
          this._read = options2.read;
        if (typeof options2.destroy === "function")
          this._destroy = options2.destroy;
      }
      Stream2.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state2 = this._readableState;
      var skipChunkCheck;
      if (!state2.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state2.defaultEncoding;
          if (encoding !== state2.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state2 = stream._readableState;
      if (chunk === null) {
        state2.reading = false;
        onEofChunk(stream, state2);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state2, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state2.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state2.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state2, chunk, true);
          } else if (state2.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state2.destroyed) {
            return false;
          } else {
            state2.reading = false;
            if (state2.decoder && !encoding) {
              chunk = state2.decoder.write(chunk);
              if (state2.objectMode || chunk.length !== 0)
                addChunk(stream, state2, chunk, false);
              else
                maybeReadMore(stream, state2);
            } else {
              addChunk(stream, state2, chunk, false);
            }
          }
        } else if (!addToFront) {
          state2.reading = false;
          maybeReadMore(stream, state2);
        }
      }
      return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
    }
    function addChunk(stream, state2, chunk, addToFront) {
      if (state2.flowing && state2.length === 0 && !state2.sync) {
        state2.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state2.length += state2.objectMode ? 1 : chunk.length;
        if (addToFront)
          state2.buffer.unshift(chunk);
        else
          state2.buffer.push(chunk);
        if (state2.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state2);
    }
    function chunkInvalid(state2, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = requireString_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state2) {
      if (n <= 0 || state2.length === 0 && state2.ended)
        return 0;
      if (state2.objectMode)
        return 1;
      if (n !== n) {
        if (state2.flowing && state2.length)
          return state2.buffer.head.data.length;
        else
          return state2.length;
      }
      if (n > state2.highWaterMark)
        state2.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state2.length)
        return n;
      if (!state2.ended) {
        state2.needReadable = true;
        return 0;
      }
      return state2.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state2 = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state2.emittedReadable = false;
      if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
        debug("read: emitReadable", state2.length, state2.ended);
        if (state2.length === 0 && state2.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state2);
      if (n === 0 && state2.ended) {
        if (state2.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state2.needReadable;
      debug("need readable", doRead);
      if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state2.ended || state2.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state2.reading = true;
        state2.sync = true;
        if (state2.length === 0)
          state2.needReadable = true;
        this._read(state2.highWaterMark);
        state2.sync = false;
        if (!state2.reading)
          n = howMuchToRead(nOrig, state2);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state2);
      else
        ret = null;
      if (ret === null) {
        state2.needReadable = state2.length <= state2.highWaterMark;
        n = 0;
      } else {
        state2.length -= n;
        state2.awaitDrain = 0;
      }
      if (state2.length === 0) {
        if (!state2.ended)
          state2.needReadable = true;
        if (nOrig !== n && state2.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state2) {
      debug("onEofChunk");
      if (state2.ended)
        return;
      if (state2.decoder) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) {
          state2.buffer.push(chunk);
          state2.length += state2.objectMode ? 1 : chunk.length;
        }
      }
      state2.ended = true;
      if (state2.sync) {
        emitReadable(stream);
      } else {
        state2.needReadable = false;
        if (!state2.emittedReadable) {
          state2.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state2 = stream._readableState;
      debug("emitReadable", state2.needReadable, state2.emittedReadable);
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        debug("emitReadable", state2.flowing);
        state2.emittedReadable = true;
        process$1.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state2 = stream._readableState;
      debug("emitReadable_", state2.destroyed, state2.length, state2.ended);
      if (!state2.destroyed && (state2.length || state2.ended)) {
        stream.emit("readable");
        state2.emittedReadable = false;
      }
      state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state2) {
      if (!state2.readingMore) {
        state2.readingMore = true;
        process$1.nextTick(maybeReadMore_, stream, state2);
      }
    }
    function maybeReadMore_(stream, state2) {
      while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
        var len = state2.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state2.length)
          break;
      }
      state2.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src2 = this;
      var state2 = this._readableState;
      switch (state2.pipesCount) {
        case 0:
          state2.pipes = dest;
          break;
        case 1:
          state2.pipes = [state2.pipes, dest];
          break;
        default:
          state2.pipes.push(dest);
          break;
      }
      state2.pipesCount += 1;
      debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state2.endEmitted)
        process$1.nextTick(endFn);
      else
        src2.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src2) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src2);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src2.removeListener("end", onend);
        src2.removeListener("end", unpipe);
        src2.removeListener("data", ondata);
        cleanedUp = true;
        if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src2.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf2(state2.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state2.awaitDrain);
            state2.awaitDrain++;
          }
          src2.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src2.unpipe(dest);
      }
      dest.emit("pipe", src2);
      if (!state2.flowing) {
        debug("pipe resume");
        src2.resume();
      }
      return dest;
    };
    function pipeOnDrain(src2) {
      return function pipeOnDrainFunctionResult() {
        var state2 = src2._readableState;
        debug("pipeOnDrain", state2.awaitDrain);
        if (state2.awaitDrain)
          state2.awaitDrain--;
        if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
          state2.flowing = true;
          flow(src2);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state2 = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state2.pipesCount === 0)
        return this;
      if (state2.pipesCount === 1) {
        if (dest && dest !== state2.pipes)
          return this;
        if (!dest)
          dest = state2.pipes;
        state2.pipes = null;
        state2.pipesCount = 0;
        state2.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state2.pipes;
        var len = state2.pipesCount;
        state2.pipes = null;
        state2.pipesCount = 0;
        state2.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        }
        return this;
      }
      var index = indexOf2(state2.pipes, dest);
      if (index === -1)
        return this;
      state2.pipes.splice(index, 1);
      state2.pipesCount -= 1;
      if (state2.pipesCount === 1)
        state2.pipes = state2.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream2.prototype.on.call(this, ev, fn);
      var state2 = this._readableState;
      if (ev === "data") {
        state2.readableListening = this.listenerCount("readable") > 0;
        if (state2.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state2.endEmitted && !state2.readableListening) {
          state2.readableListening = state2.needReadable = true;
          state2.flowing = false;
          state2.emittedReadable = false;
          debug("on readable", state2.length, state2.reading);
          if (state2.length) {
            emitReadable(this);
          } else if (!state2.reading) {
            process$1.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream2.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process$1.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process$1.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state2 = self2._readableState;
      state2.readableListening = self2.listenerCount("readable") > 0;
      if (state2.resumeScheduled && !state2.paused) {
        state2.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state2 = this._readableState;
      if (!state2.flowing) {
        debug("resume");
        state2.flowing = !state2.readableListening;
        resume(this, state2);
      }
      state2.paused = false;
      return this;
    };
    function resume(stream, state2) {
      if (!state2.resumeScheduled) {
        state2.resumeScheduled = true;
        process$1.nextTick(resume_, stream, state2);
      }
    }
    function resume_(stream, state2) {
      debug("resume", state2.reading);
      if (!state2.reading) {
        stream.read(0);
      }
      state2.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state2.flowing && !state2.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state2 = stream._readableState;
      debug("flow", state2.flowing);
      while (state2.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state2 = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state2.decoder && !state2.ended) {
          var chunk = state2.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state2.decoder)
          chunk = state2.decoder.write(chunk);
        if (state2.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state2.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = requireAsync_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state2) {
        if (this._readableState) {
          this._readableState.flowing = state2;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state2) {
      if (state2.length === 0)
        return null;
      var ret;
      if (state2.objectMode)
        ret = state2.buffer.shift();
      else if (!n || n >= state2.length) {
        if (state2.decoder)
          ret = state2.buffer.join("");
        else if (state2.buffer.length === 1)
          ret = state2.buffer.first();
        else
          ret = state2.buffer.concat(state2.length);
        state2.buffer.clear();
      } else {
        ret = state2.buffer.consume(n, state2.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state2 = stream._readableState;
      debug("endReadable", state2.endEmitted);
      if (!state2.endEmitted) {
        state2.ended = true;
        process$1.nextTick(endReadableNT, state2, stream);
      }
    }
    function endReadableNT(state2, stream) {
      debug("endReadableNT", state2.endEmitted, state2.length);
      if (!state2.endEmitted && state2.length === 0) {
        state2.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state2.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = requireFromBrowser();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf2(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
    return _stream_readable;
  }
  var _stream_transform;
  var hasRequired_stream_transform;
  function require_stream_transform() {
    if (hasRequired_stream_transform)
      return _stream_transform;
    hasRequired_stream_transform = 1;
    _stream_transform = Transform;
    var _require$codes = requireErrorsBrowser().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    inherits_browserExports(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options2) {
      if (!(this instanceof Transform))
        return new Transform(options2);
      Duplex.call(this, options2);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options2) {
        if (typeof options2.transform === "function")
          this._transform = options2.transform;
        if (typeof options2.flush === "function")
          this._flush = options2.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
    return _stream_transform;
  }
  var _stream_passthrough;
  var hasRequired_stream_passthrough;
  function require_stream_passthrough() {
    if (hasRequired_stream_passthrough)
      return _stream_passthrough;
    hasRequired_stream_passthrough = 1;
    _stream_passthrough = PassThrough;
    var Transform = require_stream_transform();
    inherits_browserExports(PassThrough, Transform);
    function PassThrough(options2) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options2);
      Transform.call(this, options2);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
    return _stream_passthrough;
  }
  var pipeline_1;
  var hasRequiredPipeline;
  function requirePipeline() {
    if (hasRequiredPipeline)
      return pipeline_1;
    hasRequiredPipeline = 1;
    var eos;
    function once3(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = requireErrorsBrowser().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop2(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once3(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = requireEndOfStream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe2(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop2;
      if (typeof streams[streams.length - 1] !== "function")
        return noop2;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe2);
    }
    pipeline_1 = pipeline;
    return pipeline_1;
  }
  var streamBrowserify = Stream$1;
  var EE = eventsExports.EventEmitter;
  var inherits = inherits_browserExports;
  inherits(Stream$1, EE);
  Stream$1.Readable = require_stream_readable();
  Stream$1.Writable = require_stream_writable();
  Stream$1.Duplex = require_stream_duplex();
  Stream$1.Transform = require_stream_transform();
  Stream$1.PassThrough = require_stream_passthrough();
  Stream$1.finished = requireEndOfStream();
  Stream$1.pipeline = requirePipeline();
  Stream$1.Stream = Stream$1;
  function Stream$1() {
    EE.call(this);
  }
  Stream$1.prototype.pipe = function(dest, options2) {
    var source = this;
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }
    source.on("data", ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options2 || options2.end !== false)) {
      source.on("end", onend);
      source.on("close", onclose);
    }
    var didOnEnd = false;
    function onend() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      if (typeof dest.destroy === "function")
        dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this, "error") === 0) {
        throw er;
      }
    }
    source.on("error", onerror);
    dest.on("error", onerror);
    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
  };
  (function(exports) {
    (function(sax2) {
      sax2.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax2.SAXParser = SAXParser;
      sax2.SAXStream = SAXStream;
      sax2.createStream = createStream;
      sax2.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax2.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax2.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax2.XML_ENTITIES) : Object.create(sax2.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit2(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F() {
          }
          F.prototype = o;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i in o)
            if (o.hasOwnProperty(i))
              a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax2.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax2.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++) {
          parser[buffers[i]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream2;
      try {
        Stream2 = streamBrowserify.Stream;
      } catch (ex) {
        Stream2 = function() {
        };
      }
      var streamWraps = sax2.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream2.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h) {
              if (!h) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h;
                return h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream2.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            var SD = requireString_decoder().StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream2.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S = 0;
      sax2.STATE = {
        BEGIN: S++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S++,
        // leading whitespace
        TEXT: S++,
        // general stuff
        TEXT_ENTITY: S++,
        // &amp and such.
        OPEN_WAKA: S++,
        // <
        SGML_DECL: S++,
        // <!BLARG
        SGML_DECL_QUOTED: S++,
        // <!BLARG foo "bar
        DOCTYPE: S++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S++,
        // <!-
        COMMENT: S++,
        // <!--
        COMMENT_ENDING: S++,
        // <!-- blah -
        COMMENT_ENDED: S++,
        // <!-- blah --
        CDATA: S++,
        // <![CDATA[ something
        CDATA_ENDING: S++,
        // ]
        CDATA_ENDING_2: S++,
        // ]]
        PROC_INST: S++,
        // <?hi
        PROC_INST_BODY: S++,
        // <?hi there
        PROC_INST_ENDING: S++,
        // <?hi "there" ?
        OPEN_TAG: S++,
        // <strong
        OPEN_TAG_SLASH: S++,
        // <strong /
        ATTRIB: S++,
        // <a
        ATTRIB_NAME: S++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S++,
        // <a foo _
        ATTRIB_VALUE: S++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S++,
        // <foo bar=&quot
        CLOSE_TAG: S++,
        // </a
        CLOSE_TAG_SAW_WHITE: S++,
        // </a   >
        SCRIPT: S++,
        // <script> ...
        SCRIPT_ENDING: S++
        // <script> ... <
      };
      sax2.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax2.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax2.ENTITIES).forEach(function(key) {
        var e = sax2.ENTITIES[key];
        var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax2.ENTITIES[key] = s2;
      });
      for (var s in sax2.STATE) {
        sax2.STATE[sax2.STATE[s]] = s;
      }
      S = sax2.STATE;
      function emit2(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode)
          closeText(parser);
        emit2(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode)
          emit2(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim)
          text = text.trim();
        if (opt.normalize)
          text = text.replace(/\s+/g, " ");
        return text;
      }
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit2(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot)
          strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
          error(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit2(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict)
          parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute2) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute2 && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i = 0, l = parser.attribList.length; i < l; i++) {
            var nv = parser.attribList[i];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S.SCRIPT;
          } else {
            parser.state = S.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s2 = parser.tags.length;
        while (s2-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i in tag.ns) {
            x[i] = tag.ns[i];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t === 0)
          parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) {
          result = chunk.charAt(i);
        }
        return result;
      }
      function write(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser.state = S.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S.SCRIPT:
              if (c === "<") {
                parser.state = S.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === "!") {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c))
                ;
              else if (isMatch(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if (parser.sgmlDecl + c === "--") {
                parser.state = S.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S.TEXT;
              } else if (isQuote(c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === ">") {
                parser.state = S.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") {
                  parser.state = S.DOCTYPE_DTD;
                } else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              parser.doctype += c;
              if (c === "]") {
                parser.state = S.DOCTYPE;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S.COMMENT:
              if (c === "-") {
                parser.state = S.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S.COMMENT;
              } else {
                parser.state = S.TEXT;
              }
              continue;
            case S.CDATA:
              if (c === "]") {
                parser.state = S.CDATA_ENDING;
              } else {
                parser.cdata += c;
              }
              continue;
            case S.CDATA_ENDING:
              if (c === "]") {
                parser.state = S.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else if (isWhitespace(c)) {
                parser.state = S.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c)) {
                continue;
              } else if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (isWhitespace(c)) {
                continue;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c)) {
                parser.state = S.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (isWhitespace(c)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace(c)) {
                continue;
              } else if (isQuote(c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                strictFail(parser, "Unquoted attribute value");
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c)) {
                parser.state = S.ATTRIB;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === ">") {
                openTag(parser);
              } else {
                parser.state = S.ATTRIB;
              }
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S.SCRIPT;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer2;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer2 = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer2 = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer2 = "attribValue";
                  break;
              }
              if (c === ";") {
                parser[buffer2] += parseEntity(parser);
                parser.entity = "";
                parser.state = returnState;
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer2] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default:
              throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 || // not a valid Unicode code point
              codePoint > 1114111 || // not a valid Unicode code point
              floor(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(exports);
  })(sax$1);
  var arrayHelper = {
    isArray: function(value) {
      if (Array.isArray) {
        return Array.isArray(value);
      }
      return Object.prototype.toString.call(value) === "[object Array]";
    }
  };
  var isArray$2 = arrayHelper.isArray;
  var isArray$1 = arrayHelper.isArray;
  var isArray = arrayHelper.isArray;
  var decimalNumber = (val) => {
    if (isNaN(val)) {
      throw new Error(`Invalid value '${val}' specified. Must be an integer.`);
    }
    return Math.floor(val);
  };
  var unsignedDecimalNumber = (val) => {
    const value = decimalNumber(val);
    if (value < 0) {
      throw new Error(`Invalid value '${val}' specified. Must be a positive integer.`);
    }
    return value;
  };
  var hexBinary = (val, length) => {
    const expectedLength = length * 2;
    if (val.length !== expectedLength || isNaN(Number(`0x${val}`))) {
      throw new Error(`Invalid hex value '${val}'. Expected ${expectedLength} digit hex value`);
    }
    return val;
  };
  var hexColorValue = (val) => {
    if (val === "auto") {
      return val;
    }
    const color = val.charAt(0) === "#" ? val.substring(1) : val;
    return hexBinary(color, 3);
  };
  var eighthPointMeasureValue = unsignedDecimalNumber;
  var pointMeasureValue = unsignedDecimalNumber;
  var BorderElement = class extends XmlComponent {
    constructor(elementName, { color, size, space, style }) {
      super(elementName);
      this.root.push(
        new BordersAttributes({
          style,
          color: color === void 0 ? void 0 : hexColorValue(color),
          size: size === void 0 ? void 0 : eighthPointMeasureValue(size),
          space: space === void 0 ? void 0 : pointMeasureValue(space)
        })
      );
    }
  };
  var BordersAttributes = class extends XmlAttributeComponent {
    constructor() {
      super(...arguments);
      __publicField(this, "xmlKeys", {
        style: "w:val",
        color: "w:color",
        size: "w:sz",
        space: "w:space"
      });
    }
  };
  var BorderStyle = /* @__PURE__ */ ((BorderStyle2) => {
    BorderStyle2["SINGLE"] = "single";
    BorderStyle2["DASH_DOT_STROKED"] = "dashDotStroked";
    BorderStyle2["DASHED"] = "dashed";
    BorderStyle2["DASH_SMALL_GAP"] = "dashSmallGap";
    BorderStyle2["DOT_DASH"] = "dotDash";
    BorderStyle2["DOT_DOT_DASH"] = "dotDotDash";
    BorderStyle2["DOTTED"] = "dotted";
    BorderStyle2["DOUBLE"] = "double";
    BorderStyle2["DOUBLE_WAVE"] = "doubleWave";
    BorderStyle2["INSET"] = "inset";
    BorderStyle2["NIL"] = "nil";
    BorderStyle2["NONE"] = "none";
    BorderStyle2["OUTSET"] = "outset";
    BorderStyle2["THICK"] = "thick";
    BorderStyle2["THICK_THIN_LARGE_GAP"] = "thickThinLargeGap";
    BorderStyle2["THICK_THIN_MEDIUM_GAP"] = "thickThinMediumGap";
    BorderStyle2["THICK_THIN_SMALL_GAP"] = "thickThinSmallGap";
    BorderStyle2["THIN_THICK_LARGE_GAP"] = "thinThickLargeGap";
    BorderStyle2["THIN_THICK_MEDIUM_GAP"] = "thinThickMediumGap";
    BorderStyle2["THIN_THICK_SMALL_GAP"] = "thinThickSmallGap";
    BorderStyle2["THIN_THICK_THIN_LARGE_GAP"] = "thinThickThinLargeGap";
    BorderStyle2["THIN_THICK_THIN_MEDIUM_GAP"] = "thinThickThinMediumGap";
    BorderStyle2["THIN_THICK_THIN_SMALL_GAP"] = "thinThickThinSmallGap";
    BorderStyle2["THREE_D_EMBOSS"] = "threeDEmboss";
    BorderStyle2["THREE_D_ENGRAVE"] = "threeDEngrave";
    BorderStyle2["TRIPLE"] = "triple";
    BorderStyle2["WAVE"] = "wave";
    return BorderStyle2;
  })(BorderStyle || {});
  var PageOrientation = /* @__PURE__ */ ((PageOrientation2) => {
    PageOrientation2["PORTRAIT"] = "portrait";
    PageOrientation2["LANDSCAPE"] = "landscape";
    return PageOrientation2;
  })(PageOrientation || {});
  var sectionPageSizeDefaults = {
    WIDTH: 11906,
    HEIGHT: 16838,
    ORIENTATION: PageOrientation.PORTRAIT
  };
  var NONE_BORDER = {
    style: BorderStyle.NONE,
    size: 0,
    color: "auto"
  };
  var DEFAULT_BORDER = {
    style: BorderStyle.SINGLE,
    size: 4,
    color: "auto"
  };
  var TableBorders = class extends XmlComponent {
    constructor(options2) {
      super("w:tblBorders");
      if (options2.top) {
        this.root.push(new BorderElement("w:top", options2.top));
      } else {
        this.root.push(new BorderElement("w:top", DEFAULT_BORDER));
      }
      if (options2.left) {
        this.root.push(new BorderElement("w:left", options2.left));
      } else {
        this.root.push(new BorderElement("w:left", DEFAULT_BORDER));
      }
      if (options2.bottom) {
        this.root.push(new BorderElement("w:bottom", options2.bottom));
      } else {
        this.root.push(new BorderElement("w:bottom", DEFAULT_BORDER));
      }
      if (options2.right) {
        this.root.push(new BorderElement("w:right", options2.right));
      } else {
        this.root.push(new BorderElement("w:right", DEFAULT_BORDER));
      }
      if (options2.insideHorizontal) {
        this.root.push(new BorderElement("w:insideH", options2.insideHorizontal));
      } else {
        this.root.push(new BorderElement("w:insideH", DEFAULT_BORDER));
      }
      if (options2.insideVertical) {
        this.root.push(new BorderElement("w:insideV", options2.insideVertical));
      } else {
        this.root.push(new BorderElement("w:insideV", DEFAULT_BORDER));
      }
    }
  };
  __publicField(TableBorders, "NONE", {
    top: NONE_BORDER,
    bottom: NONE_BORDER,
    left: NONE_BORDER,
    right: NONE_BORDER,
    insideHorizontal: NONE_BORDER,
    insideVertical: NONE_BORDER
  });
  function commonjsRequire(path) {
    throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }
  var jszip_min = { exports: {} };
  (function(module, exports) {
    !function(e) {
      module.exports = e();
    }(function() {
      return function s(a, o, h) {
        function u(r, e2) {
          if (!o[r]) {
            if (!a[r]) {
              var t = "function" == typeof commonjsRequire && commonjsRequire;
              if (!e2 && t)
                return t(r, true);
              if (l)
                return l(r, true);
              var n = new Error("Cannot find module '" + r + "'");
              throw n.code = "MODULE_NOT_FOUND", n;
            }
            var i = o[r] = { exports: {} };
            a[r][0].call(i.exports, function(e3) {
              var t2 = a[r][1][e3];
              return u(t2 || e3);
            }, i, i.exports, s, a, o, h);
          }
          return o[r].exports;
        }
        for (var l = "function" == typeof commonjsRequire && commonjsRequire, e = 0; e < h.length; e++)
          u(h[e]);
        return u;
      }({ 1: [function(e, t, r) {
        var d = e("./utils"), c = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        r.encode = function(e2) {
          for (var t2, r2, n, i, s, a, o, h = [], u = 0, l = e2.length, f = l, c2 = "string" !== d.getTypeOf(e2); u < e2.length; )
            f = l - u, n = c2 ? (t2 = e2[u++], r2 = u < l ? e2[u++] : 0, u < l ? e2[u++] : 0) : (t2 = e2.charCodeAt(u++), r2 = u < l ? e2.charCodeAt(u++) : 0, u < l ? e2.charCodeAt(u++) : 0), i = t2 >> 2, s = (3 & t2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
          return h.join("");
        }, r.decode = function(e2) {
          var t2, r2, n, i, s, a, o = 0, h = 0, u = "data:";
          if (e2.substr(0, u.length) === u)
            throw new Error("Invalid base64 input, it looks like a data url.");
          var l, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0)
            throw new Error("Invalid base64 input, bad content length.");
          for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; )
            t2 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l[h++] = t2, 64 !== s && (l[h++] = r2), 64 !== a && (l[h++] = n);
          return l;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(e, t, r) {
        var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
        function o(e2, t2, r2, n2, i2) {
          this.compressedSize = e2, this.uncompressedSize = t2, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
        }
        o.prototype = { getContentWorker: function() {
          var e2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t2 = this;
          return e2.on("end", function() {
            if (this.streamInfo.data_length !== t2.uncompressedSize)
              throw new Error("Bug : uncompressed data size mismatch");
          }), e2;
        }, getCompressedWorker: function() {
          return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, o.createWorkerFrom = function(e2, t2, r2) {
          return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t2.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t2);
        }, t.exports = o;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t, r) {
        var n = e("./stream/GenericWorker");
        r.STORE = { magic: "\0\0", compressWorker: function() {
          return new n("STORE compression");
        }, uncompressWorker: function() {
          return new n("STORE decompression");
        } }, r.DEFLATE = e("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t, r) {
        var n = e("./utils");
        var o = function() {
          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n2 = 0; n2 < 8; n2++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r2] = e2;
          }
          return t2;
        }();
        t.exports = function(e2, t2) {
          return void 0 !== e2 && e2.length ? "string" !== n.getTypeOf(e2) ? function(e3, t3, r2, n2) {
            var i = o, s = n2 + r2;
            e3 ^= -1;
            for (var a = n2; a < s; a++)
              e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3[a])];
            return -1 ^ e3;
          }(0 | t2, e2, e2.length, 0) : function(e3, t3, r2, n2) {
            var i = o, s = n2 + r2;
            e3 ^= -1;
            for (var a = n2; a < s; a++)
              e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3.charCodeAt(a))];
            return -1 ^ e3;
          }(0 | t2, e2, e2.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(e, t, r) {
        r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
      }, {}], 6: [function(e, t, r) {
        var n = null;
        n = "undefined" != typeof Promise ? Promise : e("lie"), t.exports = { Promise: n };
      }, { lie: 37 }], 7: [function(e, t, r) {
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
        function h(e2, t2) {
          a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t2, this.meta = {};
        }
        r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(e2) {
          this.meta = e2.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
        }, h.prototype.flush = function() {
          a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
        }, h.prototype.cleanUp = function() {
          a.prototype.cleanUp.call(this), this._pako = null;
        }, h.prototype._createPako = function() {
          this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
          var t2 = this;
          this._pako.onData = function(e2) {
            t2.push({ data: e2, meta: t2.meta });
          };
        }, r.compressWorker = function(e2) {
          return new h("Deflate", e2);
        }, r.uncompressWorker = function() {
          return new h("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t, r) {
        function A(e2, t2) {
          var r2, n2 = "";
          for (r2 = 0; r2 < t2; r2++)
            n2 += String.fromCharCode(255 & e2), e2 >>>= 8;
          return n2;
        }
        function n(e2, t2, r2, n2, i2, s2) {
          var a, o, h = e2.file, u = e2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), c = I.transformTo("string", O.utf8encode(h.name)), d = h.comment, p = I.transformTo("string", s2(d)), m = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          t2 && !r2 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
          var S = 0;
          t2 && (S |= 8), l || !_ && !g || (S |= 2048);
          var z = 0, C = 0;
          w && (z |= 16), "UNIX" === i2 ? (C = 798, z |= function(e3, t3) {
            var r3 = e3;
            return e3 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;
          }(h.unixPermissions, w)) : (C = 20, z |= function(e3) {
            return 63 & (e3 || 0);
          }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
          var E = "";
          return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R2.LOCAL_FILE_HEADER + E + f + b, dirRecord: R2.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z, 4) + A(n2, 4) + f + b + p };
        }
        var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R2 = e("../signature");
        function s(e2, t2, r2, n2) {
          i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t2, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        I.inherits(s, i), s.prototype.push = function(e2) {
          var t2 = e2.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
          this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t2 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
        }, s.prototype.openedSource = function(e2) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
          var t2 = this.streamFiles && !e2.file.dir;
          if (t2) {
            var r2 = n(e2, t2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: r2.fileRecord, meta: { percent: 0 } });
          } else
            this.accumulate = true;
        }, s.prototype.closedSource = function(e2) {
          this.accumulate = false;
          var t2 = this.streamFiles && !e2.file.dir, r2 = n(e2, t2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(r2.dirRecord), t2)
            this.push({ data: function(e3) {
              return R2.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
            }(e2), meta: { percent: 100 } });
          else
            for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
              this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, s.prototype.flush = function() {
          for (var e2 = this.bytesWritten, t2 = 0; t2 < this.dirRecords.length; t2++)
            this.push({ data: this.dirRecords[t2], meta: { percent: 100 } });
          var r2 = this.bytesWritten - e2, n2 = function(e3, t3, r3, n3, i2) {
            var s2 = I.transformTo("string", i2(n3));
            return R2.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e3, 2) + A(e3, 2) + A(t3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
          }(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
          this.push({ data: n2, meta: { percent: 100 } });
        }, s.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, s.prototype.registerPrevious = function(e2) {
          this._sources.push(e2);
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.closedSource(t2.previous.streamInfo), t2._sources.length ? t2.prepareNextSource() : t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
        }, s.prototype.error = function(e2) {
          var t2 = this._sources;
          if (!i.prototype.error.call(this, e2))
            return false;
          for (var r2 = 0; r2 < t2.length; r2++)
            try {
              t2[r2].error(e2);
            } catch (e3) {
            }
          return true;
        }, s.prototype.lock = function() {
          i.prototype.lock.call(this);
          for (var e2 = this._sources, t2 = 0; t2 < e2.length; t2++)
            e2[t2].lock();
        }, t.exports = s;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t, r) {
        var u = e("../compressions"), n = e("./ZipFileWorker");
        r.generateWorker = function(e2, a, t2) {
          var o = new n(a.streamFiles, t2, a.platform, a.encodeFileName), h = 0;
          try {
            e2.forEach(function(e3, t3) {
              h++;
              var r2 = function(e4, t4) {
                var r3 = e4 || t4, n3 = u[r3];
                if (!n3)
                  throw new Error(r3 + " is not a valid compression method !");
                return n3;
              }(t3.options.compression, a.compression), n2 = t3.options.compressionOptions || a.compressionOptions || {}, i = t3.dir, s = t3.date;
              t3._compressWorker(r2, n2).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t3.comment || "", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);
            }), o.entriesCount = h;
          } catch (e3) {
            o.error(e3);
          }
          return o;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t, r) {
        function n() {
          if (!(this instanceof n))
            return new n();
          if (arguments.length)
            throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var e2 = new n();
            for (var t2 in this)
              "function" != typeof this[t2] && (e2[t2] = this[t2]);
            return e2;
          };
        }
        (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e2, t2) {
          return new n().loadAsync(e2, t2);
        }, n.external = e("./external"), t.exports = n;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t, r) {
        var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
        function f(n2) {
          return new i.Promise(function(e2, t2) {
            var r2 = n2.decompressed.getContentWorker().pipe(new a());
            r2.on("error", function(e3) {
              t2(e3);
            }).on("end", function() {
              r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t2(new Error("Corrupted zip : CRC32 mismatch")) : e2();
            }).resume();
          });
        }
        t.exports = function(e2, o) {
          var h = this;
          return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
            var t2 = new s(o);
            return t2.load(e3), t2;
          }).then(function(e3) {
            var t2 = [i.Promise.resolve(e3)], r2 = e3.files;
            if (o.checkCRC32)
              for (var n2 = 0; n2 < r2.length; n2++)
                t2.push(f(r2[n2]));
            return i.Promise.all(t2);
          }).then(function(e3) {
            for (var t2 = e3.shift(), r2 = t2.files, n2 = 0; n2 < r2.length; n2++) {
              var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
              h.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h.file(a2).unsafeOriginalName = s2);
            }
            return t2.zipComment.length && (h.comment = t2.zipComment), h;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t, r) {
        var n = e("../utils"), i = e("../stream/GenericWorker");
        function s(e2, t2) {
          i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t2);
        }
        n.inherits(s, i), s.prototype._bindStream = function(e2) {
          var t2 = this;
          (this._stream = e2).pause(), e2.on("data", function(e3) {
            t2.push({ data: e3, meta: { percent: 0 } });
          }).on("error", function(e3) {
            t2.isPaused ? this.generatedError = e3 : t2.error(e3);
          }).on("end", function() {
            t2.isPaused ? t2._upstreamEnded = true : t2.end();
          });
        }, s.prototype.pause = function() {
          return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
        }, t.exports = s;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t, r) {
        var i = e("readable-stream").Readable;
        function n(e2, t2, r2) {
          i.call(this, t2), this._helper = e2;
          var n2 = this;
          e2.on("data", function(e3, t3) {
            n2.push(e3) || n2._helper.pause(), r2 && r2(t3);
          }).on("error", function(e3) {
            n2.emit("error", e3);
          }).on("end", function() {
            n2.push(null);
          });
        }
        e("../utils").inherits(n, i), n.prototype._read = function() {
          this._helper.resume();
        }, t.exports = n;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t, r) {
        t.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e2, t2) {
          if (Buffer.from && Buffer.from !== Uint8Array.from)
            return Buffer.from(e2, t2);
          if ("number" == typeof e2)
            throw new Error('The "data" argument must not be a number');
          return new Buffer(e2, t2);
        }, allocBuffer: function(e2) {
          if (Buffer.alloc)
            return Buffer.alloc(e2);
          var t2 = new Buffer(e2);
          return t2.fill(0), t2;
        }, isBuffer: function(e2) {
          return Buffer.isBuffer(e2);
        }, isStream: function(e2) {
          return e2 && "function" == typeof e2.on && "function" == typeof e2.pause && "function" == typeof e2.resume;
        } };
      }, {}], 15: [function(e, t, r) {
        function s(e2, t2, r2) {
          var n2, i2 = u.getTypeOf(t2), s2 = u.extend(r2 || {}, f);
          s2.date = s2.date || /* @__PURE__ */ new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n2 = _(e2)) && b.call(this, n2, true);
          var a2 = "string" === i2 && false === s2.binary && false === s2.base64;
          r2 && void 0 !== r2.binary || (s2.binary = !a2), (t2 instanceof c && 0 === t2.uncompressedSize || s2.dir || !t2 || 0 === t2.length) && (s2.base64 = false, s2.binary = true, t2 = "", s2.compression = "STORE", i2 = "string");
          var o2 = null;
          o2 = t2 instanceof c || t2 instanceof l ? t2 : p.isNode && p.isStream(t2) ? new m(e2, t2) : u.prepareContent(e2, t2, s2.binary, s2.optimizedBinaryString, s2.base64);
          var h2 = new d(e2, o2, s2);
          this.files[e2] = h2;
        }
        var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function(e2) {
          "/" === e2.slice(-1) && (e2 = e2.substring(0, e2.length - 1));
          var t2 = e2.lastIndexOf("/");
          return 0 < t2 ? e2.substring(0, t2) : "";
        }, g = function(e2) {
          return "/" !== e2.slice(-1) && (e2 += "/"), e2;
        }, b = function(e2, t2) {
          return t2 = void 0 !== t2 ? t2 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t2 }), this.files[e2];
        };
        function h(e2) {
          return "[object RegExp]" === Object.prototype.toString.call(e2);
        }
        var n = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(e2) {
          var t2, r2, n2;
          for (t2 in this.files)
            n2 = this.files[t2], (r2 = t2.slice(this.root.length, t2.length)) && t2.slice(0, this.root.length) === this.root && e2(r2, n2);
        }, filter: function(r2) {
          var n2 = [];
          return this.forEach(function(e2, t2) {
            r2(e2, t2) && n2.push(t2);
          }), n2;
        }, file: function(e2, t2, r2) {
          if (1 !== arguments.length)
            return e2 = this.root + e2, s.call(this, e2, t2, r2), this;
          if (h(e2)) {
            var n2 = e2;
            return this.filter(function(e3, t3) {
              return !t3.dir && n2.test(e3);
            });
          }
          var i2 = this.files[this.root + e2];
          return i2 && !i2.dir ? i2 : null;
        }, folder: function(r2) {
          if (!r2)
            return this;
          if (h(r2))
            return this.filter(function(e3, t3) {
              return t3.dir && r2.test(e3);
            });
          var e2 = this.root + r2, t2 = b.call(this, e2), n2 = this.clone();
          return n2.root = t2.name, n2;
        }, remove: function(r2) {
          r2 = this.root + r2;
          var e2 = this.files[r2];
          if (e2 || ("/" !== r2.slice(-1) && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir)
            delete this.files[r2];
          else
            for (var t2 = this.filter(function(e3, t3) {
              return t3.name.slice(0, r2.length) === r2;
            }), n2 = 0; n2 < t2.length; n2++)
              delete this.files[t2[n2].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(e2) {
          var t2, r2 = {};
          try {
            if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type)
              throw new Error("No output type specified.");
            u.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
            var n2 = r2.comment || this.comment || "";
            t2 = o.generateWorker(this, r2, n2);
          } catch (e3) {
            (t2 = new l("error")).error(e3);
          }
          return new a(t2, r2.type || "string", r2.mimeType);
        }, generateAsync: function(e2, t2) {
          return this.generateInternalStream(e2).accumulate(t2);
        }, generateNodeStream: function(e2, t2) {
          return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t2);
        } };
        t.exports = n;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t, r) {
        t.exports = e("stream");
      }, { stream: void 0 }], 17: [function(e, t, r) {
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
          for (var t2 = 0; t2 < this.data.length; t2++)
            e2[t2] = 255 & e2[t2];
        }
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data[this.zero + e2];
        }, i.prototype.lastIndexOfSignature = function(e2) {
          for (var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s)
            if (this.data[s] === t2 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2)
              return s - this.zero;
          return -1;
        }, i.prototype.readAndCheckSignature = function(e2) {
          var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
          return t2 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
        }, i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2)
            return [];
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t, r) {
        var n = e("../utils");
        function i(e2) {
          this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
        }
        i.prototype = { checkOffset: function(e2) {
          this.checkIndex(this.index + e2);
        }, checkIndex: function(e2) {
          if (this.length < this.zero + e2 || e2 < 0)
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
        }, setIndex: function(e2) {
          this.checkIndex(e2), this.index = e2;
        }, skip: function(e2) {
          this.setIndex(this.index + e2);
        }, byteAt: function() {
        }, readInt: function(e2) {
          var t2, r2 = 0;
          for (this.checkOffset(e2), t2 = this.index + e2 - 1; t2 >= this.index; t2--)
            r2 = (r2 << 8) + this.byteAt(t2);
          return this.index += e2, r2;
        }, readString: function(e2) {
          return n.transformTo("string", this.readData(e2));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var e2 = this.readInt(4);
          return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
        } }, t.exports = i;
      }, { "../utils": 32 }], 19: [function(e, t, r) {
        var n = e("./Uint8ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t, r) {
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data.charCodeAt(this.zero + e2);
        }, i.prototype.lastIndexOfSignature = function(e2) {
          return this.data.lastIndexOf(e2) - this.zero;
        }, i.prototype.readAndCheckSignature = function(e2) {
          return e2 === this.readData(4);
        }, i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t, r) {
        var n = e("./ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2)
            return new Uint8Array(0);
          var t2 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t, r) {
        var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
        t.exports = function(e2) {
          var t2 = n.getTypeOf(e2);
          return n.checkSupport(t2), "string" !== t2 || i.uint8array ? "nodebuffer" === t2 ? new o(e2) : i.uint8array ? new h(n.transformTo("uint8array", e2)) : new s(n.transformTo("array", e2)) : new a(e2);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t, r) {
        r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(e, t, r) {
        var n = e("./GenericWorker"), i = e("../utils");
        function s(e2) {
          n.call(this, "ConvertWorker to " + e2), this.destType = e2;
        }
        i.inherits(s, n), s.prototype.processChunk = function(e2) {
          this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t, r) {
        var n = e("./GenericWorker"), i = e("../crc32");
        function s() {
          n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        e("../utils").inherits(s, n), s.prototype.processChunk = function(e2) {
          this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
        }, t.exports = s;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t, r) {
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
        }
        n.inherits(s, i), s.prototype.processChunk = function(e2) {
          if (e2) {
            var t2 = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = t2 + e2.data.length;
          }
          i.prototype.processChunk.call(this, e2);
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t, r) {
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataWorker");
          var t2 = this;
          this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
            t2.dataIsReady = true, t2.data = e3, t2.max = e3 && e3.length || 0, t2.type = n.getTypeOf(e3), t2.isPaused || t2._tickAndRepeat();
          }, function(e3) {
            t2.error(e3);
          });
        }
        n.inherits(s, i), s.prototype.cleanUp = function() {
          i.prototype.cleanUp.call(this), this.data = null;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
        }, s.prototype._tickAndRepeat = function() {
          this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
        }, s.prototype._tick = function() {
          if (this.isPaused || this.isFinished)
            return false;
          var e2 = null, t2 = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max)
            return this.end();
          switch (this.type) {
            case "string":
              e2 = this.data.substring(this.index, t2);
              break;
            case "uint8array":
              e2 = this.data.subarray(this.index, t2);
              break;
            case "array":
            case "nodebuffer":
              e2 = this.data.slice(this.index, t2);
          }
          return this.index = t2, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t, r) {
        function n(e2) {
          this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        n.prototype = { push: function(e2) {
          this.emit("data", e2);
        }, end: function() {
          if (this.isFinished)
            return false;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = true;
          } catch (e2) {
            this.emit("error", e2);
          }
          return true;
        }, error: function(e2) {
          return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
        }, on: function(e2, t2) {
          return this._listeners[e2].push(t2), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(e2, t2) {
          if (this._listeners[e2])
            for (var r2 = 0; r2 < this._listeners[e2].length; r2++)
              this._listeners[e2][r2].call(this, t2);
        }, pipe: function(e2) {
          return e2.registerPrevious(this);
        }, registerPrevious: function(e2) {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
        }, resume: function() {
          if (!this.isPaused || this.isFinished)
            return false;
          var e2 = this.isPaused = false;
          return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
        }, flush: function() {
        }, processChunk: function(e2) {
          this.push(e2);
        }, withStreamInfo: function(e2, t2) {
          return this.extraStreamInfo[e2] = t2, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var e2 in this.extraStreamInfo)
            Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
        }, lock: function() {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = true, this.previous && this.previous.lock();
        }, toString: function() {
          var e2 = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + e2 : e2;
        } }, t.exports = n;
      }, {}], 29: [function(e, t, r) {
        var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
        if (n.nodestream)
          try {
            o = e("../nodejs/NodejsStreamOutputAdapter");
          } catch (e2) {
          }
        function l(e2, o2) {
          return new a.Promise(function(t2, r2) {
            var n2 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
            e2.on("data", function(e3, t3) {
              n2.push(e3), o2 && o2(t3);
            }).on("error", function(e3) {
              n2 = [], r2(e3);
            }).on("end", function() {
              try {
                var e3 = function(e4, t3, r3) {
                  switch (e4) {
                    case "blob":
                      return h.newBlob(h.transformTo("arraybuffer", t3), r3);
                    case "base64":
                      return u.encode(t3);
                    default:
                      return h.transformTo(e4, t3);
                  }
                }(s2, function(e4, t3) {
                  var r3, n3 = 0, i3 = null, s3 = 0;
                  for (r3 = 0; r3 < t3.length; r3++)
                    s3 += t3[r3].length;
                  switch (e4) {
                    case "string":
                      return t3.join("");
                    case "array":
                      return Array.prototype.concat.apply([], t3);
                    case "uint8array":
                      for (i3 = new Uint8Array(s3), r3 = 0; r3 < t3.length; r3++)
                        i3.set(t3[r3], n3), n3 += t3[r3].length;
                      return i3;
                    case "nodebuffer":
                      return Buffer.concat(t3);
                    default:
                      throw new Error("concat : unsupported type '" + e4 + "'");
                  }
                }(i2, n2), a2);
                t2(e3);
              } catch (e4) {
                r2(e4);
              }
              n2 = [];
            }).resume();
          });
        }
        function f(e2, t2, r2) {
          var n2 = t2;
          switch (t2) {
            case "blob":
            case "arraybuffer":
              n2 = "uint8array";
              break;
            case "base64":
              n2 = "string";
          }
          try {
            this._internalType = n2, this._outputType = t2, this._mimeType = r2, h.checkSupport(n2), this._worker = e2.pipe(new i(n2)), e2.lock();
          } catch (e3) {
            this._worker = new s("error"), this._worker.error(e3);
          }
        }
        f.prototype = { accumulate: function(e2) {
          return l(this, e2);
        }, on: function(e2, t2) {
          var r2 = this;
          return "data" === e2 ? this._worker.on(e2, function(e3) {
            t2.call(r2, e3.data, e3.meta);
          }) : this._worker.on(e2, function() {
            h.delay(t2, arguments, r2);
          }), this;
        }, resume: function() {
          return h.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(e2) {
          if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType)
            throw new Error(this._outputType + " is not supported by this method");
          return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e2);
        } }, t.exports = f;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t, r) {
        if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer)
          r.blob = false;
        else {
          var n = new ArrayBuffer(0);
          try {
            r.blob = 0 === new Blob([n], { type: "application/zip" }).size;
          } catch (e2) {
            try {
              var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              i.append(n), r.blob = 0 === i.getBlob("application/zip").size;
            } catch (e3) {
              r.blob = false;
            }
          }
        }
        try {
          r.nodestream = !!e("readable-stream").Readable;
        } catch (e2) {
          r.nodestream = false;
        }
      }, { "readable-stream": 16 }], 31: [function(e, t, s) {
        for (var o = e("./utils"), h = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++)
          u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
        u[254] = u[254] = 1;
        function a() {
          n.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function l() {
          n.call(this, "utf-8 encode");
        }
        s.utf8encode = function(e2) {
          return h.nodebuffer ? r.newBufferFrom(e2, "utf-8") : function(e3) {
            var t2, r2, n2, i2, s2, a2 = e3.length, o2 = 0;
            for (i2 = 0; i2 < a2; i2++)
              55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
            for (t2 = h.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++)
              55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
            return t2;
          }(e2);
        }, s.utf8decode = function(e2) {
          return h.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : function(e3) {
            var t2, r2, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);
            for (t2 = r2 = 0; t2 < s2; )
              if ((n2 = e3[t2++]) < 128)
                a2[r2++] = n2;
              else if (4 < (i2 = u[n2]))
                a2[r2++] = 65533, t2 += i2 - 1;
              else {
                for (n2 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t2 < s2; )
                  n2 = n2 << 6 | 63 & e3[t2++], i2--;
                1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);
              }
            return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
          }(e2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2));
        }, o.inherits(a, n), a.prototype.processChunk = function(e2) {
          var t2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2.data);
          if (this.leftOver && this.leftOver.length) {
            if (h.uint8array) {
              var r2 = t2;
              (t2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t2.set(r2, this.leftOver.length);
            } else
              t2 = this.leftOver.concat(t2);
            this.leftOver = null;
          }
          var n2 = function(e3, t3) {
            var r3;
            for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e3[r3]); )
              r3--;
            return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u[e3[r3]] > t3 ? r3 : t3;
          }(t2), i2 = t2;
          n2 !== t2.length && (h.uint8array ? (i2 = t2.subarray(0, n2), this.leftOver = t2.subarray(n2, t2.length)) : (i2 = t2.slice(0, n2), this.leftOver = t2.slice(n2, t2.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
        }, a.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e2) {
          this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
        }, s.Utf8EncodeWorker = l;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t, a) {
        var o = e("./support"), h = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
        function n(e2) {
          return e2;
        }
        function l(e2, t2) {
          for (var r2 = 0; r2 < e2.length; ++r2)
            t2[r2] = 255 & e2.charCodeAt(r2);
          return t2;
        }
        e("setimmediate"), a.newBlob = function(t2, r2) {
          a.checkSupport("blob");
          try {
            return new Blob([t2], { type: r2 });
          } catch (e2) {
            try {
              var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return n2.append(t2), n2.getBlob(r2);
            } catch (e3) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var i = { stringifyByChunk: function(e2, t2, r2) {
          var n2 = [], i2 = 0, s2 = e2.length;
          if (s2 <= r2)
            return String.fromCharCode.apply(null, e2);
          for (; i2 < s2; )
            "array" === t2 || "nodebuffer" === t2 ? n2.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
          return n2.join("");
        }, stringifyByChar: function(e2) {
          for (var t2 = "", r2 = 0; r2 < e2.length; r2++)
            t2 += String.fromCharCode(e2[r2]);
          return t2;
        }, applyCanBeUsed: { uint8array: function() {
          try {
            return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
          } catch (e2) {
            return false;
          }
        }(), nodebuffer: function() {
          try {
            return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
          } catch (e2) {
            return false;
          }
        }() } };
        function s(e2) {
          var t2 = 65536, r2 = a.getTypeOf(e2), n2 = true;
          if ("uint8array" === r2 ? n2 = i.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (n2 = i.applyCanBeUsed.nodebuffer), n2)
            for (; 1 < t2; )
              try {
                return i.stringifyByChunk(e2, r2, t2);
              } catch (e3) {
                t2 = Math.floor(t2 / 2);
              }
          return i.stringifyByChar(e2);
        }
        function f(e2, t2) {
          for (var r2 = 0; r2 < e2.length; r2++)
            t2[r2] = e2[r2];
          return t2;
        }
        a.applyFromCharCode = s;
        var c = {};
        c.string = { string: n, array: function(e2) {
          return l(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.string.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return l(e2, new Uint8Array(e2.length));
        }, nodebuffer: function(e2) {
          return l(e2, r.allocBuffer(e2.length));
        } }, c.array = { string: s, array: n, arraybuffer: function(e2) {
          return new Uint8Array(e2).buffer;
        }, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.arraybuffer = { string: function(e2) {
          return s(new Uint8Array(e2));
        }, array: function(e2) {
          return f(new Uint8Array(e2), new Array(e2.byteLength));
        }, arraybuffer: n, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(new Uint8Array(e2));
        } }, c.uint8array = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return e2.buffer;
        }, uint8array: n, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.nodebuffer = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.nodebuffer.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return f(e2, new Uint8Array(e2.length));
        }, nodebuffer: n }, a.transformTo = function(e2, t2) {
          if (t2 = t2 || "", !e2)
            return t2;
          a.checkSupport(e2);
          var r2 = a.getTypeOf(t2);
          return c[r2][e2](t2);
        }, a.resolve = function(e2) {
          for (var t2 = e2.split("/"), r2 = [], n2 = 0; n2 < t2.length; n2++) {
            var i2 = t2[n2];
            "." === i2 || "" === i2 && 0 !== n2 && n2 !== t2.length - 1 || (".." === i2 ? r2.pop() : r2.push(i2));
          }
          return r2.join("/");
        }, a.getTypeOf = function(e2) {
          return "string" == typeof e2 ? "string" : "[object Array]" === Object.prototype.toString.call(e2) ? "array" : o.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, a.checkSupport = function(e2) {
          if (!o[e2.toLowerCase()])
            throw new Error(e2 + " is not supported by this platform");
        }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
          var t2, r2, n2 = "";
          for (r2 = 0; r2 < (e2 || "").length; r2++)
            n2 += "\\x" + ((t2 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t2.toString(16).toUpperCase();
          return n2;
        }, a.delay = function(e2, t2, r2) {
          setImmediate(function() {
            e2.apply(r2 || null, t2 || []);
          });
        }, a.inherits = function(e2, t2) {
          function r2() {
          }
          r2.prototype = t2.prototype, e2.prototype = new r2();
        }, a.extend = function() {
          var e2, t2, r2 = {};
          for (e2 = 0; e2 < arguments.length; e2++)
            for (t2 in arguments[e2])
              Object.prototype.hasOwnProperty.call(arguments[e2], t2) && void 0 === r2[t2] && (r2[t2] = arguments[e2][t2]);
          return r2;
        }, a.prepareContent = function(r2, e2, n2, i2, s2) {
          return u.Promise.resolve(e2).then(function(n3) {
            return o.blob && (n3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3))) && "undefined" != typeof FileReader ? new u.Promise(function(t2, r3) {
              var e3 = new FileReader();
              e3.onload = function(e4) {
                t2(e4.target.result);
              }, e3.onerror = function(e4) {
                r3(e4.target.error);
              }, e3.readAsArrayBuffer(n3);
            }) : n3;
          }).then(function(e3) {
            var t2 = a.getTypeOf(e3);
            return t2 ? ("arraybuffer" === t2 ? e3 = a.transformTo("uint8array", e3) : "string" === t2 && (s2 ? e3 = h.decode(e3) : n2 && true !== i2 && (e3 = function(e4) {
              return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
            }(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t, r) {
        var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
        function h(e2) {
          this.files = [], this.loadOptions = e2;
        }
        h.prototype = { checkSignature: function(e2) {
          if (!this.reader.readAndCheckSignature(e2)) {
            this.reader.index -= 4;
            var t2 = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t2) + ", expected " + i.pretty(e2) + ")");
          }
        }, isSignature: function(e2, t2) {
          var r2 = this.reader.index;
          this.reader.setIndex(e2);
          var n2 = this.reader.readString(4) === t2;
          return this.reader.setIndex(r2), n2;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var e2 = this.reader.readData(this.zipCommentLength), t2 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t2, e2);
          this.zipComment = this.loadOptions.decodeFileName(r2);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var e2, t2, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; )
            e2 = this.reader.readInt(2), t2 = this.reader.readInt(4), r2 = this.reader.readData(t2), this.zip64ExtensibleData[e2] = { id: e2, length: t2, value: r2 };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
            throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var e2, t2;
          for (e2 = 0; e2 < this.files.length; e2++)
            t2 = this.files[e2], this.reader.setIndex(t2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t2.readLocalPart(this.reader), t2.handleUTF8(), t2.processAttributes();
        }, readCentralDir: function() {
          var e2;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
            (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
          if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length)
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
          if (e2 < 0)
            throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          this.reader.setIndex(e2);
          var t2 = e2;
          if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
            if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var r2 = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
          var n2 = t2 - r2;
          if (0 < n2)
            this.isSignature(t2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
          else if (n2 < 0)
            throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
        }, prepareReader: function(e2) {
          this.reader = n(e2);
        }, load: function(e2) {
          this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, t.exports = h;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t, r) {
        var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h = e("./compressions"), u = e("./support");
        function l(e2, t2) {
          this.options = e2, this.loadOptions = t2;
        }
        l.prototype = { isEncrypted: function() {
          return 1 == (1 & this.bitFlag);
        }, useUTF8: function() {
          return 2048 == (2048 & this.bitFlag);
        }, readLocalPart: function(e2) {
          var t2, r2;
          if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize)
            throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if (null === (t2 = function(e3) {
            for (var t3 in h)
              if (Object.prototype.hasOwnProperty.call(h, t3) && h[t3].magic === e3)
                return h[t3];
            return null;
          }(this.compressionMethod)))
            throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
          this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t2, e2.readData(this.compressedSize));
        }, readCentralPart: function(e2) {
          this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
          var t2 = e2.readInt(2);
          if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted())
            throw new Error("Encrypted zip are not supported");
          e2.skip(t2), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var e2 = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), 0 == e2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var e2 = n(this.extraFields[1].value);
            this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
          }
        }, readExtraFields: function(e2) {
          var t2, r2, n2, i2 = e2.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; )
            t2 = e2.readInt(2), r2 = e2.readInt(2), n2 = e2.readData(r2), this.extraFields[t2] = { id: t2, length: r2, value: n2 };
          e2.setIndex(i2);
        }, handleUTF8: function() {
          var e2 = u.uint8array ? "uint8array" : "array";
          if (this.useUTF8())
            this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
          else {
            var t2 = this.findExtraFieldUnicodePath();
            if (null !== t2)
              this.fileNameStr = t2;
            else {
              var r2 = s.transformTo(e2, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(r2);
            }
            var n2 = this.findExtraFieldUnicodeComment();
            if (null !== n2)
              this.fileCommentStr = n2;
            else {
              var i2 = s.transformTo(e2, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(i2);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var e2 = this.extraFields[28789];
          if (e2) {
            var t2 = n(e2.value);
            return 1 !== t2.readInt(1) ? null : a(this.fileName) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var e2 = this.extraFields[25461];
          if (e2) {
            var t2 = n(e2.value);
            return 1 !== t2.readInt(1) ? null : a(this.fileComment) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        } }, t.exports = l;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t, r) {
        function n(e2, t2, r2) {
          this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
        }
        var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h = e("./stream/GenericWorker");
        n.prototype = { internalStream: function(e2) {
          var t2 = null, r2 = "string";
          try {
            if (!e2)
              throw new Error("No output type specified.");
            var n2 = "string" === (r2 = e2.toLowerCase()) || "text" === r2;
            "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), t2 = this._decompressWorker();
            var i2 = !this._dataBinary;
            i2 && !n2 && (t2 = t2.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t2 = t2.pipe(new a.Utf8DecodeWorker()));
          } catch (e3) {
            (t2 = new h("error")).error(e3);
          }
          return new s(t2, r2, "");
        }, async: function(e2, t2) {
          return this.internalStream(e2).accumulate(t2);
        }, nodeStream: function(e2, t2) {
          return this.internalStream(e2 || "nodebuffer").toNodejsStream(t2);
        }, _compressWorker: function(e2, t2) {
          if (this._data instanceof o && this._data.compression.magic === e2.magic)
            return this._data.getCompressedWorker();
          var r2 = this._decompressWorker();
          return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t2);
        }, _decompressWorker: function() {
          return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);
        } };
        for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, f = 0; f < u.length; f++)
          n.prototype[u[f]] = l;
        t.exports = n;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l, t) {
        (function(t2) {
          var r, n, e2 = t2.MutationObserver || t2.WebKitMutationObserver;
          if (e2) {
            var i = 0, s = new e2(u), a = t2.document.createTextNode("");
            s.observe(a, { characterData: true }), r = function() {
              a.data = i = ++i % 2;
            };
          } else if (t2.setImmediate || void 0 === t2.MessageChannel)
            r = "document" in t2 && "onreadystatechange" in t2.document.createElement("script") ? function() {
              var e3 = t2.document.createElement("script");
              e3.onreadystatechange = function() {
                u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
              }, t2.document.documentElement.appendChild(e3);
            } : function() {
              setTimeout(u, 0);
            };
          else {
            var o = new t2.MessageChannel();
            o.port1.onmessage = u, r = function() {
              o.port2.postMessage(0);
            };
          }
          var h = [];
          function u() {
            var e3, t3;
            n = true;
            for (var r2 = h.length; r2; ) {
              for (t3 = h, h = [], e3 = -1; ++e3 < r2; )
                t3[e3]();
              r2 = h.length;
            }
            n = false;
          }
          l.exports = function(e3) {
            1 !== h.push(e3) || n || r();
          };
        }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 37: [function(e, t, r) {
        var i = e("immediate");
        function u() {
        }
        var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
        function o(e2) {
          if ("function" != typeof e2)
            throw new TypeError("resolver must be a function");
          this.state = n, this.queue = [], this.outcome = void 0, e2 !== u && d(this, e2);
        }
        function h(e2, t2, r2) {
          this.promise = e2, "function" == typeof t2 && (this.onFulfilled = t2, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
        }
        function f(t2, r2, n2) {
          i(function() {
            var e2;
            try {
              e2 = r2(n2);
            } catch (e3) {
              return l.reject(t2, e3);
            }
            e2 === t2 ? l.reject(t2, new TypeError("Cannot resolve promise with itself")) : l.resolve(t2, e2);
          });
        }
        function c(e2) {
          var t2 = e2 && e2.then;
          if (e2 && ("object" == typeof e2 || "function" == typeof e2) && "function" == typeof t2)
            return function() {
              t2.apply(e2, arguments);
            };
        }
        function d(t2, e2) {
          var r2 = false;
          function n2(e3) {
            r2 || (r2 = true, l.reject(t2, e3));
          }
          function i2(e3) {
            r2 || (r2 = true, l.resolve(t2, e3));
          }
          var s2 = p(function() {
            e2(i2, n2);
          });
          "error" === s2.status && n2(s2.value);
        }
        function p(e2, t2) {
          var r2 = {};
          try {
            r2.value = e2(t2), r2.status = "success";
          } catch (e3) {
            r2.status = "error", r2.value = e3;
          }
          return r2;
        }
        (t.exports = o).prototype.finally = function(t2) {
          if ("function" != typeof t2)
            return this;
          var r2 = this.constructor;
          return this.then(function(e2) {
            return r2.resolve(t2()).then(function() {
              return e2;
            });
          }, function(e2) {
            return r2.resolve(t2()).then(function() {
              throw e2;
            });
          });
        }, o.prototype.catch = function(e2) {
          return this.then(null, e2);
        }, o.prototype.then = function(e2, t2) {
          if ("function" != typeof e2 && this.state === a || "function" != typeof t2 && this.state === s)
            return this;
          var r2 = new this.constructor(u);
          this.state !== n ? f(r2, this.state === a ? e2 : t2, this.outcome) : this.queue.push(new h(r2, e2, t2));
          return r2;
        }, h.prototype.callFulfilled = function(e2) {
          l.resolve(this.promise, e2);
        }, h.prototype.otherCallFulfilled = function(e2) {
          f(this.promise, this.onFulfilled, e2);
        }, h.prototype.callRejected = function(e2) {
          l.reject(this.promise, e2);
        }, h.prototype.otherCallRejected = function(e2) {
          f(this.promise, this.onRejected, e2);
        }, l.resolve = function(e2, t2) {
          var r2 = p(c, t2);
          if ("error" === r2.status)
            return l.reject(e2, r2.value);
          var n2 = r2.value;
          if (n2)
            d(e2, n2);
          else {
            e2.state = a, e2.outcome = t2;
            for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; )
              e2.queue[i2].callFulfilled(t2);
          }
          return e2;
        }, l.reject = function(e2, t2) {
          e2.state = s, e2.outcome = t2;
          for (var r2 = -1, n2 = e2.queue.length; ++r2 < n2; )
            e2.queue[r2].callRejected(t2);
          return e2;
        }, o.resolve = function(e2) {
          if (e2 instanceof this)
            return e2;
          return l.resolve(new this(u), e2);
        }, o.reject = function(e2) {
          var t2 = new this(u);
          return l.reject(t2, e2);
        }, o.all = function(e2) {
          var r2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2))
            return this.reject(new TypeError("must be an array"));
          var n2 = e2.length, i2 = false;
          if (!n2)
            return this.resolve([]);
          var s2 = new Array(n2), a2 = 0, t2 = -1, o2 = new this(u);
          for (; ++t2 < n2; )
            h2(e2[t2], t2);
          return o2;
          function h2(e3, t3) {
            r2.resolve(e3).then(function(e4) {
              s2[t3] = e4, ++a2 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));
            }, function(e4) {
              i2 || (i2 = true, l.reject(o2, e4));
            });
          }
        }, o.race = function(e2) {
          var t2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2))
            return this.reject(new TypeError("must be an array"));
          var r2 = e2.length, n2 = false;
          if (!r2)
            return this.resolve([]);
          var i2 = -1, s2 = new this(u);
          for (; ++i2 < r2; )
            a2 = e2[i2], t2.resolve(a2).then(function(e3) {
              n2 || (n2 = true, l.resolve(s2, e3));
            }, function(e3) {
              n2 || (n2 = true, l.reject(s2, e3));
            });
          var a2;
          return s2;
        };
      }, { immediate: 36 }], 38: [function(e, t, r) {
        var n = {};
        (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t, r) {
        var a = e("./zlib/deflate"), o = e("./utils/common"), h = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
        function p(e2) {
          if (!(this instanceof p))
            return new p(e2);
          this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 < t2.windowBits ? t2.windowBits = -t2.windowBits : t2.gzip && 0 < t2.windowBits && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
          var r2 = a.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
          if (r2 !== l)
            throw new Error(i[r2]);
          if (t2.header && a.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
            var n2;
            if (n2 = "string" == typeof t2.dictionary ? h.string2buf(t2.dictionary) : "[object ArrayBuffer]" === u.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l)
              throw new Error(i[r2]);
            this._dict_set = true;
          }
        }
        function n(e2, t2) {
          var r2 = new p(t2);
          if (r2.push(e2, true), r2.err)
            throw r2.msg || i[r2.err];
          return r2.result;
        }
        p.prototype.push = function(e2, t2) {
          var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
          if (this.ended)
            return false;
          n2 = t2 === ~~t2 ? t2 : true === t2 ? 4 : 0, "string" == typeof e2 ? i2.input = h.string2buf(e2) : "[object ArrayBuffer]" === u.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
          do {
            if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r2 = a.deflate(i2, n2)) && r2 !== l)
              return this.onEnd(r2), !(this.ended = true);
            0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
          } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r2);
          return 4 === n2 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : 2 !== n2 || (this.onEnd(l), !(i2.avail_out = 0));
        }, p.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, p.prototype.onEnd = function(e2) {
          e2 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, n(e2, t2);
        }, r.gzip = function(e2, t2) {
          return (t2 = t2 || {}).gzip = true, n(e2, t2);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t, r) {
        var c = e("./zlib/inflate"), d = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
        function a(e2) {
          if (!(this instanceof a))
            return new a(e2);
          this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 <= t2.windowBits && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(0 <= t2.windowBits && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), 15 < t2.windowBits && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
          var r2 = c.inflateInit2(this.strm, t2.windowBits);
          if (r2 !== m.Z_OK)
            throw new Error(n[r2]);
          this.header = new s(), c.inflateGetHeader(this.strm, this.header);
        }
        function o(e2, t2) {
          var r2 = new a(t2);
          if (r2.push(e2, true), r2.err)
            throw r2.msg || n[r2.err];
          return r2.result;
        }
        a.prototype.push = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
          if (this.ended)
            return false;
          n2 = t2 === ~~t2 ? t2 : true === t2 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e2 ? h.input = p.binstring2buf(e2) : "[object ArrayBuffer]" === _.call(e2) ? h.input = new Uint8Array(e2) : h.input = e2, h.next_in = 0, h.avail_in = h.input.length;
          do {
            if (0 === h.avail_out && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = c.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && true === f && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK)
              return this.onEnd(r2), !(this.ended = true);
            h.next_out && (0 !== h.avail_out && r2 !== m.Z_STREAM_END && (0 !== h.avail_in || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - i2, a2 = p.buf2string(h.output, i2), h.next_out = s2, h.avail_out = u - s2, s2 && d.arraySet(h.output, h.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = true);
          } while ((0 < h.avail_in || 0 === h.avail_out) && r2 !== m.Z_STREAM_END);
          return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
        }, a.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, a.prototype.onEnd = function(e2) {
          e2 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, o(e2, t2);
        }, r.ungzip = o;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t, r) {
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
        r.assign = function(e2) {
          for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {
            var r2 = t2.shift();
            if (r2) {
              if ("object" != typeof r2)
                throw new TypeError(r2 + "must be non-object");
              for (var n2 in r2)
                r2.hasOwnProperty(n2) && (e2[n2] = r2[n2]);
            }
          }
          return e2;
        }, r.shrinkBuf = function(e2, t2) {
          return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
        };
        var i = { arraySet: function(e2, t2, r2, n2, i2) {
          if (t2.subarray && e2.subarray)
            e2.set(t2.subarray(r2, r2 + n2), i2);
          else
            for (var s2 = 0; s2 < n2; s2++)
              e2[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e2) {
          var t2, r2, n2, i2, s2, a;
          for (t2 = n2 = 0, r2 = e2.length; t2 < r2; t2++)
            n2 += e2[t2].length;
          for (a = new Uint8Array(n2), t2 = i2 = 0, r2 = e2.length; t2 < r2; t2++)
            s2 = e2[t2], a.set(s2, i2), i2 += s2.length;
          return a;
        } }, s = { arraySet: function(e2, t2, r2, n2, i2) {
          for (var s2 = 0; s2 < n2; s2++)
            e2[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e2) {
          return [].concat.apply([], e2);
        } };
        r.setTyped = function(e2) {
          e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
        }, r.setTyped(n);
      }, {}], 42: [function(e, t, r) {
        var h = e("./common"), i = true, s = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (e2) {
          i = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (e2) {
          s = false;
        }
        for (var u = new h.Buf8(256), n = 0; n < 256; n++)
          u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
        function l(e2, t2) {
          if (t2 < 65537 && (e2.subarray && s || !e2.subarray && i))
            return String.fromCharCode.apply(null, h.shrinkBuf(e2, t2));
          for (var r2 = "", n2 = 0; n2 < t2; n2++)
            r2 += String.fromCharCode(e2[n2]);
          return r2;
        }
        u[254] = u[254] = 1, r.string2buf = function(e2) {
          var t2, r2, n2, i2, s2, a = e2.length, o = 0;
          for (i2 = 0; i2 < a; i2++)
            55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (t2 = new h.Buf8(o), i2 = s2 = 0; s2 < o; i2++)
            55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
          return t2;
        }, r.buf2binstring = function(e2) {
          return l(e2, e2.length);
        }, r.binstring2buf = function(e2) {
          for (var t2 = new h.Buf8(e2.length), r2 = 0, n2 = t2.length; r2 < n2; r2++)
            t2[r2] = e2.charCodeAt(r2);
          return t2;
        }, r.buf2string = function(e2, t2) {
          var r2, n2, i2, s2, a = t2 || e2.length, o = new Array(2 * a);
          for (r2 = n2 = 0; r2 < a; )
            if ((i2 = e2[r2++]) < 128)
              o[n2++] = i2;
            else if (4 < (s2 = u[i2]))
              o[n2++] = 65533, r2 += s2 - 1;
            else {
              for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a; )
                i2 = i2 << 6 | 63 & e2[r2++], s2--;
              1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
            }
          return l(o, n2);
        }, r.utf8border = function(e2, t2) {
          var r2;
          for ((t2 = t2 || e2.length) > e2.length && (t2 = e2.length), r2 = t2 - 1; 0 <= r2 && 128 == (192 & e2[r2]); )
            r2--;
          return r2 < 0 ? t2 : 0 === r2 ? t2 : r2 + u[e2[r2]] > t2 ? r2 : t2;
        };
      }, { "./common": 41 }], 43: [function(e, t, r) {
        t.exports = function(e2, t2, r2, n) {
          for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; 0 !== r2; ) {
            for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t2[n++] | 0) | 0, --a; )
              ;
            i %= 65521, s %= 65521;
          }
          return i | s << 16 | 0;
        };
      }, {}], 44: [function(e, t, r) {
        t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(e, t, r) {
        var o = function() {
          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n = 0; n < 8; n++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r2] = e2;
          }
          return t2;
        }();
        t.exports = function(e2, t2, r2, n) {
          var i = o, s = n + r2;
          e2 ^= -1;
          for (var a = n; a < s; a++)
            e2 = e2 >>> 8 ^ i[255 & (e2 ^ t2[a])];
          return -1 ^ e2;
        };
      }, {}], 46: [function(e, t, r) {
        var h, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p = e("./crc32"), n = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
        function R2(e2, t2) {
          return e2.msg = n[t2], t2;
        }
        function T(e2) {
          return (e2 << 1) - (4 < e2 ? 9 : 0);
        }
        function D(e2) {
          for (var t2 = e2.length; 0 <= --t2; )
            e2[t2] = 0;
        }
        function F(e2) {
          var t2 = e2.state, r2 = t2.pending;
          r2 > e2.avail_out && (r2 = e2.avail_out), 0 !== r2 && (c.arraySet(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, 0 === t2.pending && (t2.pending_out = 0));
        }
        function N(e2, t2) {
          u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, F(e2.strm);
        }
        function U(e2, t2) {
          e2.pending_buf[e2.pending++] = t2;
        }
        function P(e2, t2) {
          e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
        }
        function L(e2, t2) {
          var r2, n2, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h2 = e2.strstart > e2.w_size - z ? e2.strstart - (e2.w_size - z) : 0, u2 = e2.window, l2 = e2.w_mask, f2 = e2.prev, c2 = e2.strstart + S, d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
          e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
          do {
            if (u2[(r2 = t2) + a2] === p2 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
              s2 += 2, r2++;
              do {
              } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);
              if (n2 = S - (c2 - s2), s2 = c2 - S, a2 < n2) {
                if (e2.match_start = t2, o2 <= (a2 = n2))
                  break;
                d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
              }
            }
          } while ((t2 = f2[t2 & l2]) > h2 && 0 != --i2);
          return a2 <= e2.lookahead ? a2 : e2.lookahead;
        }
        function j(e2) {
          var t2, r2, n2, i2, s2, a2, o2, h2, u2, l2, f2 = e2.w_size;
          do {
            if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z)) {
              for (c.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t2 = r2 = e2.hash_size; n2 = e2.head[--t2], e2.head[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
                ;
              for (t2 = r2 = f2; n2 = e2.prev[--t2], e2.prev[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
                ;
              i2 += f2;
            }
            if (0 === e2.strm.avail_in)
              break;
            if (a2 = e2.strm, o2 = e2.window, h2 = e2.strstart + e2.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = 0 === l2 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h2), 1 === a2.state.wrap ? a2.adler = d(a2.adler, o2, l2, h2) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, l2, h2)), a2.next_in += l2, a2.total_in += l2, l2), e2.lookahead += r2, e2.lookahead + e2.insert >= x)
              for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); )
                ;
          } while (e2.lookahead < z && 0 !== e2.strm.avail_in);
        }
        function Z(e2, t2) {
          for (var r2, n2; ; ) {
            if (e2.lookahead < z) {
              if (j(e2), e2.lookahead < z && t2 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r2 && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2)), e2.match_length >= x)
              if (n2 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {
                for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, 0 != --e2.match_length; )
                  ;
                e2.strstart++;
              } else
                e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
            else
              n2 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
            if (n2 && (N(e2, false), 0 === e2.strm.avail_out))
              return A;
          }
          return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
        }
        function W(e2, t2) {
          for (var r2, n2, i2; ; ) {
            if (e2.lookahead < z) {
              if (j(e2), e2.lookahead < z && t2 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, 0 !== r2 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2), e2.match_length <= 5 && (1 === e2.strategy || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {
              for (i2 = e2.strstart + e2.lookahead - x, n2 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 != --e2.prev_length; )
                ;
              if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n2 && (N(e2, false), 0 === e2.strm.avail_out))
                return A;
            } else if (e2.match_available) {
              if ((n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out)
                return A;
            } else
              e2.match_available = 1, e2.strstart++, e2.lookahead--;
          }
          return e2.match_available && (n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
        }
        function M(e2, t2, r2, n2, i2) {
          this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n2, this.func = i2;
        }
        function H() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function G(e2) {
          var t2;
          return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t2 = e2.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? C : E, e2.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = l, u._tr_init(t2), m) : R2(e2, _);
        }
        function K(e2) {
          var t2 = G(e2);
          return t2 === m && function(e3) {
            e3.window_size = 2 * e3.w_size, D(e3.head), e3.max_lazy_match = h[e3.level].max_lazy, e3.good_match = h[e3.level].good_length, e3.nice_match = h[e3.level].nice_length, e3.max_chain_length = h[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
          }(e2.state), t2;
        }
        function Y(e2, t2, r2, n2, i2, s2) {
          if (!e2)
            return _;
          var a2 = 1;
          if (t2 === g && (t2 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y < i2 || r2 !== v || n2 < 8 || 15 < n2 || t2 < 0 || 9 < t2 || s2 < 0 || b < s2)
            return R2(e2, _);
          8 === n2 && (n2 = 9);
          var o2 = new H();
          return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t2, o2.strategy = s2, o2.method = r2, K(e2);
        }
        h = [new M(0, 0, 0, 0, function(e2, t2) {
          var r2 = 65535;
          for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
            if (e2.lookahead <= 1) {
              if (j(e2), 0 === e2.lookahead && t2 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            e2.strstart += e2.lookahead, e2.lookahead = 0;
            var n2 = e2.block_start + r2;
            if ((0 === e2.strstart || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, N(e2, false), 0 === e2.strm.avail_out))
              return A;
            if (e2.strstart - e2.block_start >= e2.w_size - z && (N(e2, false), 0 === e2.strm.avail_out))
              return A;
          }
          return e2.insert = 0, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A);
        }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(e2, t2) {
          return Y(e2, t2, v, 15, 8, 0);
        }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(e2, t2) {
          return e2 && e2.state ? 2 !== e2.state.wrap ? _ : (e2.state.gzhead = t2, m) : _;
        }, r.deflate = function(e2, t2) {
          var r2, n2, i2, s2;
          if (!e2 || !e2.state || 5 < t2 || t2 < 0)
            return e2 ? R2(e2, _) : _;
          if (n2 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || 666 === n2.status && t2 !== f)
            return R2(e2, 0 === e2.avail_out ? -5 : _);
          if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t2, n2.status === C)
            if (2 === n2.wrap)
              e2.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E);
            else {
              var a2 = v + (n2.w_bits - 8 << 4) << 8;
              a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E, P(n2, a2), 0 !== n2.strstart && (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), e2.adler = 1;
            }
          if (69 === n2.status)
            if (n2.gzhead.extra) {
              for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); )
                U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
            } else
              n2.status = 73;
          if (73 === n2.status)
            if (n2.gzhead.name) {
              i2 = n2.pending;
              do {
                if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
              } while (0 !== s2);
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.gzindex = 0, n2.status = 91);
            } else
              n2.status = 91;
          if (91 === n2.status)
            if (n2.gzhead.comment) {
              i2 = n2.pending;
              do {
                if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
              } while (0 !== s2);
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.status = 103);
            } else
              n2.status = 103;
          if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F(e2), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = E)) : n2.status = E), 0 !== n2.pending) {
            if (F(e2), 0 === e2.avail_out)
              return n2.last_flush = -1, m;
          } else if (0 === e2.avail_in && T(t2) <= T(r2) && t2 !== f)
            return R2(e2, -5);
          if (666 === n2.status && 0 !== e2.avail_in)
            return R2(e2, -5);
          if (0 !== e2.avail_in || 0 !== n2.lookahead || t2 !== l && 666 !== n2.status) {
            var o2 = 2 === n2.strategy ? function(e3, t3) {
              for (var r3; ; ) {
                if (0 === e3.lookahead && (j(e3), 0 === e3.lookahead)) {
                  if (t3 === l)
                    return A;
                  break;
                }
                if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), 0 === e3.strm.avail_out))
                  return A;
              }
              return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
            }(n2, t2) : 3 === n2.strategy ? function(e3, t3) {
              for (var r3, n3, i3, s3, a3 = e3.window; ; ) {
                if (e3.lookahead <= S) {
                  if (j(e3), e3.lookahead <= S && t3 === l)
                    return A;
                  if (0 === e3.lookahead)
                    break;
                }
                if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                  s3 = e3.strstart + S;
                  do {
                  } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                  e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
                }
                if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), 0 === e3.strm.avail_out))
                  return A;
              }
              return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
            }(n2, t2) : h[n2.level].func(n2, t2);
            if (o2 !== O && o2 !== B || (n2.status = 666), o2 === A || o2 === O)
              return 0 === e2.avail_out && (n2.last_flush = -1), m;
            if (o2 === I && (1 === t2 ? u._tr_align(n2) : 5 !== t2 && (u._tr_stored_block(n2, 0, 0, false), 3 === t2 && (D(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F(e2), 0 === e2.avail_out))
              return n2.last_flush = -1, m;
          }
          return t2 !== f ? m : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), U(n2, e2.adler >> 16 & 255), U(n2, e2.adler >> 24 & 255), U(n2, 255 & e2.total_in), U(n2, e2.total_in >> 8 & 255), U(n2, e2.total_in >> 16 & 255), U(n2, e2.total_in >> 24 & 255)) : (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), F(e2), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m : 1);
        }, r.deflateEnd = function(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state.status) !== C && 69 !== t2 && 73 !== t2 && 91 !== t2 && 103 !== t2 && t2 !== E && 666 !== t2 ? R2(e2, _) : (e2.state = null, t2 === E ? R2(e2, -3) : m) : _;
        }, r.deflateSetDictionary = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h2, u2, l2 = t2.length;
          if (!e2 || !e2.state)
            return _;
          if (2 === (s2 = (r2 = e2.state).wrap) || 1 === s2 && r2.status !== C || r2.lookahead)
            return _;
          for (1 === s2 && (e2.adler = d(e2.adler, t2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (0 === s2 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t2, l2 - r2.w_size, r2.w_size, 0), t2 = u2, l2 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h2 = e2.input, e2.avail_in = l2, e2.next_in = 0, e2.input = t2, j(r2); r2.lookahead >= x; ) {
            for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; )
              ;
            r2.strstart = n2, r2.lookahead = x - 1, j(r2);
          }
          return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h2, e2.avail_in = a2, r2.wrap = s2, m;
        }, r.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t, r) {
        t.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
      }, {}], 48: [function(e, t, r) {
        t.exports = function(e2, t2) {
          var r2, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C;
          r2 = e2.state, n = e2.next_in, z = e2.input, i = n + (e2.avail_in - 5), s = e2.next_out, C = e2.output, a = s - (t2 - e2.avail_out), o = s + (e2.avail_out - 257), h = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
          e:
            do {
              p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = m[d & g];
              t:
                for (; ; ) {
                  if (d >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255))
                    C[s++] = 65535 & v;
                  else {
                    if (!(16 & y)) {
                      if (0 == (64 & y)) {
                        v = m[(65535 & v) + (d & (1 << y) - 1)];
                        continue t;
                      }
                      if (32 & y) {
                        r2.mode = 12;
                        break e;
                      }
                      e2.msg = "invalid literal/length code", r2.mode = 30;
                      break e;
                    }
                    w = 65535 & v, (y &= 15) && (p < y && (d += z[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = _[d & b];
                    r:
                      for (; ; ) {
                        if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                          if (0 == (64 & y)) {
                            v = _[(65535 & v) + (d & (1 << y) - 1)];
                            continue r;
                          }
                          e2.msg = "invalid distance code", r2.mode = 30;
                          break e;
                        }
                        if (k = 65535 & v, p < (y &= 15) && (d += z[n++] << p, (p += 8) < y && (d += z[n++] << p, p += 8)), h < (k += d & (1 << y) - 1)) {
                          e2.msg = "invalid distance too far back", r2.mode = 30;
                          break e;
                        }
                        if (d >>>= y, p -= y, (y = s - a) < k) {
                          if (l < (y = k - y) && r2.sane) {
                            e2.msg = "invalid distance too far back", r2.mode = 30;
                            break e;
                          }
                          if (S = c, (x = 0) === f) {
                            if (x += u - y, y < w) {
                              for (w -= y; C[s++] = c[x++], --y; )
                                ;
                              x = s - k, S = C;
                            }
                          } else if (f < y) {
                            if (x += u + f - y, (y -= f) < w) {
                              for (w -= y; C[s++] = c[x++], --y; )
                                ;
                              if (x = 0, f < w) {
                                for (w -= y = f; C[s++] = c[x++], --y; )
                                  ;
                                x = s - k, S = C;
                              }
                            }
                          } else if (x += f - y, y < w) {
                            for (w -= y; C[s++] = c[x++], --y; )
                              ;
                            x = s - k, S = C;
                          }
                          for (; 2 < w; )
                            C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                          w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                        } else {
                          for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); )
                            ;
                          w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                        }
                        break;
                      }
                  }
                  break;
                }
            } while (n < i && s < o);
          n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e2.next_in = n, e2.next_out = s, e2.avail_in = n < i ? i - n + 5 : 5 - (n - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p;
        };
      }, {}], 49: [function(e, t, r) {
        var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R2 = e("./inffast"), T = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
        function L(e2) {
          return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
        }
        function s() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function a(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state, e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = P, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new I.Buf32(n), t2.distcode = t2.distdyn = new I.Buf32(i), t2.sane = 1, t2.back = -1, N) : U;
        }
        function o(e2) {
          var t2;
          return e2 && e2.state ? ((t2 = e2.state).wsize = 0, t2.whave = 0, t2.wnext = 0, a(e2)) : U;
        }
        function h(e2, t2) {
          var r2, n2;
          return e2 && e2.state ? (n2 = e2.state, t2 < 0 ? (r2 = 0, t2 = -t2) : (r2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || 15 < t2) ? U : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = r2, n2.wbits = t2, o(e2))) : U;
        }
        function u(e2, t2) {
          var r2, n2;
          return e2 ? (n2 = new s(), (e2.state = n2).window = null, (r2 = h(e2, t2)) !== N && (e2.state = null), r2) : U;
        }
        var l, f, c = true;
        function j(e2) {
          if (c) {
            var t2;
            for (l = new I.Buf32(512), f = new I.Buf32(32), t2 = 0; t2 < 144; )
              e2.lens[t2++] = 8;
            for (; t2 < 256; )
              e2.lens[t2++] = 9;
            for (; t2 < 280; )
              e2.lens[t2++] = 7;
            for (; t2 < 288; )
              e2.lens[t2++] = 8;
            for (T(D, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; )
              e2.lens[t2++] = 5;
            T(F, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c = false;
          }
          e2.lencode = l, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
        }
        function Z(e2, t2, r2, n2) {
          var i2, s2 = e2.state;
          return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n2 >= s2.wsize ? (I.arraySet(s2.window, t2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I.arraySet(s2.window, t2, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I.arraySet(s2.window, t2, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
        }
        r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(e2) {
          return u(e2, 15);
        }, r.inflateInit2 = u, r.inflate = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h2, u2, l2, f2, c2, d, p, m, _, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in)
            return U;
          12 === (r2 = e2.state).mode && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c2 = h2, x = N;
          e:
            for (; ; )
              switch (r2.mode) {
                case P:
                  if (0 === r2.wrap) {
                    r2.mode = 13;
                    break;
                  }
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (2 & r2.wrap && 35615 === u2) {
                    E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                    break;
                  }
                  if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                    e2.msg = "incorrect header check", r2.mode = 30;
                    break;
                  }
                  if (8 != (15 & u2)) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r2.wbits)
                    r2.wbits = k;
                  else if (k > r2.wbits) {
                    e2.msg = "invalid window size", r2.mode = 30;
                    break;
                  }
                  r2.dmax = 1 << k, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
                  break;
                case 2:
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (r2.flags = u2, 8 != (255 & r2.flags)) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (57344 & r2.flags) {
                    e2.msg = "unknown header flags set", r2.mode = 30;
                    break;
                  }
                  r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
                case 3:
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
                case 4:
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
                case 5:
                  if (1024 & r2.flags) {
                    for (; l2 < 16; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
                  } else
                    r2.head && (r2.head.extra = null);
                  r2.mode = 6;
                case 6:
                  if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n2, s2, d, k)), 512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length))
                    break e;
                  r2.length = 0, r2.mode = 7;
                case 7:
                  if (2048 & r2.flags) {
                    if (0 === o2)
                      break e;
                    for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d < o2; )
                      ;
                    if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                      break e;
                  } else
                    r2.head && (r2.head.name = null);
                  r2.length = 0, r2.mode = 8;
                case 8:
                  if (4096 & r2.flags) {
                    if (0 === o2)
                      break e;
                    for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d < o2; )
                      ;
                    if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                      break e;
                  } else
                    r2.head && (r2.head.comment = null);
                  r2.mode = 9;
                case 9:
                  if (512 & r2.flags) {
                    for (; l2 < 16; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (u2 !== (65535 & r2.check)) {
                      e2.msg = "header crc mismatch", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
                  break;
                case 10:
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  e2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
                case 11:
                  if (0 === r2.havedict)
                    return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
                  e2.adler = r2.check = 1, r2.mode = 12;
                case 12:
                  if (5 === t2 || 6 === t2)
                    break e;
                case 13:
                  if (r2.last) {
                    u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                    break;
                  }
                  for (; l2 < 3; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                    case 0:
                      r2.mode = 14;
                      break;
                    case 1:
                      if (j(r2), r2.mode = 20, 6 !== t2)
                        break;
                      u2 >>>= 2, l2 -= 2;
                      break e;
                    case 2:
                      r2.mode = 17;
                      break;
                    case 3:
                      e2.msg = "invalid block type", r2.mode = 30;
                  }
                  u2 >>>= 2, l2 -= 2;
                  break;
                case 14:
                  for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                    e2.msg = "invalid stored block lengths", r2.mode = 30;
                    break;
                  }
                  if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, 6 === t2)
                    break e;
                case 15:
                  r2.mode = 16;
                case 16:
                  if (d = r2.length) {
                    if (o2 < d && (d = o2), h2 < d && (d = h2), 0 === d)
                      break e;
                    I.arraySet(i2, n2, s2, d, a2), o2 -= d, s2 += d, h2 -= d, a2 += d, r2.length -= d;
                    break;
                  }
                  r2.mode = 12;
                  break;
                case 17:
                  for (; l2 < 14; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                    e2.msg = "too many length or distance symbols", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 18;
                case 18:
                  for (; r2.have < r2.ncode; ) {
                    for (; l2 < 3; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
                  }
                  for (; r2.have < 19; )
                    r2.lens[A[r2.have++]] = 0;
                  if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                    e2.msg = "invalid code lengths set", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 19;
                case 19:
                  for (; r2.have < r2.nlen + r2.ndist; ) {
                    for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (b < 16)
                      u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                    else {
                      if (16 === b) {
                        for (z = _ + 2; l2 < z; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        if (u2 >>>= _, l2 -= _, 0 === r2.have) {
                          e2.msg = "invalid bit length repeat", r2.mode = 30;
                          break;
                        }
                        k = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                      } else if (17 === b) {
                        for (z = _ + 3; l2 < z; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        l2 -= _, k = 0, d = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                      } else {
                        for (z = _ + 7; l2 < z; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        l2 -= _, k = 0, d = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                      }
                      if (r2.have + d > r2.nlen + r2.ndist) {
                        e2.msg = "invalid bit length repeat", r2.mode = 30;
                        break;
                      }
                      for (; d--; )
                        r2.lens[r2.have++] = k;
                    }
                  }
                  if (30 === r2.mode)
                    break;
                  if (0 === r2.lens[256]) {
                    e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                    break;
                  }
                  if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                    e2.msg = "invalid literal/lengths set", r2.mode = 30;
                    break;
                  }
                  if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                    e2.msg = "invalid distances set", r2.mode = 30;
                    break;
                  }
                  if (r2.mode = 20, 6 === t2)
                    break e;
                case 20:
                  r2.mode = 21;
                case 21:
                  if (6 <= o2 && 258 <= h2) {
                    e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, R2(e2, c2), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, 12 === r2.mode && (r2.back = -1);
                    break;
                  }
                  for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (g && 0 == (240 & g)) {
                    for (v = _, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    u2 >>>= v, l2 -= v, r2.back += v;
                  }
                  if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, 0 === g) {
                    r2.mode = 26;
                    break;
                  }
                  if (32 & g) {
                    r2.back = -1, r2.mode = 12;
                    break;
                  }
                  if (64 & g) {
                    e2.msg = "invalid literal/length code", r2.mode = 30;
                    break;
                  }
                  r2.extra = 15 & g, r2.mode = 22;
                case 22:
                  if (r2.extra) {
                    for (z = r2.extra; l2 < z; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                  }
                  r2.was = r2.length, r2.mode = 23;
                case 23:
                  for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (0 == (240 & g)) {
                    for (v = _, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    u2 >>>= v, l2 -= v, r2.back += v;
                  }
                  if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                    e2.msg = "invalid distance code", r2.mode = 30;
                    break;
                  }
                  r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
                case 24:
                  if (r2.extra) {
                    for (z = r2.extra; l2 < z; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                  }
                  if (r2.offset > r2.dmax) {
                    e2.msg = "invalid distance too far back", r2.mode = 30;
                    break;
                  }
                  r2.mode = 25;
                case 25:
                  if (0 === h2)
                    break e;
                  if (d = c2 - h2, r2.offset > d) {
                    if ((d = r2.offset - d) > r2.whave && r2.sane) {
                      e2.msg = "invalid distance too far back", r2.mode = 30;
                      break;
                    }
                    p = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m = r2.window;
                  } else
                    m = i2, p = a2 - r2.offset, d = r2.length;
                  for (h2 < d && (d = h2), h2 -= d, r2.length -= d; i2[a2++] = m[p++], --d; )
                    ;
                  0 === r2.length && (r2.mode = 21);
                  break;
                case 26:
                  if (0 === h2)
                    break e;
                  i2[a2++] = r2.length, h2--, r2.mode = 21;
                  break;
                case 27:
                  if (r2.wrap) {
                    for (; l2 < 32; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 |= n2[s2++] << l2, l2 += 8;
                    }
                    if (c2 -= h2, e2.total_out += c2, r2.total += c2, c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)), c2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {
                      e2.msg = "incorrect data check", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.mode = 28;
                case 28:
                  if (r2.wrap && r2.flags) {
                    for (; l2 < 32; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (u2 !== (4294967295 & r2.total)) {
                      e2.msg = "incorrect length check", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.mode = 29;
                case 29:
                  x = 1;
                  break e;
                case 30:
                  x = -3;
                  break e;
                case 31:
                  return -4;
                case 32:
                default:
                  return U;
              }
          return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t2)) && Z(e2, e2.output, e2.next_out, c2 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c2 -= e2.avail_out, e2.total_in += f2, e2.total_out += c2, r2.total += c2, r2.wrap && c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, e2.next_out - c2) : O(r2.check, i2, c2, e2.next_out - c2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === c2 || 4 === t2) && x === N && (x = -5), x);
        }, r.inflateEnd = function(e2) {
          if (!e2 || !e2.state)
            return U;
          var t2 = e2.state;
          return t2.window && (t2.window = null), e2.state = null, N;
        }, r.inflateGetHeader = function(e2, t2) {
          var r2;
          return e2 && e2.state ? 0 == (2 & (r2 = e2.state).wrap) ? U : ((r2.head = t2).done = false, N) : U;
        }, r.inflateSetDictionary = function(e2, t2) {
          var r2, n2 = t2.length;
          return e2 && e2.state ? 0 !== (r2 = e2.state).wrap && 11 !== r2.mode ? U : 11 === r2.mode && O(1, t2, n2, 0) !== r2.check ? -3 : Z(e2, t2, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
        }, r.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t, r) {
        var D = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        t.exports = function(e2, t2, r2, n, i, s, a, o) {
          var h, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R2 = null, T = 0;
          for (b = 0; b <= 15; b++)
            O[b] = 0;
          for (v = 0; v < n; v++)
            O[t2[r2 + v]]++;
          for (k = g, w = 15; 1 <= w && 0 === O[w]; w--)
            ;
          if (w < k && (k = w), 0 === w)
            return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
          for (y = 1; y < w && 0 === O[y]; y++)
            ;
          for (k < y && (k = y), b = z = 1; b <= 15; b++)
            if (z <<= 1, (z -= O[b]) < 0)
              return -1;
          if (0 < z && (0 === e2 || 1 !== w))
            return -1;
          for (B[1] = 0, b = 1; b < 15; b++)
            B[b + 1] = B[b] + O[b];
          for (v = 0; v < n; v++)
            0 !== t2[r2 + v] && (a[B[t2[r2 + v]]++] = v);
          if (d = 0 === e2 ? (A = R2 = a, 19) : 1 === e2 ? (A = F, I -= 257, R2 = N, T -= 257, 256) : (A = U, R2 = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
            return 1;
          for (; ; ) {
            for (p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R2[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u; )
              ;
            for (h = 1 << b - 1; E & h; )
              h >>= 1;
            if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b]) {
              if (b === w)
                break;
              b = t2[r2 + a[v]];
            }
            if (k < b && (E & f) !== l) {
              for (0 === S && (S = k), c += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0); )
                x++, z <<= 1;
              if (C += 1 << x, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
                return 1;
              i[l = E & f] = k << 24 | x << 16 | c - s | 0;
            }
          }
          return 0 !== E && (i[c + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(e, t, r) {
        t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(e, t, r) {
        var i = e("../utils/common"), o = 0, h = 1;
        function n(e2) {
          for (var t2 = e2.length; 0 <= --t2; )
            e2[t2] = 0;
        }
        var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
        n(z);
        var C = new Array(2 * f);
        n(C);
        var E = new Array(512);
        n(E);
        var A = new Array(256);
        n(A);
        var I = new Array(a);
        n(I);
        var O, B, R2, T = new Array(f);
        function D(e2, t2, r2, n2, i2) {
          this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
        }
        function F(e2, t2) {
          this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
        }
        function N(e2) {
          return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)];
        }
        function U(e2, t2) {
          e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
        }
        function P(e2, t2, r2) {
          e2.bi_valid > d - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, U(e2, e2.bi_buf), e2.bi_buf = t2 >> d - e2.bi_valid, e2.bi_valid += r2 - d) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);
        }
        function L(e2, t2, r2) {
          P(e2, r2[2 * t2], r2[2 * t2 + 1]);
        }
        function j(e2, t2) {
          for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t2; )
            ;
          return r2 >>> 1;
        }
        function Z(e2, t2, r2) {
          var n2, i2, s2 = new Array(g + 1), a2 = 0;
          for (n2 = 1; n2 <= g; n2++)
            s2[n2] = a2 = a2 + r2[n2 - 1] << 1;
          for (i2 = 0; i2 <= t2; i2++) {
            var o2 = e2[2 * i2 + 1];
            0 !== o2 && (e2[2 * i2] = j(s2[o2]++, o2));
          }
        }
        function W(e2) {
          var t2;
          for (t2 = 0; t2 < l; t2++)
            e2.dyn_ltree[2 * t2] = 0;
          for (t2 = 0; t2 < f; t2++)
            e2.dyn_dtree[2 * t2] = 0;
          for (t2 = 0; t2 < c; t2++)
            e2.bl_tree[2 * t2] = 0;
          e2.dyn_ltree[2 * m] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
        }
        function M(e2) {
          8 < e2.bi_valid ? U(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
        }
        function H(e2, t2, r2, n2) {
          var i2 = 2 * t2, s2 = 2 * r2;
          return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n2[t2] <= n2[r2];
        }
        function G(e2, t2, r2) {
          for (var n2 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H(t2, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H(t2, n2, e2.heap[i2], e2.depth)); )
            e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
          e2.heap[r2] = n2;
        }
        function K(e2, t2, r2) {
          var n2, i2, s2, a2, o2 = 0;
          if (0 !== e2.last_lit)
            for (; n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, 0 === n2 ? L(e2, i2, t2) : (L(e2, (s2 = A[i2]) + u + 1, t2), 0 !== (a2 = w[s2]) && P(e2, i2 -= I[s2], a2), L(e2, s2 = N(--n2), r2), 0 !== (a2 = k[s2]) && P(e2, n2 -= T[s2], a2)), o2 < e2.last_lit; )
              ;
          L(e2, m, t2);
        }
        function Y(e2, t2) {
          var r2, n2, i2, s2 = t2.dyn_tree, a2 = t2.stat_desc.static_tree, o2 = t2.stat_desc.has_stree, h2 = t2.stat_desc.elems, u2 = -1;
          for (e2.heap_len = 0, e2.heap_max = _, r2 = 0; r2 < h2; r2++)
            0 !== s2[2 * r2] ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
          for (; e2.heap_len < 2; )
            s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
          for (t2.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--)
            G(e2, s2, r2);
          for (i2 = h2; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G(e2, s2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n2] ? e2.depth[r2] : e2.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e2.heap[1] = i2++, G(e2, s2, 1), 2 <= e2.heap_len; )
            ;
          e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t3) {
            var r3, n3, i3, s3, a3, o3, h3 = t3.dyn_tree, u3 = t3.max_code, l2 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, c2 = t3.stat_desc.extra_bits, d2 = t3.stat_desc.extra_base, p2 = t3.stat_desc.max_length, m2 = 0;
            for (s3 = 0; s3 <= g; s3++)
              e3.bl_count[s3] = 0;
            for (h3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _; r3++)
              p2 < (s3 = h3[2 * h3[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d2 <= n3 && (a3 = c2[n3 - d2]), o3 = h3[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n3 + 1] + a3)));
            if (0 !== m2) {
              do {
                for (s3 = p2 - 1; 0 === e3.bl_count[s3]; )
                  s3--;
                e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
              } while (0 < m2);
              for (s3 = p2; 0 !== s3; s3--)
                for (n3 = e3.bl_count[s3]; 0 !== n3; )
                  u3 < (i3 = e3.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n3--);
            }
          }(e2, t2), Z(s2, u2, e2.bl_count);
        }
        function X(e2, t2, r2) {
          var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
          for (0 === a2 && (h2 = 138, u2 = 3), t2[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++)
            i2 = a2, a2 = t2[2 * (n2 + 1) + 1], ++o2 < h2 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v]++ : e2.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
        }
        function V(e2, t2, r2) {
          var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
          for (0 === a2 && (h2 = 138, u2 = 3), n2 = 0; n2 <= r2; n2++)
            if (i2 = a2, a2 = t2[2 * (n2 + 1) + 1], !(++o2 < h2 && i2 === a2)) {
              if (o2 < u2)
                for (; L(e2, i2, e2.bl_tree), 0 != --o2; )
                  ;
              else
                0 !== i2 ? (i2 !== s2 && (L(e2, i2, e2.bl_tree), o2--), L(e2, b, e2.bl_tree), P(e2, o2 - 3, 2)) : o2 <= 10 ? (L(e2, v, e2.bl_tree), P(e2, o2 - 3, 3)) : (L(e2, y, e2.bl_tree), P(e2, o2 - 11, 7));
              s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
            }
        }
        n(T);
        var q = false;
        function J(e2, t2, r2, n2) {
          P(e2, (s << 1) + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
            M(e3), n3 && (U(e3, r3), U(e3, ~r3)), i.arraySet(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
          }(e2, t2, r2, true);
        }
        r._tr_init = function(e2) {
          q || (function() {
            var e3, t2, r2, n2, i2, s2 = new Array(g + 1);
            for (n2 = r2 = 0; n2 < a - 1; n2++)
              for (I[n2] = r2, e3 = 0; e3 < 1 << w[n2]; e3++)
                A[r2++] = n2;
            for (A[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++)
              for (T[n2] = i2, e3 = 0; e3 < 1 << k[n2]; e3++)
                E[i2++] = n2;
            for (i2 >>= 7; n2 < f; n2++)
              for (T[n2] = i2 << 7, e3 = 0; e3 < 1 << k[n2] - 7; e3++)
                E[256 + i2++] = n2;
            for (t2 = 0; t2 <= g; t2++)
              s2[t2] = 0;
            for (e3 = 0; e3 <= 143; )
              z[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (; e3 <= 255; )
              z[2 * e3 + 1] = 9, e3++, s2[9]++;
            for (; e3 <= 279; )
              z[2 * e3 + 1] = 7, e3++, s2[7]++;
            for (; e3 <= 287; )
              z[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (Z(z, l + 1, s2), e3 = 0; e3 < f; e3++)
              C[2 * e3 + 1] = 5, C[2 * e3] = j(e3, 5);
            O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R2 = new D(new Array(0), x, 0, c, p);
          }(), q = true), e2.l_desc = new F(e2.dyn_ltree, O), e2.d_desc = new F(e2.dyn_dtree, B), e2.bl_desc = new F(e2.bl_tree, R2), e2.bi_buf = 0, e2.bi_valid = 0, W(e2);
        }, r._tr_stored_block = J, r._tr_flush_block = function(e2, t2, r2, n2) {
          var i2, s2, a2 = 0;
          0 < e2.level ? (2 === e2.strm.data_type && (e2.strm.data_type = function(e3) {
            var t3, r3 = 4093624447;
            for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1)
              if (1 & r3 && 0 !== e3.dyn_ltree[2 * t3])
                return o;
            if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26])
              return h;
            for (t3 = 32; t3 < u; t3++)
              if (0 !== e3.dyn_ltree[2 * t3])
                return h;
            return o;
          }(e2)), Y(e2, e2.l_desc), Y(e2, e2.d_desc), a2 = function(e3) {
            var t3;
            for (X(e3, e3.dyn_ltree, e3.l_desc.max_code), X(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t3 = c - 1; 3 <= t3 && 0 === e3.bl_tree[2 * S[t3] + 1]; t3--)
              ;
            return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
          }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && -1 !== t2 ? J(e2, t2, r2, n2) : 4 === e2.strategy || s2 === i2 ? (P(e2, 2 + (n2 ? 1 : 0), 3), K(e2, z, C)) : (P(e2, 4 + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
            var i3;
            for (P(e3, t3 - 257, 5), P(e3, r3 - 1, 5), P(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++)
              P(e3, e3.bl_tree[2 * S[i3] + 1], 3);
            V(e3, e3.dyn_ltree, t3 - 1), V(e3, e3.dyn_dtree, r3 - 1);
          }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K(e2, e2.dyn_ltree, e2.dyn_dtree)), W(e2), n2 && M(e2);
        }, r._tr_tally = function(e2, t2, r2) {
          return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, 0 === t2 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
        }, r._tr_align = function(e2) {
          P(e2, 2, 3), L(e2, m, z), function(e3) {
            16 === e3.bi_valid ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
          }(e2);
        };
      }, { "../utils/common": 41 }], 53: [function(e, t, r) {
        t.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(e, t, r) {
        (function(e2) {
          !function(r2, n) {
            if (!r2.setImmediate) {
              var i, s, t2, a, o = 1, h = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
              e3 = e3 && e3.setTimeout ? e3 : r2, i = "[object process]" === {}.toString.call(r2.process) ? function(e4) {
                process$1.nextTick(function() {
                  c(e4);
                });
              } : function() {
                if (r2.postMessage && !r2.importScripts) {
                  var e4 = true, t3 = r2.onmessage;
                  return r2.onmessage = function() {
                    e4 = false;
                  }, r2.postMessage("", "*"), r2.onmessage = t3, e4;
                }
              }() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d, false) : r2.attachEvent("onmessage", d), function(e4) {
                r2.postMessage(a + e4, "*");
              }) : r2.MessageChannel ? ((t2 = new MessageChannel()).port1.onmessage = function(e4) {
                c(e4.data);
              }, function(e4) {
                t2.port2.postMessage(e4);
              }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e4) {
                var t3 = l.createElement("script");
                t3.onreadystatechange = function() {
                  c(e4), t3.onreadystatechange = null, s.removeChild(t3), t3 = null;
                }, s.appendChild(t3);
              }) : function(e4) {
                setTimeout(c, 0, e4);
              }, e3.setImmediate = function(e4) {
                "function" != typeof e4 && (e4 = new Function("" + e4));
                for (var t3 = new Array(arguments.length - 1), r3 = 0; r3 < t3.length; r3++)
                  t3[r3] = arguments[r3 + 1];
                var n2 = { callback: e4, args: t3 };
                return h[o] = n2, i(o), o++;
              }, e3.clearImmediate = f;
            }
            function f(e4) {
              delete h[e4];
            }
            function c(e4) {
              if (u)
                setTimeout(c, 0, e4);
              else {
                var t3 = h[e4];
                if (t3) {
                  u = true;
                  try {
                    !function(e5) {
                      var t4 = e5.callback, r3 = e5.args;
                      switch (r3.length) {
                        case 0:
                          t4();
                          break;
                        case 1:
                          t4(r3[0]);
                          break;
                        case 2:
                          t4(r3[0], r3[1]);
                          break;
                        case 3:
                          t4(r3[0], r3[1], r3[2]);
                          break;
                        default:
                          t4.apply(n, r3);
                      }
                    }(t3);
                  } finally {
                    f(e4), u = false;
                  }
                }
              }
            }
            function d(e4) {
              e4.source === r2 && "string" == typeof e4.data && 0 === e4.data.indexOf(a) && c(+e4.data.slice(a.length));
            }
          }("undefined" == typeof self ? void 0 === e2 ? this : e2 : self);
        }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}] }, {}, [10])(10);
    });
  })(jszip_min);
  var jszip_minExports = jszip_min.exports;
  var JSZip = /* @__PURE__ */ getDefaultExportFromCjs(jszip_minExports);
  var xml$2 = { exports: {} };
  var XML_CHARACTER_MAP = {
    "&": "&amp;",
    '"': "&quot;",
    "'": "&apos;",
    "<": "&lt;",
    ">": "&gt;"
  };
  function escapeForXML$1(string) {
    return string && string.replace ? string.replace(/([&"<>'])/g, function(str, item) {
      return XML_CHARACTER_MAP[item];
    }) : string;
  }
  var escapeForXML_1 = escapeForXML$1;
  var escapeForXML = escapeForXML_1;
  var Stream = streamBrowserify.Stream;
  var DEFAULT_INDENT = "    ";
  function xml(input, options2) {
    if (typeof options2 !== "object") {
      options2 = {
        indent: options2
      };
    }
    var stream = options2.stream ? new Stream() : null, output = "", interrupted = false, indent = !options2.indent ? "" : options2.indent === true ? DEFAULT_INDENT : options2.indent, instant = true;
    function delay(func) {
      if (!instant) {
        func();
      } else {
        process$1.nextTick(func);
      }
    }
    function append(interrupt, out) {
      if (out !== void 0) {
        output += out;
      }
      if (interrupt && !interrupted) {
        stream = stream || new Stream();
        interrupted = true;
      }
      if (interrupt && interrupted) {
        var data = output;
        delay(function() {
          stream.emit("data", data);
        });
        output = "";
      }
    }
    function add(value, last) {
      format(append, resolve(value, indent, indent ? 1 : 0), last);
    }
    function end() {
      if (stream) {
        var data = output;
        delay(function() {
          stream.emit("data", data);
          stream.emit("end");
          stream.readable = false;
          stream.emit("close");
        });
      }
    }
    function addXmlDeclaration(declaration) {
      var encoding = declaration.encoding || "UTF-8", attr2 = { version: "1.0", encoding };
      if (declaration.standalone) {
        attr2.standalone = declaration.standalone;
      }
      add({ "?xml": { _attr: attr2 } });
      output = output.replace("/>", "?>");
    }
    delay(function() {
      instant = false;
    });
    if (options2.declaration) {
      addXmlDeclaration(options2.declaration);
    }
    if (input && input.forEach) {
      input.forEach(function(value, i) {
        var last;
        if (i + 1 === input.length)
          last = end;
        add(value, last);
      });
    } else {
      add(input, end);
    }
    if (stream) {
      stream.readable = true;
      return stream;
    }
    return output;
  }
  function element() {
    var input = Array.prototype.slice.call(arguments), self2 = {
      _elem: resolve(input)
    };
    self2.push = function(input2) {
      if (!this.append) {
        throw new Error("not assigned to a parent!");
      }
      var that = this;
      var indent = this._elem.indent;
      format(
        this.append,
        resolve(
          input2,
          indent,
          this._elem.icount + (indent ? 1 : 0)
        ),
        function() {
          that.append(true);
        }
      );
    };
    self2.close = function(input2) {
      if (input2 !== void 0) {
        this.push(input2);
      }
      if (this.end) {
        this.end();
      }
    };
    return self2;
  }
  function create_indent(character, count) {
    return new Array(count || 0).join(character || "");
  }
  function resolve(data, indent, indent_count) {
    indent_count = indent_count || 0;
    var indent_spaces = create_indent(indent, indent_count);
    var name;
    var values = data;
    var interrupt = false;
    if (typeof data === "object") {
      var keys = Object.keys(data);
      name = keys[0];
      values = data[name];
      if (values && values._elem) {
        values._elem.name = name;
        values._elem.icount = indent_count;
        values._elem.indent = indent;
        values._elem.indents = indent_spaces;
        values._elem.interrupt = values;
        return values._elem;
      }
    }
    var attributes = [], content = [];
    var isStringContent;
    function get_attributes(obj) {
      var keys2 = Object.keys(obj);
      keys2.forEach(function(key) {
        attributes.push(attribute(key, obj[key]));
      });
    }
    switch (typeof values) {
      case "object":
        if (values === null)
          break;
        if (values._attr) {
          get_attributes(values._attr);
        }
        if (values._cdata) {
          content.push(
            ("<![CDATA[" + values._cdata).replace(/\]\]>/g, "]]]]><![CDATA[>") + "]]>"
          );
        }
        if (values.forEach) {
          isStringContent = false;
          content.push("");
          values.forEach(function(value) {
            if (typeof value == "object") {
              var _name = Object.keys(value)[0];
              if (_name == "_attr") {
                get_attributes(value._attr);
              } else {
                content.push(resolve(
                  value,
                  indent,
                  indent_count + 1
                ));
              }
            } else {
              content.pop();
              isStringContent = true;
              content.push(escapeForXML(value));
            }
          });
          if (!isStringContent) {
            content.push("");
          }
        }
        break;
      default:
        content.push(escapeForXML(values));
    }
    return {
      name,
      interrupt,
      attributes,
      content,
      icount: indent_count,
      indents: indent_spaces,
      indent
    };
  }
  function format(append, elem, end) {
    if (typeof elem != "object") {
      return append(false, elem);
    }
    var len = elem.interrupt ? 1 : elem.content.length;
    function proceed() {
      while (elem.content.length) {
        var value = elem.content.shift();
        if (value === void 0)
          continue;
        if (interrupt(value))
          return;
        format(append, value);
      }
      append(false, (len > 1 ? elem.indents : "") + (elem.name ? "</" + elem.name + ">" : "") + (elem.indent && !end ? "\n" : ""));
      if (end) {
        end();
      }
    }
    function interrupt(value) {
      if (value.interrupt) {
        value.interrupt.append = append;
        value.interrupt.end = proceed;
        value.interrupt = false;
        append(true);
        return true;
      }
      return false;
    }
    append(false, elem.indents + (elem.name ? "<" + elem.name : "") + (elem.attributes.length ? " " + elem.attributes.join(" ") : "") + (len ? elem.name ? ">" : "" : elem.name ? "/>" : "") + (elem.indent && len > 1 ? "\n" : ""));
    if (!len) {
      return append(false, elem.indent ? "\n" : "");
    }
    if (!interrupt(elem)) {
      proceed();
    }
  }
  function attribute(key, value) {
    return key + '="' + escapeForXML(value) + '"';
  }
  xml$2.exports = xml;
  xml$2.exports.element = xml$2.exports.Element = element;
  var xmlExports = xml$2.exports;
  var xml$1 = /* @__PURE__ */ getDefaultExportFromCjs(xmlExports);
  var Formatter = class {
    // tslint:disable-next-line: no-object-literal-type-assertion
    format(input, context = { stack: [] }) {
      const output = input.prepForXml(context);
      if (output) {
        return output;
      } else {
        throw Error("XMLComponent did not format correctly");
      }
    }
  };
  var ImageReplacer = class {
    replace(xmlData, mediaData, offset) {
      let currentXmlData = xmlData;
      mediaData.forEach((image, i) => {
        currentXmlData = currentXmlData.replace(new RegExp(`{${image.fileName}}`, "g"), (offset + i).toString());
      });
      return currentXmlData;
    }
    getMediaData(xmlData, media) {
      return media.Array.filter((image) => xmlData.search(`{${image.fileName}}`) > 0);
    }
  };
  var NumberingReplacer = class {
    replace(xmlData, concreteNumberings) {
      let currentXmlData = xmlData;
      for (const concreteNumbering of concreteNumberings) {
        currentXmlData = currentXmlData.replace(
          new RegExp(`{${concreteNumbering.reference}-${concreteNumbering.instance}}`, "g"),
          concreteNumbering.numId.toString()
        );
      }
      return currentXmlData;
    }
  };
  var Compiler = class {
    constructor() {
      __publicField(this, "formatter");
      __publicField(this, "imageReplacer");
      __publicField(this, "numberingReplacer");
      this.formatter = new Formatter();
      this.imageReplacer = new ImageReplacer();
      this.numberingReplacer = new NumberingReplacer();
    }
    compile(file, prettifyXml) {
      const zip = new JSZip();
      const xmlifiedFileMapping = this.xmlifyFile(file, prettifyXml);
      const map = new Map(Object.entries(xmlifiedFileMapping));
      for (const [, obj] of map) {
        if (Array.isArray(obj)) {
          for (const subFile of obj) {
            zip.file(subFile.path, subFile.data);
          }
        } else {
          zip.file(obj.path, obj.data);
        }
      }
      for (const { stream, fileName } of file.Media.Array) {
        zip.file(`word/media/${fileName}`, stream);
      }
      return zip;
    }
    xmlifyFile(file, prettify) {
      const documentRelationshipCount = file.Document.Relationships.RelationshipCount + 1;
      const documentXmlData = xml$1(
        this.formatter.format(file.Document.View, {
          viewWrapper: file.Document,
          file,
          stack: []
        }),
        {
          indent: prettify,
          declaration: {
            standalone: "yes",
            encoding: "UTF-8"
          }
        }
      );
      const documentMediaDatas = this.imageReplacer.getMediaData(documentXmlData, file.Media);
      return {
        Relationships: {
          data: (() => {
            documentMediaDatas.forEach((mediaData, i) => {
              file.Document.Relationships.createRelationship(
                documentRelationshipCount + i,
                "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
                `media/${mediaData.fileName}`
              );
            });
            return xml$1(
              this.formatter.format(file.Document.Relationships, {
                viewWrapper: file.Document,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  encoding: "UTF-8"
                }
              }
            );
          })(),
          path: "word/_rels/document.xml.rels"
        },
        Document: {
          data: (() => {
            const xmlData = this.imageReplacer.replace(documentXmlData, documentMediaDatas, documentRelationshipCount);
            const referenedXmlData = this.numberingReplacer.replace(xmlData, file.Numbering.ConcreteNumbering);
            return referenedXmlData;
          })(),
          path: "word/document.xml"
        },
        Styles: {
          data: (() => {
            const xmlStyles = xml$1(
              this.formatter.format(file.Styles, {
                viewWrapper: file.Document,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  standalone: "yes",
                  encoding: "UTF-8"
                }
              }
            );
            const referencedXmlStyles = this.numberingReplacer.replace(xmlStyles, file.Numbering.ConcreteNumbering);
            return referencedXmlStyles;
          })(),
          path: "word/styles.xml"
        },
        Properties: {
          data: xml$1(
            this.formatter.format(file.CoreProperties, {
              viewWrapper: file.Document,
              file,
              stack: []
            }),
            {
              indent: prettify,
              declaration: {
                standalone: "yes",
                encoding: "UTF-8"
              }
            }
          ),
          path: "docProps/core.xml"
        },
        Numbering: {
          data: xml$1(
            this.formatter.format(file.Numbering, {
              viewWrapper: file.Document,
              file,
              stack: []
            }),
            {
              indent: prettify,
              declaration: {
                standalone: "yes",
                encoding: "UTF-8"
              }
            }
          ),
          path: "word/numbering.xml"
        },
        FileRelationships: {
          data: xml$1(
            this.formatter.format(file.FileRelationships, {
              viewWrapper: file.Document,
              file,
              stack: []
            }),
            {
              indent: prettify,
              declaration: {
                encoding: "UTF-8"
              }
            }
          ),
          path: "_rels/.rels"
        },
        HeaderRelationships: file.Headers.map((headerWrapper, index) => {
          const xmlData = xml$1(
            this.formatter.format(headerWrapper.View, {
              viewWrapper: headerWrapper,
              file,
              stack: []
            }),
            {
              indent: prettify,
              declaration: {
                encoding: "UTF-8"
              }
            }
          );
          const mediaDatas = this.imageReplacer.getMediaData(xmlData, file.Media);
          mediaDatas.forEach((mediaData, i) => {
            headerWrapper.Relationships.createRelationship(
              i,
              "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
              `media/${mediaData.fileName}`
            );
          });
          return {
            data: xml$1(
              this.formatter.format(headerWrapper.Relationships, {
                viewWrapper: headerWrapper,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  encoding: "UTF-8"
                }
              }
            ),
            path: `word/_rels/header${index + 1}.xml.rels`
          };
        }),
        FooterRelationships: file.Footers.map((footerWrapper, index) => {
          const xmlData = xml$1(
            this.formatter.format(footerWrapper.View, {
              viewWrapper: footerWrapper,
              file,
              stack: []
            }),
            {
              indent: prettify,
              declaration: {
                encoding: "UTF-8"
              }
            }
          );
          const mediaDatas = this.imageReplacer.getMediaData(xmlData, file.Media);
          mediaDatas.forEach((mediaData, i) => {
            footerWrapper.Relationships.createRelationship(
              i,
              "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
              `media/${mediaData.fileName}`
            );
          });
          return {
            data: xml$1(
              this.formatter.format(footerWrapper.Relationships, {
                viewWrapper: footerWrapper,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  encoding: "UTF-8"
                }
              }
            ),
            path: `word/_rels/footer${index + 1}.xml.rels`
          };
        }),
        Headers: file.Headers.map((headerWrapper, index) => {
          const tempXmlData = xml$1(
            this.formatter.format(headerWrapper.View, {
              viewWrapper: headerWrapper,
              file,
              stack: []
            }),
            {
              indent: prettify,
              declaration: {
                encoding: "UTF-8"
              }
            }
          );
          const mediaDatas = this.imageReplacer.getMediaData(tempXmlData, file.Media);
          const xmlData = this.imageReplacer.replace(tempXmlData, mediaDatas, 0);
          const referenedXmlData = this.numberingReplacer.replace(xmlData, file.Numbering.ConcreteNumbering);
          return {
            data: referenedXmlData,
            path: `word/header${index + 1}.xml`
          };
        }),
        Footers: file.Footers.map((footerWrapper, index) => {
          const tempXmlData = xml$1(
            this.formatter.format(footerWrapper.View, {
              viewWrapper: footerWrapper,
              file,
              stack: []
            }),
            {
              indent: prettify,
              declaration: {
                encoding: "UTF-8"
              }
            }
          );
          const mediaDatas = this.imageReplacer.getMediaData(tempXmlData, file.Media);
          const xmlData = this.imageReplacer.replace(tempXmlData, mediaDatas, 0);
          const referenedXmlData = this.numberingReplacer.replace(xmlData, file.Numbering.ConcreteNumbering);
          return {
            data: referenedXmlData,
            path: `word/footer${index + 1}.xml`
          };
        }),
        ContentTypes: {
          data: xml$1(
            this.formatter.format(file.ContentTypes, {
              viewWrapper: file.Document,
              file,
              stack: []
            }),
            {
              indent: prettify,
              declaration: {
                encoding: "UTF-8"
              }
            }
          ),
          path: "[Content_Types].xml"
        },
        CustomProperties: {
          data: xml$1(
            this.formatter.format(file.CustomProperties, {
              viewWrapper: file.Document,
              file,
              stack: []
            }),
            {
              indent: prettify,
              declaration: {
                standalone: "yes",
                encoding: "UTF-8"
              }
            }
          ),
          path: "docProps/custom.xml"
        },
        AppProperties: {
          data: xml$1(
            this.formatter.format(file.AppProperties, {
              viewWrapper: file.Document,
              file,
              stack: []
            }),
            {
              indent: prettify,
              declaration: {
                standalone: "yes",
                encoding: "UTF-8"
              }
            }
          ),
          path: "docProps/app.xml"
        },
        FootNotes: {
          data: xml$1(
            this.formatter.format(file.FootNotes.View, {
              viewWrapper: file.FootNotes,
              file,
              stack: []
            }),
            {
              indent: prettify,
              declaration: {
                encoding: "UTF-8"
              }
            }
          ),
          path: "word/footnotes.xml"
        },
        FootNotesRelationships: {
          data: xml$1(
            this.formatter.format(file.FootNotes.Relationships, {
              viewWrapper: file.FootNotes,
              file,
              stack: []
            }),
            {
              indent: prettify,
              declaration: {
                encoding: "UTF-8"
              }
            }
          ),
          path: "word/_rels/footnotes.xml.rels"
        },
        Settings: {
          data: xml$1(
            this.formatter.format(file.Settings, {
              viewWrapper: file.Document,
              file,
              stack: []
            }),
            {
              indent: prettify,
              declaration: {
                standalone: "yes",
                encoding: "UTF-8"
              }
            }
          ),
          path: "word/settings.xml"
        },
        Comments: {
          data: xml$1(
            this.formatter.format(file.Comments, {
              viewWrapper: file.Document,
              file,
              stack: []
            }),
            {
              indent: prettify,
              declaration: {
                standalone: "yes",
                encoding: "UTF-8"
              }
            }
          ),
          path: "word/comments.xml"
        }
      };
    }
  };
  var convertPrettifyType = (prettify) => prettify === true ? "  " : prettify === false ? void 0 : prettify;
  var Packer = class {
    static async toString(file, prettify) {
      const zip = this.compiler.compile(file, convertPrettifyType(prettify));
      const zipData = await zip.generateAsync({
        type: "string",
        mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        compression: "DEFLATE"
      });
      return zipData;
    }
    static async toBuffer(file, prettify) {
      const zip = this.compiler.compile(file, convertPrettifyType(prettify));
      const zipData = await zip.generateAsync({
        type: "nodebuffer",
        mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        compression: "DEFLATE"
      });
      return zipData;
    }
    static async toBase64String(file, prettify) {
      const zip = this.compiler.compile(file, convertPrettifyType(prettify));
      const zipData = await zip.generateAsync({
        type: "base64",
        mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        compression: "DEFLATE"
      });
      return zipData;
    }
    static async toBlob(file, prettify) {
      const zip = this.compiler.compile(file, convertPrettifyType(prettify));
      const zipData = await zip.generateAsync({
        type: "blob",
        mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        compression: "DEFLATE"
      });
      return zipData;
    }
    static toStream(file, prettify) {
      const stream = new streamBrowserify.Stream();
      const zip = this.compiler.compile(file, convertPrettifyType(prettify));
      zip.generateAsync({
        type: "nodebuffer",
        mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        compression: "DEFLATE"
      }).then((z) => {
        stream.emit("data", z);
        stream.emit("end");
      });
      return stream;
    }
  };
  __publicField(Packer, "compiler", new Compiler());
  var formatter$1 = new Formatter();
  var formatter = new Formatter();
  var imageReplacer = new ImageReplacer();

  // src/lib/Relation.ts
  var import_typebox = __toESM(require_typebox(), 1);

  // src/lib/store.ts
  var setMapValue = (map, key, value) => {
    if (map.has(key)) {
      throw new Error(`Value already exists.`);
    }
    map.set(key, { value });
  };
  var getMapValue = (map, key) => map.get(key);
  var removeCallback = (callbacks, callback) => {
    callbacks?.splice(callbacks.indexOf(callback), 1);
  };
  var findLastFrom = (arr, index, callback) => {
    for (let i = index; i >= 0; i -= 1) {
      if (callback(arr[i])) {
        return arr[i];
      }
    }
    return void 0;
  };
  var Store = class _Store {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    constructor() {
    }
    static isGlobalRendering = false;
    static parser;
    static renderer;
    static globalValues = /* @__PURE__ */ new WeakMap();
    static globalCallbacks = [];
    static nodeValues = [];
    static nodeCallbacks = [];
    static currentNodeIndex = -1;
    static initGlobal({
      renderer,
      parser
    }) {
      if (_Store.isGlobalRendering) {
        throw new Error("Do not use multiple renderers at once.");
      }
      _Store.clearGlobal();
      _Store.isGlobalRendering = true;
      _Store.parser = parser;
      _Store.renderer = renderer;
    }
    static getIsRendering() {
      return _Store.isGlobalRendering;
    }
    static getParser() {
      _Store.checkIfGlobalRendering();
      return _Store.parser;
    }
    static getRenderer() {
      _Store.checkIfGlobalRendering();
      return _Store.renderer;
    }
    static setGlobalValue(key, value) {
      setMapValue(_Store.globalValues, key, value);
    }
    static getGlobalValue(key) {
      return getMapValue(_Store.globalValues, key);
    }
    static addGlobalCallback(callback) {
      _Store.checkIfGlobalRendering();
      _Store.globalCallbacks.push(callback);
    }
    static removeGlobalCallback(callback) {
      _Store.checkIfGlobalRendering();
      removeCallback(_Store.globalCallbacks, callback);
    }
    static initNode() {
      _Store.checkIfGlobalRendering();
      _Store.currentNodeIndex += 1;
    }
    static setNodeValue(key, value) {
      _Store.checkIfGlobalRendering();
      const nodeValues = _Store.nodeValues[_Store.currentNodeIndex] ??= /* @__PURE__ */ new Map();
      setMapValue(nodeValues, key, value);
    }
    static getLastNodeValue(key) {
      _Store.checkIfGlobalRendering();
      return findLastFrom(
        _Store.nodeValues,
        _Store.currentNodeIndex,
        (map) => map?.has(key)
      )?.get(key);
    }
    static addNodeCallback(callback) {
      _Store.checkIfGlobalRendering();
      const nodeValues = _Store.nodeCallbacks[_Store.currentNodeIndex] ??= [];
      nodeValues.push(callback);
    }
    static removeNodeCallback(callback) {
      _Store.checkIfGlobalRendering();
      removeCallback(_Store.nodeCallbacks[_Store.currentNodeIndex], callback);
    }
    static completeNode() {
      _Store.checkIfGlobalRendering();
      _Store.callNodeCallbacks();
      _Store.clearNode();
    }
    static clearNode() {
      _Store.nodeValues.splice(_Store.currentNodeIndex);
      _Store.nodeCallbacks.splice(_Store.currentNodeIndex);
      _Store.currentNodeIndex -= 1;
    }
    static completeGlobal() {
      _Store.callGlobalCallbacks();
      _Store.clearGlobal();
    }
    static clearGlobal() {
      _Store.isGlobalRendering = false;
      _Store.parser = void 0;
      _Store.renderer = void 0;
      _Store.globalCallbacks.splice(0);
      _Store.nodeValues.splice(0);
      _Store.nodeCallbacks.splice(0);
      _Store.currentNodeIndex = -1;
    }
    static callGlobalCallbacks() {
      _Store.checkIfGlobalRendering();
      _Store.globalCallbacks.forEach((callback) => callback());
    }
    static callNodeCallbacks() {
      _Store.checkIfGlobalRendering();
      _Store.nodeCallbacks[_Store.currentNodeIndex]?.forEach(
        (callback) => callback()
      );
    }
    static checkIfGlobalRendering() {
      if (_Store.isGlobalRendering !== true) {
        throw new Error("Document is not currently rendering.");
      }
    }
  };

  // src/lib/Relation.ts
  import_typebox.TypeRegistry.Set("Node", () => true);
  var Relation = ({ type, required, single }) => {
    const typesArr = asArray(type);
    return import_typebox.Type.Transform(
      import_typebox.Type.Unsafe({
        [import_typebox.Kind]: "Node"
      })
    ).Decode(() => {
      throw new Error("Decode not implemented.");
    }).Encode((node) => {
      const renderer = Store.getRenderer();
      const parser = Store.getParser();
      const elements = parser(node).map((element2) => {
        if (!typesArr.includes(element2.type)) {
          throw new TypeError(
            `Expected child element "${element2.type}" to be of type "${typesArr.join(" or ")}".`
          );
        }
        return renderer(element2);
      });
      if (required && elements.length === 0) {
        throw new TypeError("At least one child element required.");
      }
      if (single) {
        if (elements.length > 1) {
          throw new TypeError("Received more than one child element.");
        }
        return elements[0];
      }
      return elements;
    });
  };

  // src/entities/schema.ts
  var pageTypeSchema = import_typebox2.Type.Object({
    header: import_typebox2.Type.Optional(Relation({ type: ["header"], single: true })),
    footer: import_typebox2.Type.Optional(Relation({ type: ["footer"], single: true }))
  });
  var elementSchemas = {
    document: import_typebox2.Type.Object({
      children: Relation({ type: "pagesGroup", required: true })
    }),
    pagesGroup: import_typebox2.Type.Object({
      pageTypes: import_typebox2.Type.Partial(
        import_typebox2.Type.Object({
          default: pageTypeSchema,
          first: pageTypeSchema,
          even: pageTypeSchema,
          odd: pageTypeSchema
        })
      ),
      headers: import_typebox2.Type.Optional(
        import_typebox2.Type.Partial(
          import_typebox2.Type.Object({
            default: Relation({ type: "header", single: true }),
            first: Relation({ type: "header", single: true }),
            even: Relation({ type: "header", single: true }),
            odd: Relation({ type: "header", single: true })
          })
        )
      ),
      children: Relation({
        type: ["paragraph", "table"],
        required: true
      }),
      footers: import_typebox2.Type.Optional(
        import_typebox2.Type.Partial(
          import_typebox2.Type.Object({
            default: Relation({ type: "footer", single: true }),
            first: Relation({ type: "footer", single: true }),
            even: Relation({ type: "footer", single: true }),
            odd: Relation({ type: "footer", single: true })
          })
        )
      )
    }),
    header: import_typebox2.Type.Object({
      children: Relation({
        type: ["paragraph", "table"],
        required: true
      })
    }),
    footer: import_typebox2.Type.Object({
      children: Relation({
        type: ["paragraph", "table"],
        required: true
      })
    }),
    paragraph: import_typebox2.Type.Object({
      children: Relation({ type: "textrun" })
    }),
    textrun: import_typebox2.Type.Object({
      children: Relation({ type: "textrun" })
    }),
    table: import_typebox2.Type.Never({})
  };

  // src/lib/pager/createCss.ts
  var getDataSelector = (pagesGroupId) => `[${PAGES_GROUP_DATA_ATTRIBUTE}="${pagesGroupId}"]`;
  var getPageTypeSelector = (pagesGroupId, pageType) => {
    assertPageType(pageType);
    const baseSelector = `.pagedjs_named_page.pagedjs_${pagesGroupId}_page`;
    switch (pageType) {
      case "default":
        return baseSelector;
      case "first":
        return baseSelector + ".pagedjs_first_page";
      case "even":
        return baseSelector + ".pagedjs_even_page";
      case "odd":
        return baseSelector + ".pagedjs_odd_page";
      default:
        throw new TypeError(`Invalid page type "${pageType}".`);
    }
  };
  var getAtPageSelector = (pagesGroupId, pageType) => {
    assertPageType(pageType);
    switch (pageType) {
      case "default":
        return `@page ${pagesGroupId}`;
      case "first":
        return `@page ${pagesGroupId}:first`;
      case "even":
        return `@page ${pagesGroupId}:left`;
      case "odd":
        return `@page ${pagesGroupId}:right`;
      default:
        throw new TypeError(`Invalid page type "${pageType}".`);
    }
  };
  var createPagesGroupCss = (pagesGroupId) => [
    `${getDataSelector(pagesGroupId)} {
${jsToCss({
      page: pagesGroupId
    })}}`
  ].join("\n") + "\n";
  var createPageCss = (pagesGroupId, pageType, { width, height, marginTop, marginRight, marginBottom, marginLeft }) => [
    `${getAtPageSelector(pagesGroupId, pageType)} {
${jsToCss({
      size: `${width} ${height}`,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft
    })}}`,
    `${getPageTypeSelector(pagesGroupId, pageType)} {
${jsToCss({
      position: "relative",
      overflow: "hidden",
      width,
      height
    })}}`,
    `${getPageTypeSelector(
      pagesGroupId,
      pageType
    )} .${HEADER_CLASS_NAME} {
${jsToCss({
      bottom: `calc(100% - ${marginTop})`,
      display: "block",
      position: "absolute"
    })}}`,
    `${getPageTypeSelector(
      pagesGroupId,
      pageType
    )} .${FOOTER_CLASS_NAME} {
${jsToCss({
      top: `calc(100% - ${marginTop})`,
      display: "block",
      position: "absolute"
    })}}`
  ].join("\n") + "\n";

  // src/lib/pager/createPageRenderer.ts
  var createRenderer = ({ pagesGroups }) => {
    let documentHtml = "";
    let documentCss = "";
    const pagesGroupsData = {};
    pagesGroups.forEach(({ contentHtml, id, pageTypes }) => {
      if (!contentHtml) {
        return;
      }
      const pagesGroupId = `${PREFIX}_${id}`;
      documentCss += createPagesGroupCss(pagesGroupId);
      pagesGroupsData[pagesGroupId] = mapPageTypes(
        parsePageTypes(pageTypes),
        (pageType, {
          headerHtml,
          footerHtml,
          width,
          height,
          marginTop,
          marginRight,
          marginBottom,
          marginLeft
        }) => {
          const headerEl = createEl(headerHtml, {
            class: HEADER_CLASS_NAME
          });
          const footerEl = createEl(footerHtml, {
            class: FOOTER_CLASS_NAME
          });
          documentCss += createPageCss(pagesGroupId, pageType, {
            width,
            height,
            marginTop: mathUnits("add", marginTop, getElHeight(headerEl, width)),
            marginRight,
            marginBottom: mathUnits(
              "add",
              marginBottom,
              getElHeight(footerEl, width)
            ),
            marginLeft
          });
          return {
            headerEl,
            footerEl
          };
        }
      );
      documentHtml += createHtml(contentHtml, {
        [PAGES_GROUP_DATA_ATTRIBUTE]: pagesGroupId,
        class: PAGES_GROUP_CLASS_NAME
      });
    });
    const pageHandler = (pageEl, pagesGroupId, pageType) => {
      const data = pagesGroupsData[pagesGroupId];
      const { headerEl, footerEl } = data[pageType];
      appendCloneTo(pageEl, headerEl);
      appendCloneTo(pageEl, footerEl);
    };
    return { documentHtml, documentCss, pageHandler };
  };

  // src/lib/pager/createPreviewer.ts
  var previewer = new previewer_default();
  var createPreviewer = async (rootElement, documentOptions) => {
    const { documentHtml, documentCss, pageHandler } = createRenderer(documentOptions);
    addStyleSheet(documentCss);
    const unregister = registerPageHandler(pageHandler);
    await previewer.preview(documentHtml, [{ _: documentCss }], rootElement);
    unregister();
  };

  // src/headless.ts
  var rootEl = document.createElement("div");
  document.body.appendChild(rootEl);
  var globalObj = {
    renderPages: (document2) => createPreviewer(rootEl, document2)
  };
  window.headless = globalObj;
  return __toCommonJS(headless_exports);
})();
/*! Bundled license information:

docx/build/index.mjs:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)
*/
